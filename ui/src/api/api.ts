/* tslint:disable */
/* eslint-disable */
/**
 * OptiPrism
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api@optiprism.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'createdBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'updatedBy'?: number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'role'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof Account
     */
    'teams'?: Array<number>;
    /**
     * 
     * @type {Array<AccountProjectsInner>}
     * @memberof Account
     */
    'projects'?: Array<AccountProjectsInner>;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface AccountProjectsInner
 */
export interface AccountProjectsInner {
    /**
     * 
     * @type {number}
     * @memberof AccountProjectsInner
     */
    'projectId'?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountProjectsInner
     */
    'role'?: string;
}
/**
 * 
 * @export
 * @interface AnalysisCumulative
 */
export interface AnalysisCumulative {
    /**
     * 
     * @type {string}
     * @memberof AnalysisCumulative
     */
    'type'?: AnalysisCumulativeTypeEnum;
}

export const AnalysisCumulativeTypeEnum = {
    Cumulative: 'cumulative'
} as const;

export type AnalysisCumulativeTypeEnum = typeof AnalysisCumulativeTypeEnum[keyof typeof AnalysisCumulativeTypeEnum];

/**
 * 
 * @export
 * @interface AnalysisLinear
 */
export interface AnalysisLinear {
    /**
     * 
     * @type {string}
     * @memberof AnalysisLinear
     */
    'type'?: AnalysisLinearTypeEnum;
}

export const AnalysisLinearTypeEnum = {
    Linear: 'linear'
} as const;

export type AnalysisLinearTypeEnum = typeof AnalysisLinearTypeEnum[keyof typeof AnalysisLinearTypeEnum];

/**
 * 
 * @export
 * @interface AnalysisRollingAverage
 */
export interface AnalysisRollingAverage {
    /**
     * 
     * @type {string}
     * @memberof AnalysisRollingAverage
     */
    'type'?: AnalysisRollingAverageTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof AnalysisRollingAverage
     */
    'window'?: number;
}

export const AnalysisRollingAverageTypeEnum = {
    RollingAverage: 'rollingAverage'
} as const;

export type AnalysisRollingAverageTypeEnum = typeof AnalysisRollingAverageTypeEnum[keyof typeof AnalysisRollingAverageTypeEnum];

/**
 * 
 * @export
 * @interface AnalysisRollingWindow
 */
export interface AnalysisRollingWindow {
    /**
     * 
     * @type {string}
     * @memberof AnalysisRollingWindow
     */
    'type'?: AnalysisRollingWindowTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof AnalysisRollingWindow
     */
    'window'?: number;
}

export const AnalysisRollingWindowTypeEnum = {
    RollingWindow: 'rollingWindow'
} as const;

export type AnalysisRollingWindowTypeEnum = typeof AnalysisRollingWindowTypeEnum[keyof typeof AnalysisRollingWindowTypeEnum];

/**
 * 
 * @export
 * @interface AuthAccess200Response
 */
export interface AuthAccess200Response {
    /**
     * 
     * @type {string}
     * @memberof AuthAccess200Response
     */
    'accessToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthAccess200Response
     */
    'refreshToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthAccess200Response
     */
    'csrfToken'?: string;
}
/**
 * 
 * @export
 * @interface AuthAccessRequest
 */
export interface AuthAccessRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthAccessRequest
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface BasicLogin200Response
 */
export interface BasicLogin200Response {
    /**
     * 
     * @type {string}
     * @memberof BasicLogin200Response
     */
    'accessToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof BasicLogin200Response
     */
    'refreshToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof BasicLogin200Response
     */
    'csrfToken'?: string;
}
/**
 * 
 * @export
 * @interface BasicLoginRequest
 */
export interface BasicLoginRequest {
    /**
     * 
     * @type {string}
     * @memberof BasicLoginRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof BasicLoginRequest
     */
    'password': string;
}
/**
 * breakdown by property.
 * @export
 * @interface BreakdownByProperty
 */
export interface BreakdownByProperty {
    /**
     * 
     * @type {string}
     * @memberof BreakdownByProperty
     */
    'type'?: BreakdownByPropertyTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof BreakdownByProperty
     */
    'propertyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof BreakdownByProperty
     */
    'propertyType': BreakdownByPropertyPropertyTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof BreakdownByProperty
     */
    'propertyId'?: number;
}

export const BreakdownByPropertyTypeEnum = {
    Property: 'property'
} as const;

export type BreakdownByPropertyTypeEnum = typeof BreakdownByPropertyTypeEnum[keyof typeof BreakdownByPropertyTypeEnum];
export const BreakdownByPropertyPropertyTypeEnum = {
    Custom: 'custom',
    Event: 'event',
    User: 'user'
} as const;

export type BreakdownByPropertyPropertyTypeEnum = typeof BreakdownByPropertyPropertyTypeEnum[keyof typeof BreakdownByPropertyPropertyTypeEnum];

/**
 * Custom Event is an alias to an expression which is used while querying. You can use regular or custom events in expression. You can combine events in expression, you can use filter by properties.
 * @export
 * @interface CreateCustomEventRequest
 */
export interface CreateCustomEventRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCustomEventRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomEventRequest
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateCustomEventRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<CustomEventEvent>}
     * @memberof CreateCustomEventRequest
     */
    'events': Array<CustomEventEvent>;
}
/**
 * Custom Event is an alias to an expression which is used while querying. You can use regular or custom events in expression. You can combine events in expression, you can use filter by properties.
 * @export
 * @interface CustomEvent
 */
export interface CustomEvent {
    /**
     * 
     * @type {number}
     * @memberof CustomEvent
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CustomEvent
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CustomEvent
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof CustomEvent
     */
    'createdBy': number;
    /**
     * 
     * @type {number}
     * @memberof CustomEvent
     */
    'updatedBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomEvent
     */
    'projectId': number;
    /**
     * 
     * @type {boolean}
     * @memberof CustomEvent
     */
    'isSystem': boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomEvent
     */
    'status': CustomEventStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CustomEvent
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CustomEvent
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CustomEvent
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<CustomEventEvent>}
     * @memberof CustomEvent
     */
    'events'?: Array<CustomEventEvent>;
}

export const CustomEventStatusEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type CustomEventStatusEnum = typeof CustomEventStatusEnum[keyof typeof CustomEventStatusEnum];

/**
 * custom event will matches all of the provided events
 * @export
 * @interface CustomEventEvent
 */
export interface CustomEventEvent {
    /**
     * 
     * @type {string}
     * @memberof CustomEventEvent
     */
    'eventName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomEventEvent
     */
    'eventType': CustomEventEventEventTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof CustomEventEvent
     */
    'eventId'?: number;
    /**
     * array of event filters
     * @type {Array<EventFilterByProperty>}
     * @memberof CustomEventEvent
     */
    'filters': Array<EventFilterByProperty>;
}

export const CustomEventEventEventTypeEnum = {
    Custom: 'custom'
} as const;

export type CustomEventEventEventTypeEnum = typeof CustomEventEventEventTypeEnum[keyof typeof CustomEventEventEventTypeEnum];

/**
 * 
 * @export
 * @interface CustomEventEventAllOf
 */
export interface CustomEventEventAllOf {
    /**
     * array of event filters
     * @type {Array<EventFilterByProperty>}
     * @memberof CustomEventEventAllOf
     */
    'filters'?: Array<EventFilterByProperty>;
}
/**
 * 
 * @export
 * @interface CustomEventsList200Response
 */
export interface CustomEventsList200Response {
    /**
     * 
     * @type {Array<CustomEvent>}
     * @memberof CustomEventsList200Response
     */
    'events'?: Array<CustomEvent>;
    /**
     * 
     * @type {ListResponseMetadataMeta}
     * @memberof CustomEventsList200Response
     */
    'meta'?: ListResponseMetadataMeta;
}
/**
 * 
 * @export
 * @interface CustomEventsList200ResponseAllOf
 */
export interface CustomEventsList200ResponseAllOf {
    /**
     * 
     * @type {Array<CustomEvent>}
     * @memberof CustomEventsList200ResponseAllOf
     */
    'events'?: Array<CustomEvent>;
}
/**
 * 
 * @export
 * @interface CustomPropertiesList200Response
 */
export interface CustomPropertiesList200Response {
    /**
     * 
     * @type {Array<CustomProperty>}
     * @memberof CustomPropertiesList200Response
     */
    'events'?: Array<CustomProperty>;
    /**
     * 
     * @type {ListResponseMetadataMeta}
     * @memberof CustomPropertiesList200Response
     */
    'meta'?: ListResponseMetadataMeta;
}
/**
 * 
 * @export
 * @interface CustomPropertiesList200ResponseAllOf
 */
export interface CustomPropertiesList200ResponseAllOf {
    /**
     * 
     * @type {Array<CustomProperty>}
     * @memberof CustomPropertiesList200ResponseAllOf
     */
    'events'?: Array<CustomProperty>;
}
/**
 * 
 * @export
 * @interface CustomProperty
 */
export interface CustomProperty {
    /**
     * 
     * @type {number}
     * @memberof CustomProperty
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomProperty
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomProperty
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof CustomProperty
     */
    'createdBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomProperty
     */
    'updatedBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomProperty
     */
    'projectId'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof CustomProperty
     */
    'events'?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof CustomProperty
     */
    'isSystem'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomProperty
     */
    'status'?: CustomPropertyStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CustomProperty
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomProperty
     */
    'description'?: string;
    /**
     * 
     * @type {DataType}
     * @memberof CustomProperty
     */
    'type'?: DataType;
    /**
     * 
     * @type {boolean}
     * @memberof CustomProperty
     */
    'nullable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomProperty
     */
    'isArray'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CustomProperty
     */
    'tags'?: Array<string>;
}

export const CustomPropertyStatusEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type CustomPropertyStatusEnum = typeof CustomPropertyStatusEnum[keyof typeof CustomPropertyStatusEnum];

/**
 * 
 * @export
 * @interface DataTableResponse
 */
export interface DataTableResponse {
    /**
     * 
     * @type {Array<DataTableResponseColumnsInner>}
     * @memberof DataTableResponse
     */
    'columns'?: Array<DataTableResponseColumnsInner>;
}
/**
 * 
 * @export
 * @interface DataTableResponseColumnsInner
 */
export interface DataTableResponseColumnsInner {
    /**
     * 
     * @type {string}
     * @memberof DataTableResponseColumnsInner
     */
    'type'?: DataTableResponseColumnsInnerTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof DataTableResponseColumnsInner
     */
    'step'?: number;
    /**
     * 
     * @type {DataType}
     * @memberof DataTableResponseColumnsInner
     */
    'dataType'?: DataType;
    /**
     * 
     * @type {string}
     * @memberof DataTableResponseColumnsInner
     */
    'name'?: string;
    /**
     * 
     * @type {PropertyValuesList200ResponseValues}
     * @memberof DataTableResponseColumnsInner
     */
    'values'?: PropertyValuesList200ResponseValues;
    /**
     * 
     * @type {PropertyValuesList200ResponseValues}
     * @memberof DataTableResponseColumnsInner
     */
    'compareValues'?: PropertyValuesList200ResponseValues;
}

export const DataTableResponseColumnsInnerTypeEnum = {
    Dimension: 'dimension',
    Metric: 'metric',
    MetricValue: 'metricValue',
    FunnelMetricValue: 'funnelMetricValue'
} as const;

export type DataTableResponseColumnsInnerTypeEnum = typeof DataTableResponseColumnsInnerTypeEnum[keyof typeof DataTableResponseColumnsInnerTypeEnum];

/**
 * data type
 * @export
 * @enum {string}
 */

export const DataType = {
    String: 'string',
    Number: 'number',
    Boolean: 'boolean'
} as const;

export type DataType = typeof DataType[keyof typeof DataType];


/**
 * aggregate property and compare to value
 * @export
 * @interface DidEventAggregateProperty
 */
export interface DidEventAggregateProperty {
    /**
     * 
     * @type {string}
     * @memberof DidEventAggregateProperty
     */
    'type': DidEventAggregatePropertyTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DidEventAggregateProperty
     */
    'propertyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidEventAggregateProperty
     */
    'propertyType': DidEventAggregatePropertyPropertyTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof DidEventAggregateProperty
     */
    'propertyId'?: number;
    /**
     * 
     * @type {QueryAggregateProperty}
     * @memberof DidEventAggregateProperty
     */
    'aggregate': QueryAggregateProperty;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof DidEventAggregateProperty
     */
    'operation': PropertyFilterOperation;
    /**
     * one or more values. Doesn\'t need if operation is \"empty\" or \"exist\"
     * @type {number}
     * @memberof DidEventAggregateProperty
     */
    'value'?: number;
    /**
     * time frame
     * @type {TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach}
     * @memberof DidEventAggregateProperty
     */
    'time': TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach;
}

export const DidEventAggregatePropertyTypeEnum = {
    AggregateProperty: 'aggregateProperty'
} as const;

export type DidEventAggregatePropertyTypeEnum = typeof DidEventAggregatePropertyTypeEnum[keyof typeof DidEventAggregatePropertyTypeEnum];
export const DidEventAggregatePropertyPropertyTypeEnum = {
    Custom: 'custom',
    Event: 'event',
    User: 'user'
} as const;

export type DidEventAggregatePropertyPropertyTypeEnum = typeof DidEventAggregatePropertyPropertyTypeEnum[keyof typeof DidEventAggregatePropertyPropertyTypeEnum];

/**
 * 
 * @export
 * @interface DidEventAggregatePropertyAllOf
 */
export interface DidEventAggregatePropertyAllOf {
    /**
     * 
     * @type {string}
     * @memberof DidEventAggregatePropertyAllOf
     */
    'type'?: DidEventAggregatePropertyAllOfTypeEnum;
}

export const DidEventAggregatePropertyAllOfTypeEnum = {
    AggregateProperty: 'aggregateProperty'
} as const;

export type DidEventAggregatePropertyAllOfTypeEnum = typeof DidEventAggregatePropertyAllOfTypeEnum[keyof typeof DidEventAggregatePropertyAllOfTypeEnum];

/**
 * 
 * @export
 * @interface DidEventAggregatePropertyAllOf1
 */
export interface DidEventAggregatePropertyAllOf1 {
    /**
     * 
     * @type {QueryAggregateProperty}
     * @memberof DidEventAggregatePropertyAllOf1
     */
    'aggregate'?: QueryAggregateProperty;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof DidEventAggregatePropertyAllOf1
     */
    'operation'?: PropertyFilterOperation;
    /**
     * one or more values. Doesn\'t need if operation is \"empty\" or \"exist\"
     * @type {number}
     * @memberof DidEventAggregatePropertyAllOf1
     */
    'value'?: number;
    /**
     * time frame
     * @type {TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach}
     * @memberof DidEventAggregatePropertyAllOf1
     */
    'time'?: TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach;
}
/**
 * find all users who made event X times
 * @export
 * @interface DidEventCount
 */
export interface DidEventCount {
    /**
     * 
     * @type {string}
     * @memberof DidEventCount
     */
    'type': DidEventCountTypeEnum;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof DidEventCount
     */
    'operation': PropertyFilterOperation;
    /**
     * one or more values. Doesn\'t need if operation is \"empty\" or \"exist\"
     * @type {number}
     * @memberof DidEventCount
     */
    'value'?: number;
    /**
     * 
     * @type {DidEventCountTime}
     * @memberof DidEventCount
     */
    'time': DidEventCountTime;
}

export const DidEventCountTypeEnum = {
    DidEventCount: 'didEventCount'
} as const;

export type DidEventCountTypeEnum = typeof DidEventCountTypeEnum[keyof typeof DidEventCountTypeEnum];

/**
 * @type DidEventCountTime
 * time frame
 * @export
 */
export type DidEventCountTime = TimeAfterFirstUse | TimeBetween | TimeLast | TimeWindowEach;

/**
 * find users with Nth event occurance
 * @export
 * @interface DidEventHistoricalCount
 */
export interface DidEventHistoricalCount {
    /**
     * 
     * @type {string}
     * @memberof DidEventHistoricalCount
     */
    'type': DidEventHistoricalCountTypeEnum;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof DidEventHistoricalCount
     */
    'operation': PropertyFilterOperation;
    /**
     * 
     * @type {number}
     * @memberof DidEventHistoricalCount
     */
    'value'?: number;
    /**
     * 
     * @type {DidEventRelativeCountTime}
     * @memberof DidEventHistoricalCount
     */
    'time': DidEventRelativeCountTime;
}

export const DidEventHistoricalCountTypeEnum = {
    HistoricalCount: 'historicalCount'
} as const;

export type DidEventHistoricalCountTypeEnum = typeof DidEventHistoricalCountTypeEnum[keyof typeof DidEventHistoricalCountTypeEnum];

/**
 * find all users who made left event X time more/less than right event.
 * @export
 * @interface DidEventRelativeCount
 */
export interface DidEventRelativeCount {
    /**
     * 
     * @type {string}
     * @memberof DidEventRelativeCount
     */
    'type': DidEventRelativeCountTypeEnum;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof DidEventRelativeCount
     */
    'operation': PropertyFilterOperation;
    /**
     * 
     * @type {EventRef}
     * @memberof DidEventRelativeCount
     */
    'rightEvent': EventRef;
    /**
     * 
     * @type {DidEventRelativeCountTime}
     * @memberof DidEventRelativeCount
     */
    'time': DidEventRelativeCountTime;
}

export const DidEventRelativeCountTypeEnum = {
    DidEventRelativeCount: 'didEventRelativeCount'
} as const;

export type DidEventRelativeCountTypeEnum = typeof DidEventRelativeCountTypeEnum[keyof typeof DidEventRelativeCountTypeEnum];

/**
 * @type DidEventRelativeCountTime
 * @export
 */
export type DidEventRelativeCountTime = TimeAfterFirstUse | TimeBetween | TimeLast | TimeWindowEach;

/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'code'?: ErrorResponseCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<{ [key: string]: string; }>}
     * @memberof ErrorResponse
     */
    'fields'?: Array<{ [key: string]: string; }>;
}

export const ErrorResponseCodeEnum = {
    _1000InvalidToken: '1000_invalid_token'
} as const;

export type ErrorResponseCodeEnum = typeof ErrorResponseCodeEnum[keyof typeof ErrorResponseCodeEnum];

/**
 * Event describes user event. User event is an action which user (client) might do on a product site/app. For instance, user might do a signup and it might be a \"Sign up\" event. Event Also has a properties. <br/><br/> Name must be unique among project events, including custom ones. E.g. you can\'t have multiple \"Sign up\" events. <br/><br/> Normally events are created and updated by admin in a project scope, but there are also system events, which can\'t be deleted or modified.
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * event unique id
     * @type {number}
     * @memberof Event
     */
    'id': number;
    /**
     * create date
     * @type {string}
     * @memberof Event
     */
    'createdAt': string;
    /**
     * update (once updated)
     * @type {string}
     * @memberof Event
     */
    'updatedAt'?: string;
    /**
     * id of creator User
     * @type {number}
     * @memberof Event
     */
    'createdBy': number;
    /**
     * id of updater User
     * @type {number}
     * @memberof Event
     */
    'updatedBy'?: number;
    /**
     * project id
     * @type {number}
     * @memberof Event
     */
    'projectId': number;
    /**
     * the event is a system-wide, shown in any project and can\'t be modified by a regular user
     * @type {boolean}
     * @memberof Event
     */
    'isSystem': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Event
     */
    'tags'?: Array<string>;
    /**
     * event name. Must be unique among all project events (including custom). The name field is used while events ingesting.
     * @type {string}
     * @memberof Event
     */
    'name': string;
    /**
     * event name to display. If empty then name property is used.
     * @type {string}
     * @memberof Event
     */
    'displayName'?: string;
    /**
     * description
     * @type {string}
     * @memberof Event
     */
    'description'?: string;
    /**
     * event status
     * @type {string}
     * @memberof Event
     */
    'status': EventStatusEnum;
    /**
     * array of id of attached to event properties
     * @type {Array<number>}
     * @memberof Event
     */
    'eventProperties'?: Array<number>;
    /**
     * array of id of attached to user properties
     * @type {Array<number>}
     * @memberof Event
     */
    'userProperties'?: Array<number>;
}

export const EventStatusEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type EventStatusEnum = typeof EventStatusEnum[keyof typeof EventStatusEnum];

/**
 * chart type
 * @export
 * @enum {string}
 */

export const EventChartType = {
    Line: 'line',
    Bar: 'bar',
    SingleValue: 'singleValue'
} as const;

export type EventChartType = typeof EventChartType[keyof typeof EventChartType];


/**
 * 
 * @export
 * @interface EventFilterByCohort
 */
export interface EventFilterByCohort {
    /**
     * 
     * @type {string}
     * @memberof EventFilterByCohort
     */
    'type'?: EventFilterByCohortTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EventFilterByCohort
     */
    'cohortId'?: number;
}

export const EventFilterByCohortTypeEnum = {
    Cohort: 'cohort'
} as const;

export type EventFilterByCohortTypeEnum = typeof EventFilterByCohortTypeEnum[keyof typeof EventFilterByCohortTypeEnum];

/**
 * 
 * @export
 * @interface EventFilterByGroup
 */
export interface EventFilterByGroup {
    /**
     * 
     * @type {string}
     * @memberof EventFilterByGroup
     */
    'type'?: EventFilterByGroupTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EventFilterByGroup
     */
    'groupId'?: number;
}

export const EventFilterByGroupTypeEnum = {
    Group: 'group'
} as const;

export type EventFilterByGroupTypeEnum = typeof EventFilterByGroupTypeEnum[keyof typeof EventFilterByGroupTypeEnum];

/**
 * filter by property
 * @export
 * @interface EventFilterByProperty
 */
export interface EventFilterByProperty {
    /**
     * 
     * @type {string}
     * @memberof EventFilterByProperty
     */
    'type'?: EventFilterByPropertyTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof EventFilterByProperty
     */
    'propertyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventFilterByProperty
     */
    'propertyType': EventFilterByPropertyPropertyTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EventFilterByProperty
     */
    'propertyId'?: number;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof EventFilterByProperty
     */
    'operation': PropertyFilterOperation;
    /**
     * one or several property values. May be not set if operation is \"empty\" or \"exist\"
     * @type {Array<Value>}
     * @memberof EventFilterByProperty
     */
    'value'?: Array<Value>;
}

export const EventFilterByPropertyTypeEnum = {
    Property: 'property'
} as const;

export type EventFilterByPropertyTypeEnum = typeof EventFilterByPropertyTypeEnum[keyof typeof EventFilterByPropertyTypeEnum];
export const EventFilterByPropertyPropertyTypeEnum = {
    Custom: 'custom',
    Event: 'event',
    User: 'user'
} as const;

export type EventFilterByPropertyPropertyTypeEnum = typeof EventFilterByPropertyPropertyTypeEnum[keyof typeof EventFilterByPropertyPropertyTypeEnum];

/**
 * 
 * @export
 * @interface EventFilterByPropertyAllOf
 */
export interface EventFilterByPropertyAllOf {
    /**
     * 
     * @type {string}
     * @memberof EventFilterByPropertyAllOf
     */
    'type'?: EventFilterByPropertyAllOfTypeEnum;
}

export const EventFilterByPropertyAllOfTypeEnum = {
    Property: 'property'
} as const;

export type EventFilterByPropertyAllOfTypeEnum = typeof EventFilterByPropertyAllOfTypeEnum[keyof typeof EventFilterByPropertyAllOfTypeEnum];

/**
 * 
 * @export
 * @interface EventFilterByPropertyAllOf1
 */
export interface EventFilterByPropertyAllOf1 {
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof EventFilterByPropertyAllOf1
     */
    'operation'?: PropertyFilterOperation;
    /**
     * one or several property values. May be not set if operation is \"empty\" or \"exist\"
     * @type {Array<Value>}
     * @memberof EventFilterByPropertyAllOf1
     */
    'value'?: Array<Value>;
}
/**
 * event filters
 * @export
 * @interface EventFilters
 */
export interface EventFilters {
    /**
     * 
     * @type {string}
     * @memberof EventFilters
     */
    'groupsCondition'?: EventFiltersGroupsConditionEnum;
    /**
     * 
     * @type {EventFiltersGroups}
     * @memberof EventFilters
     */
    'groups'?: EventFiltersGroups;
}

export const EventFiltersGroupsConditionEnum = {
    And: 'and',
    Or: 'or'
} as const;

export type EventFiltersGroupsConditionEnum = typeof EventFiltersGroupsConditionEnum[keyof typeof EventFiltersGroupsConditionEnum];

/**
 * 
 * @export
 * @interface EventFiltersGroups
 */
export interface EventFiltersGroups {
    /**
     * 
     * @type {string}
     * @memberof EventFiltersGroups
     */
    'filtersCondition'?: EventFiltersGroupsFiltersConditionEnum;
    /**
     * 
     * @type {Array<EventFiltersGroupsFiltersInner>}
     * @memberof EventFiltersGroups
     */
    'filters'?: Array<EventFiltersGroupsFiltersInner>;
}

export const EventFiltersGroupsFiltersConditionEnum = {
    And: 'and',
    Or: 'or'
} as const;

export type EventFiltersGroupsFiltersConditionEnum = typeof EventFiltersGroupsFiltersConditionEnum[keyof typeof EventFiltersGroupsFiltersConditionEnum];

/**
 * 
 * @export
 * @interface EventFiltersGroupsFiltersInner
 */
export interface EventFiltersGroupsFiltersInner {
    /**
     * 
     * @type {string}
     * @memberof EventFiltersGroupsFiltersInner
     */
    'type'?: EventFiltersGroupsFiltersInnerTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EventFiltersGroupsFiltersInner
     */
    'cohortId'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventFiltersGroupsFiltersInner
     */
    'propertyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventFiltersGroupsFiltersInner
     */
    'propertyType': EventFiltersGroupsFiltersInnerPropertyTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EventFiltersGroupsFiltersInner
     */
    'propertyId'?: number;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof EventFiltersGroupsFiltersInner
     */
    'operation': PropertyFilterOperation;
    /**
     * one or several property values. May be not set if operation is \"empty\" or \"exist\"
     * @type {Array<Value>}
     * @memberof EventFiltersGroupsFiltersInner
     */
    'value'?: Array<Value>;
    /**
     * 
     * @type {number}
     * @memberof EventFiltersGroupsFiltersInner
     */
    'groupId'?: number;
}

export const EventFiltersGroupsFiltersInnerTypeEnum = {
    Group: 'group'
} as const;

export type EventFiltersGroupsFiltersInnerTypeEnum = typeof EventFiltersGroupsFiltersInnerTypeEnum[keyof typeof EventFiltersGroupsFiltersInnerTypeEnum];
export const EventFiltersGroupsFiltersInnerPropertyTypeEnum = {
    Custom: 'custom',
    Event: 'event',
    User: 'user'
} as const;

export type EventFiltersGroupsFiltersInnerPropertyTypeEnum = typeof EventFiltersGroupsFiltersInnerPropertyTypeEnum[keyof typeof EventFiltersGroupsFiltersInnerPropertyTypeEnum];

/**
 * event query
 * @export
 * @interface EventQuery
 */
export interface EventQuery {
    /**
     * 
     * @type {string}
     * @memberof EventQuery
     */
    'name'?: string;
    /**
     * 
     * @type {EventQueryQuery}
     * @memberof EventQuery
     */
    'query': EventQueryQuery;
}
/**
 * @type EventQueryQuery
 * @export
 */
export type EventQueryQuery = QueryAggregateProperty | QueryAggregatePropertyPerGroup | QueryCountPerGroup | QueryFormula | QuerySimple;

/**
 * 
 * @export
 * @interface EventRecord
 */
export interface EventRecord {
    /**
     * 
     * @type {number}
     * @memberof EventRecord
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventRecord
     */
    'name'?: string;
    /**
     * map of property name and property value pairs
     * @type {object}
     * @memberof EventRecord
     */
    'properties'?: object;
    /**
     * map of user name and property value pairs
     * @type {object}
     * @memberof EventRecord
     */
    'userProperties'?: object;
    /**
     * 
     * @type {Array<EventRecordMatchedCustomEventsInner>}
     * @memberof EventRecord
     */
    'matchedCustomEvents'?: Array<EventRecordMatchedCustomEventsInner>;
}
/**
 * 
 * @export
 * @interface EventRecordMatchedCustomEventsInner
 */
export interface EventRecordMatchedCustomEventsInner {
    /**
     * 
     * @type {number}
     * @memberof EventRecordMatchedCustomEventsInner
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface EventRecordsList200Response
 */
export interface EventRecordsList200Response {
    /**
     * 
     * @type {Array<EventRecord>}
     * @memberof EventRecordsList200Response
     */
    'events'?: Array<EventRecord>;
    /**
     * 
     * @type {ListResponseMetadataMeta}
     * @memberof EventRecordsList200Response
     */
    'meta'?: ListResponseMetadataMeta;
}
/**
 * 
 * @export
 * @interface EventRecordsList200ResponseAllOf
 */
export interface EventRecordsList200ResponseAllOf {
    /**
     * 
     * @type {Array<EventRecord>}
     * @memberof EventRecordsList200ResponseAllOf
     */
    'events'?: Array<EventRecord>;
}
/**
 * request event records sorted by time of creation
 * @export
 * @interface EventRecordsListRequest
 */
export interface EventRecordsListRequest {
    /**
     * 
     * @type {EventRecordsListRequestTime}
     * @memberof EventRecordsListRequest
     */
    'time': EventRecordsListRequestTime;
    /**
     * group that is used in aggregations by group. For instance, group by user or group by organization.
     * @type {string}
     * @memberof EventRecordsListRequest
     */
    'group'?: string;
    /**
     * 
     * @type {EventRecordsListRequestSearch}
     * @memberof EventRecordsListRequest
     */
    'search'?: EventRecordsListRequestSearch;
    /**
     * array of events to query
     * @type {Array<EventRecordsListRequestEventsInner>}
     * @memberof EventRecordsListRequest
     */
    'events'?: Array<EventRecordsListRequestEventsInner>;
    /**
     * 
     * @type {EventFilters}
     * @memberof EventRecordsListRequest
     */
    'filters'?: EventFilters;
}
/**
 * 
 * @export
 * @interface EventRecordsListRequestEventsInner
 */
export interface EventRecordsListRequestEventsInner {
    /**
     * 
     * @type {string}
     * @memberof EventRecordsListRequestEventsInner
     */
    'eventName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventRecordsListRequestEventsInner
     */
    'eventType': EventRecordsListRequestEventsInnerEventTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EventRecordsListRequestEventsInner
     */
    'eventId'?: number;
    /**
     * array of event filters
     * @type {Array<EventRecordsListRequestEventsInnerAllOfFiltersInner>}
     * @memberof EventRecordsListRequestEventsInner
     */
    'filters'?: Array<EventRecordsListRequestEventsInnerAllOfFiltersInner>;
}

export const EventRecordsListRequestEventsInnerEventTypeEnum = {
    Custom: 'custom'
} as const;

export type EventRecordsListRequestEventsInnerEventTypeEnum = typeof EventRecordsListRequestEventsInnerEventTypeEnum[keyof typeof EventRecordsListRequestEventsInnerEventTypeEnum];

/**
 * 
 * @export
 * @interface EventRecordsListRequestEventsInnerAllOf
 */
export interface EventRecordsListRequestEventsInnerAllOf {
    /**
     * array of event filters
     * @type {Array<EventRecordsListRequestEventsInnerAllOfFiltersInner>}
     * @memberof EventRecordsListRequestEventsInnerAllOf
     */
    'filters'?: Array<EventRecordsListRequestEventsInnerAllOfFiltersInner>;
}
/**
 * @type EventRecordsListRequestEventsInnerAllOfFiltersInner
 * @export
 */
export type EventRecordsListRequestEventsInnerAllOfFiltersInner = EventFilterByGroup | EventFilterByProperty;

/**
 * search in results
 * @export
 * @interface EventRecordsListRequestSearch
 */
export interface EventRecordsListRequestSearch {
    /**
     * 
     * @type {string}
     * @memberof EventRecordsListRequestSearch
     */
    'term'?: string;
    /**
     * 
     * @type {Array<EventRecordsListRequestSearchInEventPropertiesInner>}
     * @memberof EventRecordsListRequestSearch
     */
    'inEventProperties'?: Array<EventRecordsListRequestSearchInEventPropertiesInner>;
    /**
     * 
     * @type {Array<EventRecordsListRequestSearchInEventPropertiesInner>}
     * @memberof EventRecordsListRequestSearch
     */
    'inUserProperties'?: Array<EventRecordsListRequestSearchInEventPropertiesInner>;
}
/**
 * @type EventRecordsListRequestSearchInEventPropertiesInner
 * @export
 */
export type EventRecordsListRequestSearchInEventPropertiesInner = number | string;

/**
 * @type EventRecordsListRequestTime
 * select time
 * @export
 */
export type EventRecordsListRequestTime = TimeBetween | TimeFrom | TimeLast;

/**
 * @type EventRef
 * reference to event by its name and type
 * @export
 */
export type EventRef = EventRefOneOf | EventRefOneOf1;

/**
 * 
 * @export
 * @interface EventRefOneOf
 */
export interface EventRefOneOf {
    /**
     * 
     * @type {string}
     * @memberof EventRefOneOf
     */
    'eventName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventRefOneOf
     */
    'eventType'?: EventRefOneOfEventTypeEnum;
}

export const EventRefOneOfEventTypeEnum = {
    Regular: 'regular'
} as const;

export type EventRefOneOfEventTypeEnum = typeof EventRefOneOfEventTypeEnum[keyof typeof EventRefOneOfEventTypeEnum];

/**
 * 
 * @export
 * @interface EventRefOneOf1
 */
export interface EventRefOneOf1 {
    /**
     * 
     * @type {number}
     * @memberof EventRefOneOf1
     */
    'eventId'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventRefOneOf1
     */
    'eventType'?: EventRefOneOf1EventTypeEnum;
}

export const EventRefOneOf1EventTypeEnum = {
    Custom: 'custom'
} as const;

export type EventRefOneOf1EventTypeEnum = typeof EventRefOneOf1EventTypeEnum[keyof typeof EventRefOneOf1EventTypeEnum];

/**
 * event segmentation report type main payload
 * @export
 * @interface EventSegmentation
 */
export interface EventSegmentation {
    /**
     * 
     * @type {EventRecordsListRequestTime}
     * @memberof EventSegmentation
     */
    'time': EventRecordsListRequestTime;
    /**
     * group that is used in aggregations by group. For instance, group by user or group by organizartion.
     * @type {string}
     * @memberof EventSegmentation
     */
    'group': string;
    /**
     * 
     * @type {TimeUnit}
     * @memberof EventSegmentation
     */
    'intervalUnit': TimeUnit;
    /**
     * 
     * @type {EventChartType}
     * @memberof EventSegmentation
     */
    'chartType': EventChartType;
    /**
     * 
     * @type {EventSegmentationAnalysis}
     * @memberof EventSegmentation
     */
    'analysis': EventSegmentationAnalysis;
    /**
     * 
     * @type {EventSegmentationCompare}
     * @memberof EventSegmentation
     */
    'compare'?: EventSegmentationCompare;
    /**
     * array of events to query
     * @type {Array<EventSegmentationEvent>}
     * @memberof EventSegmentation
     */
    'events': Array<EventSegmentationEvent>;
    /**
     * 
     * @type {EventFilters}
     * @memberof EventSegmentation
     */
    'filters'?: EventFilters;
    /**
     * array of common breakdowns (which applies to all events)
     * @type {Array<BreakdownByProperty>}
     * @memberof EventSegmentation
     */
    'breakdowns'?: Array<BreakdownByProperty>;
    /**
     * array of segments
     * @type {Array<EventSegmentationSegment>}
     * @memberof EventSegmentation
     */
    'segments'?: Array<EventSegmentationSegment>;
}
/**
 * @type EventSegmentationAnalysis
 * analysis type
 * @export
 */
export type EventSegmentationAnalysis = AnalysisCumulative | AnalysisLinear | AnalysisRollingAverage | AnalysisRollingWindow;

/**
 * optional comparison with previous period
 * @export
 * @interface EventSegmentationCompare
 */
export interface EventSegmentationCompare {
    /**
     * offset in past in timeUnit
     * @type {number}
     * @memberof EventSegmentationCompare
     */
    'offset': number;
    /**
     * 
     * @type {TimeUnit}
     * @memberof EventSegmentationCompare
     */
    'unit': TimeUnit;
}
/**
 * event object
 * @export
 * @interface EventSegmentationEvent
 */
export interface EventSegmentationEvent {
    /**
     * 
     * @type {string}
     * @memberof EventSegmentationEvent
     */
    'eventName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSegmentationEvent
     */
    'eventType': EventSegmentationEventEventTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EventSegmentationEvent
     */
    'eventId'?: number;
    /**
     * array of event filters
     * @type {Array<EventFilterByProperty>}
     * @memberof EventSegmentationEvent
     */
    'filters'?: Array<EventFilterByProperty>;
    /**
     * 
     * @type {Array<BreakdownByProperty>}
     * @memberof EventSegmentationEvent
     */
    'breakdowns'?: Array<BreakdownByProperty>;
    /**
     * array of event queries
     * @type {Array<EventQuery>}
     * @memberof EventSegmentationEvent
     */
    'queries': Array<EventQuery>;
}

export const EventSegmentationEventEventTypeEnum = {
    Custom: 'custom'
} as const;

export type EventSegmentationEventEventTypeEnum = typeof EventSegmentationEventEventTypeEnum[keyof typeof EventSegmentationEventEventTypeEnum];

/**
 * 
 * @export
 * @interface EventSegmentationEventAllOf
 */
export interface EventSegmentationEventAllOf {
    /**
     * array of event filters
     * @type {Array<EventFilterByProperty>}
     * @memberof EventSegmentationEventAllOf
     */
    'filters'?: Array<EventFilterByProperty>;
    /**
     * 
     * @type {Array<BreakdownByProperty>}
     * @memberof EventSegmentationEventAllOf
     */
    'breakdowns'?: Array<BreakdownByProperty>;
    /**
     * array of event queries
     * @type {Array<EventQuery>}
     * @memberof EventSegmentationEventAllOf
     */
    'queries'?: Array<EventQuery>;
}
/**
 * segment
 * @export
 * @interface EventSegmentationSegment
 */
export interface EventSegmentationSegment {
    /**
     * name of segment
     * @type {string}
     * @memberof EventSegmentationSegment
     */
    'name'?: string;
    /**
     * array of conditions
     * @type {Array<SegmentCondition>}
     * @memberof EventSegmentationSegment
     */
    'conditions': Array<SegmentCondition>;
}
/**
 * possible event type
 * @export
 * @enum {string}
 */

export const EventType = {
    Regular: 'regular',
    Custom: 'custom'
} as const;

export type EventType = typeof EventType[keyof typeof EventType];


/**
 * 
 * @export
 * @interface EventsList200Response
 */
export interface EventsList200Response {
    /**
     * 
     * @type {Array<Event>}
     * @memberof EventsList200Response
     */
    'events'?: Array<Event>;
    /**
     * 
     * @type {ListResponseMetadataMeta}
     * @memberof EventsList200Response
     */
    'meta'?: ListResponseMetadataMeta;
}
/**
 * 
 * @export
 * @interface EventsList200ResponseAllOf
 */
export interface EventsList200ResponseAllOf {
    /**
     * 
     * @type {Array<Event>}
     * @memberof EventsList200ResponseAllOf
     */
    'events'?: Array<Event>;
}
/**
 * 
 * @export
 * @interface FunnelConversionOverTimeChartType
 */
export interface FunnelConversionOverTimeChartType {
    /**
     * 
     * @type {string}
     * @memberof FunnelConversionOverTimeChartType
     */
    'type'?: FunnelConversionOverTimeChartTypeTypeEnum;
    /**
     * 
     * @type {TimeUnit}
     * @memberof FunnelConversionOverTimeChartType
     */
    'intervalUnit'?: TimeUnit;
}

export const FunnelConversionOverTimeChartTypeTypeEnum = {
    ConversionOverTime: 'conversionOverTime'
} as const;

export type FunnelConversionOverTimeChartTypeTypeEnum = typeof FunnelConversionOverTimeChartTypeTypeEnum[keyof typeof FunnelConversionOverTimeChartTypeTypeEnum];

/**
 * 
 * @export
 * @interface FunnelConversionStepsChartType
 */
export interface FunnelConversionStepsChartType {
    /**
     * 
     * @type {string}
     * @memberof FunnelConversionStepsChartType
     */
    'type'?: FunnelConversionStepsChartTypeTypeEnum;
}

export const FunnelConversionStepsChartTypeTypeEnum = {
    ConversionSteps: 'conversionSteps'
} as const;

export type FunnelConversionStepsChartTypeTypeEnum = typeof FunnelConversionStepsChartTypeTypeEnum[keyof typeof FunnelConversionStepsChartTypeTypeEnum];

/**
 * 
 * @export
 * @interface FunnelConversionStepsChartTypeResponse
 */
export interface FunnelConversionStepsChartTypeResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof FunnelConversionStepsChartTypeResponse
     */
    'dimensionHeaders'?: Array<string>;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof FunnelConversionStepsChartTypeResponse
     */
    'dimensions'?: Array<Array<string>>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FunnelConversionStepsChartTypeResponse
     */
    'metrics'?: Array<FunnelConversionStepsChartTypeResponseMetricsEnum>;
    /**
     * 
     * @type {Array<number>}
     * @memberof FunnelConversionStepsChartTypeResponse
     */
    'singles'?: Array<number>;
    /**
     * 
     * @type {Array<Array<number>>}
     * @memberof FunnelConversionStepsChartTypeResponse
     */
    'series'?: Array<Array<number>>;
}

export const FunnelConversionStepsChartTypeResponseMetricsEnum = {
    AvgTimeToConvert: 'avgTimeToConvert'
} as const;

export type FunnelConversionStepsChartTypeResponseMetricsEnum = typeof FunnelConversionStepsChartTypeResponseMetricsEnum[keyof typeof FunnelConversionStepsChartTypeResponseMetricsEnum];

/**
 * event object
 * @export
 * @interface FunnelEvent
 */
export interface FunnelEvent {
    /**
     * 
     * @type {string}
     * @memberof FunnelEvent
     */
    'eventName'?: string;
    /**
     * 
     * @type {string}
     * @memberof FunnelEvent
     */
    'eventType': FunnelEventEventTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof FunnelEvent
     */
    'eventId'?: number;
    /**
     * array of event filters
     * @type {Array<EventFilterByProperty>}
     * @memberof FunnelEvent
     */
    'filters'?: Array<EventFilterByProperty>;
}

export const FunnelEventEventTypeEnum = {
    Custom: 'custom'
} as const;

export type FunnelEventEventTypeEnum = typeof FunnelEventEventTypeEnum[keyof typeof FunnelEventEventTypeEnum];

/**
 * 
 * @export
 * @interface FunnelEventAllOf
 */
export interface FunnelEventAllOf {
    /**
     * array of event filters
     * @type {Array<EventFilterByProperty>}
     * @memberof FunnelEventAllOf
     */
    'filters'?: Array<EventFilterByProperty>;
}
/**
 * 
 * @export
 * @interface FunnelExcludeSteps
 */
export interface FunnelExcludeSteps {
    /**
     * 
     * @type {FunnelExcludeStepsSteps}
     * @memberof FunnelExcludeSteps
     */
    'steps'?: FunnelExcludeStepsSteps;
}
/**
 * @type FunnelExcludeStepsSteps
 * @export
 */
export type FunnelExcludeStepsSteps = FunnelExcludeStepsStepsOneOf | FunnelExcludeStepsStepsOneOf1;

/**
 * 
 * @export
 * @interface FunnelExcludeStepsStepsOneOf
 */
export interface FunnelExcludeStepsStepsOneOf {
    /**
     * 
     * @type {string}
     * @memberof FunnelExcludeStepsStepsOneOf
     */
    'type'?: FunnelExcludeStepsStepsOneOfTypeEnum;
}

export const FunnelExcludeStepsStepsOneOfTypeEnum = {
    All: 'all'
} as const;

export type FunnelExcludeStepsStepsOneOfTypeEnum = typeof FunnelExcludeStepsStepsOneOfTypeEnum[keyof typeof FunnelExcludeStepsStepsOneOfTypeEnum];

/**
 * 
 * @export
 * @interface FunnelExcludeStepsStepsOneOf1
 */
export interface FunnelExcludeStepsStepsOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof FunnelExcludeStepsStepsOneOf1
     */
    'type'?: FunnelExcludeStepsStepsOneOf1TypeEnum;
    /**
     * 
     * @type {number}
     * @memberof FunnelExcludeStepsStepsOneOf1
     */
    'from'?: number;
    /**
     * 
     * @type {number}
     * @memberof FunnelExcludeStepsStepsOneOf1
     */
    'to'?: number;
}

export const FunnelExcludeStepsStepsOneOf1TypeEnum = {
    Between: 'between'
} as const;

export type FunnelExcludeStepsStepsOneOf1TypeEnum = typeof FunnelExcludeStepsStepsOneOf1TypeEnum[keyof typeof FunnelExcludeStepsStepsOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface FunnelFrequencyChartType
 */
export interface FunnelFrequencyChartType {
    /**
     * 
     * @type {string}
     * @memberof FunnelFrequencyChartType
     */
    'type'?: FunnelFrequencyChartTypeTypeEnum;
}

export const FunnelFrequencyChartTypeTypeEnum = {
    Frequency: 'frequency'
} as const;

export type FunnelFrequencyChartTypeTypeEnum = typeof FunnelFrequencyChartTypeTypeEnum[keyof typeof FunnelFrequencyChartTypeTypeEnum];

/**
 * 
 * @export
 * @interface FunnelQuery
 */
export interface FunnelQuery {
    /**
     * 
     * @type {EventRecordsListRequestTime}
     * @memberof FunnelQuery
     */
    'time'?: EventRecordsListRequestTime;
    /**
     * group that is used in aggregations by group. For instance, group by user or group by organizartion.
     * @type {string}
     * @memberof FunnelQuery
     */
    'group'?: string;
    /**
     * 
     * @type {Array<FunnelQueryStepsInner>}
     * @memberof FunnelQuery
     */
    'steps'?: Array<FunnelQueryStepsInner>;
    /**
     * 
     * @type {FunnelQueryTimeWindow}
     * @memberof FunnelQuery
     */
    'timeWindow'?: FunnelQueryTimeWindow;
    /**
     * 
     * @type {FunnelQueryChartType}
     * @memberof FunnelQuery
     */
    'chartType'?: FunnelQueryChartType;
    /**
     * 
     * @type {string}
     * @memberof FunnelQuery
     */
    'count'?: FunnelQueryCountEnum;
    /**
     * 
     * @type {string}
     * @memberof FunnelQuery
     */
    'stepOrder'?: FunnelQueryStepOrderEnum;
    /**
     * 
     * @type {FunnelQueryAttribution}
     * @memberof FunnelQuery
     */
    'attribution'?: FunnelQueryAttribution;
    /**
     * 
     * @type {Array<PropertyRef>}
     * @memberof FunnelQuery
     */
    'holdingConstants'?: Array<PropertyRef>;
    /**
     * 
     * @type {Array<FunnelQueryExcludeInner>}
     * @memberof FunnelQuery
     */
    'exclude'?: Array<FunnelQueryExcludeInner>;
    /**
     * array of breakdowns
     * @type {Array<BreakdownByProperty>}
     * @memberof FunnelQuery
     */
    'breakdowns'?: Array<BreakdownByProperty>;
}

export const FunnelQueryCountEnum = {
    Uniques: 'uniques',
    Totals: 'totals'
} as const;

export type FunnelQueryCountEnum = typeof FunnelQueryCountEnum[keyof typeof FunnelQueryCountEnum];
export const FunnelQueryStepOrderEnum = {
    Any: 'any',
    ExactSequence: 'exactSequence',
    ExactOrder: 'exactOrder'
} as const;

export type FunnelQueryStepOrderEnum = typeof FunnelQueryStepOrderEnum[keyof typeof FunnelQueryStepOrderEnum];

/**
 * @type FunnelQueryAttribution
 * @export
 */
export type FunnelQueryAttribution = FunnelQueryAttributionOneOf | FunnelQueryAttributionOneOf1;

/**
 * 
 * @export
 * @interface FunnelQueryAttributionOneOf
 */
export interface FunnelQueryAttributionOneOf {
    /**
     * 
     * @type {string}
     * @memberof FunnelQueryAttributionOneOf
     */
    'type'?: FunnelQueryAttributionOneOfTypeEnum;
}

export const FunnelQueryAttributionOneOfTypeEnum = {
    FirstTouch: 'firstTouch',
    LastTouch: 'lastTouch'
} as const;

export type FunnelQueryAttributionOneOfTypeEnum = typeof FunnelQueryAttributionOneOfTypeEnum[keyof typeof FunnelQueryAttributionOneOfTypeEnum];

/**
 * 
 * @export
 * @interface FunnelQueryAttributionOneOf1
 */
export interface FunnelQueryAttributionOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof FunnelQueryAttributionOneOf1
     */
    'type'?: FunnelQueryAttributionOneOf1TypeEnum;
    /**
     * 
     * @type {number}
     * @memberof FunnelQueryAttributionOneOf1
     */
    'step'?: number;
}

export const FunnelQueryAttributionOneOf1TypeEnum = {
    Step: 'step'
} as const;

export type FunnelQueryAttributionOneOf1TypeEnum = typeof FunnelQueryAttributionOneOf1TypeEnum[keyof typeof FunnelQueryAttributionOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface FunnelQueryChartType
 */
export interface FunnelQueryChartType {
    /**
     * 
     * @type {string}
     * @memberof FunnelQueryChartType
     */
    'type'?: FunnelQueryChartTypeTypeEnum;
    /**
     * 
     * @type {TimeUnit}
     * @memberof FunnelQueryChartType
     */
    'intervalUnit'?: TimeUnit;
    /**
     * 
     * @type {number}
     * @memberof FunnelQueryChartType
     */
    'minInterval'?: number;
    /**
     * 
     * @type {number}
     * @memberof FunnelQueryChartType
     */
    'maxInterval'?: number;
}

export const FunnelQueryChartTypeTypeEnum = {
    Frequency: 'frequency'
} as const;

export type FunnelQueryChartTypeTypeEnum = typeof FunnelQueryChartTypeTypeEnum[keyof typeof FunnelQueryChartTypeTypeEnum];

/**
 * 
 * @export
 * @interface FunnelQueryExcludeInner
 */
export interface FunnelQueryExcludeInner {
    /**
     * 
     * @type {string}
     * @memberof FunnelQueryExcludeInner
     */
    'eventName'?: string;
    /**
     * 
     * @type {string}
     * @memberof FunnelQueryExcludeInner
     */
    'eventType': FunnelQueryExcludeInnerEventTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof FunnelQueryExcludeInner
     */
    'eventId'?: number;
    /**
     * array of event filters
     * @type {Array<EventFilterByProperty>}
     * @memberof FunnelQueryExcludeInner
     */
    'filters'?: Array<EventFilterByProperty>;
    /**
     * 
     * @type {FunnelExcludeStepsSteps}
     * @memberof FunnelQueryExcludeInner
     */
    'steps'?: FunnelExcludeStepsSteps;
}

export const FunnelQueryExcludeInnerEventTypeEnum = {
    Custom: 'custom'
} as const;

export type FunnelQueryExcludeInnerEventTypeEnum = typeof FunnelQueryExcludeInnerEventTypeEnum[keyof typeof FunnelQueryExcludeInnerEventTypeEnum];

/**
 * 
 * @export
 * @interface FunnelQueryStepsInner
 */
export interface FunnelQueryStepsInner {
    /**
     * 
     * @type {Array<FunnelEvent>}
     * @memberof FunnelQueryStepsInner
     */
    'events'?: Array<FunnelEvent>;
    /**
     * 
     * @type {string}
     * @memberof FunnelQueryStepsInner
     */
    'order'?: FunnelQueryStepsInnerOrderEnum;
}

export const FunnelQueryStepsInnerOrderEnum = {
    Any: 'any',
    Exact: 'exact'
} as const;

export type FunnelQueryStepsInnerOrderEnum = typeof FunnelQueryStepsInnerOrderEnum[keyof typeof FunnelQueryStepsInnerOrderEnum];

/**
 * 
 * @export
 * @interface FunnelQueryTimeWindow
 */
export interface FunnelQueryTimeWindow {
    /**
     * N days/weeks
     * @type {number}
     * @memberof FunnelQueryTimeWindow
     */
    'n'?: number;
    /**
     * 
     * @type {TimeUnitWithSession}
     * @memberof FunnelQueryTimeWindow
     */
    'unit'?: TimeUnitWithSession;
    /**
     * 
     * @type {string}
     * @memberof FunnelQueryTimeWindow
     */
    'from'?: FunnelQueryTimeWindowFromEnum;
}

export const FunnelQueryTimeWindowFromEnum = {
    AnyDay: 'anyDay',
    FirstDay: 'firstDay'
} as const;

export type FunnelQueryTimeWindowFromEnum = typeof FunnelQueryTimeWindowFromEnum[keyof typeof FunnelQueryTimeWindowFromEnum];

/**
 * 
 * @export
 * @interface FunnelTimeToConvertChartType
 */
export interface FunnelTimeToConvertChartType {
    /**
     * 
     * @type {string}
     * @memberof FunnelTimeToConvertChartType
     */
    'type'?: FunnelTimeToConvertChartTypeTypeEnum;
    /**
     * 
     * @type {TimeUnit}
     * @memberof FunnelTimeToConvertChartType
     */
    'intervalUnit'?: TimeUnit;
    /**
     * 
     * @type {number}
     * @memberof FunnelTimeToConvertChartType
     */
    'minInterval'?: number;
    /**
     * 
     * @type {number}
     * @memberof FunnelTimeToConvertChartType
     */
    'maxInterval'?: number;
}

export const FunnelTimeToConvertChartTypeTypeEnum = {
    TimeToConvert: 'timeToConvert'
} as const;

export type FunnelTimeToConvertChartTypeTypeEnum = typeof FunnelTimeToConvertChartTypeTypeEnum[keyof typeof FunnelTimeToConvertChartTypeTypeEnum];

/**
 * 
 * @export
 * @interface GroupEventsList200Response
 */
export interface GroupEventsList200Response {
    /**
     * 
     * @type {Array<GroupRecord>}
     * @memberof GroupEventsList200Response
     */
    'events'?: Array<GroupRecord>;
    /**
     * 
     * @type {ListResponseMetadataMeta}
     * @memberof GroupEventsList200Response
     */
    'meta'?: ListResponseMetadataMeta;
}
/**
 * 
 * @export
 * @interface GroupEventsList200ResponseAllOf
 */
export interface GroupEventsList200ResponseAllOf {
    /**
     * 
     * @type {Array<GroupRecord>}
     * @memberof GroupEventsList200ResponseAllOf
     */
    'events'?: Array<GroupRecord>;
}
/**
 * 
 * @export
 * @interface GroupRecord
 */
export interface GroupRecord {
    /**
     * 
     * @type {number}
     * @memberof GroupRecord
     */
    'id'?: number;
    /**
     * map of group property name and property value pairs
     * @type {object}
     * @memberof GroupRecord
     */
    'properties'?: object;
}
/**
 * request group records sorted by time of creation
 * @export
 * @interface GroupRecordsListRequest
 */
export interface GroupRecordsListRequest {
    /**
     * 
     * @type {EventRecordsListRequestTime}
     * @memberof GroupRecordsListRequest
     */
    'time': EventRecordsListRequestTime;
    /**
     * group that is used in aggregations by group. For instance, group by user or group by organization.
     * @type {string}
     * @memberof GroupRecordsListRequest
     */
    'group'?: string;
    /**
     * 
     * @type {GroupRecordsListRequestSearch}
     * @memberof GroupRecordsListRequest
     */
    'search'?: GroupRecordsListRequestSearch;
    /**
     * array of segments
     * @type {Array<EventSegmentationSegment>}
     * @memberof GroupRecordsListRequest
     */
    'segments'?: Array<EventSegmentationSegment>;
    /**
     * 
     * @type {EventFilters}
     * @memberof GroupRecordsListRequest
     */
    'filters'?: EventFilters;
}
/**
 * search in results
 * @export
 * @interface GroupRecordsListRequestSearch
 */
export interface GroupRecordsListRequestSearch {
    /**
     * 
     * @type {string}
     * @memberof GroupRecordsListRequestSearch
     */
    'term'?: string;
    /**
     * 
     * @type {Array<EventRecordsListRequestSearchInEventPropertiesInner>}
     * @memberof GroupRecordsListRequestSearch
     */
    'inUserProperties'?: Array<EventRecordsListRequestSearchInEventPropertiesInner>;
}
/**
 * see  https://datatracker.ietf.org/doc/html/rfc7519
 * @export
 * @interface JWTToken
 */
export interface JWTToken {
    /**
     * 
     * @type {number}
     * @memberof JWTToken
     */
    'accountId': number;
    /**
     * 
     * @type {number}
     * @memberof JWTToken
     */
    'organizationId': number;
    /**
     * 
     * @type {number}
     * @memberof JWTToken
     */
    'projectId'?: number;
    /**
     * 
     * @type {string}
     * @memberof JWTToken
     */
    'iss': JWTTokenIssEnum;
    /**
     * 
     * @type {number}
     * @memberof JWTToken
     */
    'exp': number;
    /**
     * 
     * @type {number}
     * @memberof JWTToken
     */
    'nbf': number;
    /**
     * 
     * @type {number}
     * @memberof JWTToken
     */
    'iat': number;
    /**
     * 
     * @type {number}
     * @memberof JWTToken
     */
    'jti': number;
}

export const JWTTokenIssEnum = {
    Optiprism: 'optiprism'
} as const;

export type JWTTokenIssEnum = typeof JWTTokenIssEnum[keyof typeof JWTTokenIssEnum];

/**
 * list response metadata
 * @export
 * @interface ListResponseMetadata
 */
export interface ListResponseMetadata {
    /**
     * 
     * @type {ListResponseMetadataMeta}
     * @memberof ListResponseMetadata
     */
    'meta'?: ListResponseMetadataMeta;
}
/**
 * 
 * @export
 * @interface ListResponseMetadataMeta
 */
export interface ListResponseMetadataMeta {
    /**
     * 
     * @type {string}
     * @memberof ListResponseMetadataMeta
     */
    'next'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListResponseMetadataMeta
     */
    'prev'?: string;
    /**
     * 
     * @type {number}
     * @memberof ListResponseMetadataMeta
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {Array<number>}
     * @memberof Organization
     */
    'teams'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Organization
     */
    'users'?: Array<number>;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'createdBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'updatedBy'?: number;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'sessionTimeoutSeconds'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Project
     */
    'teams'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Project
     */
    'users'?: Array<number>;
}
/**
 * property defines event or user property. For example, event \"Buy product\" may contains next properties like \"Product name\" and \"Price.\"
 * @export
 * @interface Property
 */
export interface Property {
    /**
     * property unique id
     * @type {number}
     * @memberof Property
     */
    'id': number;
    /**
     * create date
     * @type {string}
     * @memberof Property
     */
    'createdAt': string;
    /**
     * update (once updated)
     * @type {string}
     * @memberof Property
     */
    'updatedAt'?: string;
    /**
     * id of creator User
     * @type {number}
     * @memberof Property
     */
    'createdBy': number;
    /**
     * id of updater User
     * @type {number}
     * @memberof Property
     */
    'updatedBy'?: number;
    /**
     * project id
     * @type {number}
     * @memberof Property
     */
    'projectId': number;
    /**
     * list of id of events which use this property
     * @type {Array<number>}
     * @memberof Property
     */
    'events'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    'type'?: PropertyTypeEnum;
    /**
     * the property is a system-wide, shown in any project and can\'t be modified by a regular user
     * @type {boolean}
     * @memberof Property
     */
    'isSystem': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Property
     */
    'tags'?: Array<string>;
    /**
     * property name. Must be unique
     * @type {string}
     * @memberof Property
     */
    'name': string;
    /**
     * property name to display. If empty then name is used.
     * @type {string}
     * @memberof Property
     */
    'displayName'?: string;
    /**
     * description
     * @type {string}
     * @memberof Property
     */
    'description'?: string;
    /**
     * property status
     * @type {string}
     * @memberof Property
     */
    'status': PropertyStatusEnum;
    /**
     * 
     * @type {object & DataType}
     * @memberof Property
     */
    'dataType'?: object & DataType;
    /**
     * nullable property might contains null value
     * @type {boolean}
     * @memberof Property
     */
    'nullable': boolean;
    /**
     * array property might contents multiple values
     * @type {boolean}
     * @memberof Property
     */
    'isArray': boolean;
    /**
     * dictionary can efficiently packs strings provided that cardinality will be relatively log (16bits is a reasonable maximum)
     * @type {boolean}
     * @memberof Property
     */
    'isDictionary': boolean;
    /**
     * 
     * @type {object & DataType}
     * @memberof Property
     */
    'dictionaryType'?: object & DataType;
}

export const PropertyTypeEnum = {
    Event: 'event',
    User: 'user'
} as const;

export type PropertyTypeEnum = typeof PropertyTypeEnum[keyof typeof PropertyTypeEnum];
export const PropertyStatusEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type PropertyStatusEnum = typeof PropertyStatusEnum[keyof typeof PropertyStatusEnum];

/**
 * operation
 * @export
 * @enum {string}
 */

export const PropertyFilterOperation = {
    Eq: 'eq',
    Neq: 'neq',
    Gt: 'gt',
    Gte: 'gte',
    Lt: 'lt',
    Lte: 'lte',
    True: 'true',
    False: 'false',
    Exists: 'exists',
    Empty: 'empty',
    ArrAll: 'arr_all',
    ArrAny: 'arr_any',
    ArrNone: 'arr_none',
    Regex: 'regex'
} as const;

export type PropertyFilterOperation = typeof PropertyFilterOperation[keyof typeof PropertyFilterOperation];


/**
 * @type PropertyRef
 * reference to a property by id or name, depends on property type
 * @export
 */
export type PropertyRef = PropertyRefOneOf | PropertyRefOneOf1;

/**
 * 
 * @export
 * @interface PropertyRefOneOf
 */
export interface PropertyRefOneOf {
    /**
     * 
     * @type {string}
     * @memberof PropertyRefOneOf
     */
    'propertyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyRefOneOf
     */
    'propertyType'?: PropertyRefOneOfPropertyTypeEnum;
}

export const PropertyRefOneOfPropertyTypeEnum = {
    Event: 'event',
    User: 'user'
} as const;

export type PropertyRefOneOfPropertyTypeEnum = typeof PropertyRefOneOfPropertyTypeEnum[keyof typeof PropertyRefOneOfPropertyTypeEnum];

/**
 * 
 * @export
 * @interface PropertyRefOneOf1
 */
export interface PropertyRefOneOf1 {
    /**
     * 
     * @type {number}
     * @memberof PropertyRefOneOf1
     */
    'propertyId'?: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyRefOneOf1
     */
    'propertyType'?: PropertyRefOneOf1PropertyTypeEnum;
}

export const PropertyRefOneOf1PropertyTypeEnum = {
    Custom: 'custom',
    Event: 'event',
    User: 'user'
} as const;

export type PropertyRefOneOf1PropertyTypeEnum = typeof PropertyRefOneOf1PropertyTypeEnum[keyof typeof PropertyRefOneOf1PropertyTypeEnum];

/**
 * possible property type
 * @export
 * @enum {string}
 */

export const PropertyType = {
    Event: 'event',
    User: 'user',
    Custom: 'custom'
} as const;

export type PropertyType = typeof PropertyType[keyof typeof PropertyType];


/**
 * 
 * @export
 * @interface PropertyValuesList200Response
 */
export interface PropertyValuesList200Response {
    /**
     * 
     * @type {PropertyValuesList200ResponseValues}
     * @memberof PropertyValuesList200Response
     */
    'values'?: PropertyValuesList200ResponseValues;
}
/**
 * @type PropertyValuesList200ResponseValues
 * @export
 */
export type PropertyValuesList200ResponseValues = Array<boolean> | Array<number> | Array<string>;

/**
 * 
 * @export
 * @interface PropertyValuesListRequest
 */
export interface PropertyValuesListRequest {
    /**
     * use event name only with eventType=event|user
     * @type {string}
     * @memberof PropertyValuesListRequest
     */
    'eventName'?: string;
    /**
     * use event id only with eventType=custom
     * @type {number}
     * @memberof PropertyValuesListRequest
     */
    'eventId'?: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyValuesListRequest
     */
    'eventType'?: PropertyValuesListRequestEventTypeEnum;
    /**
     * use property name only with propertyType=event|user
     * @type {string}
     * @memberof PropertyValuesListRequest
     */
    'propertyName'?: string;
    /**
     * use property id only with propertyType=custom
     * @type {number}
     * @memberof PropertyValuesListRequest
     */
    'propertyId'?: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyValuesListRequest
     */
    'propertyType'?: PropertyValuesListRequestPropertyTypeEnum;
}

export const PropertyValuesListRequestEventTypeEnum = {
    Event: 'event',
    User: 'user',
    Custom: 'custom'
} as const;

export type PropertyValuesListRequestEventTypeEnum = typeof PropertyValuesListRequestEventTypeEnum[keyof typeof PropertyValuesListRequestEventTypeEnum];
export const PropertyValuesListRequestPropertyTypeEnum = {
    Event: 'event',
    User: 'user',
    Custom: 'custom'
} as const;

export type PropertyValuesListRequestPropertyTypeEnum = typeof PropertyValuesListRequestPropertyTypeEnum[keyof typeof PropertyValuesListRequestPropertyTypeEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const QueryAggregate = {
    Sum: 'sum',
    Avg: 'avg',
    Median: 'median',
    Min: 'min',
    Max: 'max',
    DistinctCount: 'distinctCount',
    _25thPercentile: '25thPercentile',
    _75thPercentile: '75thPercentile',
    _90thPercentile: '90thPercentile',
    _99thPercentile: '99thPercentile'
} as const;

export type QueryAggregate = typeof QueryAggregate[keyof typeof QueryAggregate];


/**
 * aggregate of property per by group
 * @export
 * @interface QueryAggregateProperty
 */
export interface QueryAggregateProperty {
    /**
     * 
     * @type {string}
     * @memberof QueryAggregateProperty
     */
    'type': QueryAggregatePropertyTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof QueryAggregateProperty
     */
    'propertyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryAggregateProperty
     */
    'propertyType': QueryAggregatePropertyPropertyTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof QueryAggregateProperty
     */
    'propertyId'?: number;
    /**
     * 
     * @type {QueryAggregate}
     * @memberof QueryAggregateProperty
     */
    'aggregate': QueryAggregate;
}

export const QueryAggregatePropertyTypeEnum = {
    AggregateProperty: 'aggregateProperty'
} as const;

export type QueryAggregatePropertyTypeEnum = typeof QueryAggregatePropertyTypeEnum[keyof typeof QueryAggregatePropertyTypeEnum];
export const QueryAggregatePropertyPropertyTypeEnum = {
    Custom: 'custom',
    Event: 'event',
    User: 'user'
} as const;

export type QueryAggregatePropertyPropertyTypeEnum = typeof QueryAggregatePropertyPropertyTypeEnum[keyof typeof QueryAggregatePropertyPropertyTypeEnum];

/**
 * 
 * @export
 * @interface QueryAggregatePropertyAllOf
 */
export interface QueryAggregatePropertyAllOf {
    /**
     * 
     * @type {QueryAggregate}
     * @memberof QueryAggregatePropertyAllOf
     */
    'aggregate'?: QueryAggregate;
}
/**
 * aggregate of property per by group
 * @export
 * @interface QueryAggregatePropertyPerGroup
 */
export interface QueryAggregatePropertyPerGroup {
    /**
     * 
     * @type {string}
     * @memberof QueryAggregatePropertyPerGroup
     */
    'type': QueryAggregatePropertyPerGroupTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof QueryAggregatePropertyPerGroup
     */
    'propertyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryAggregatePropertyPerGroup
     */
    'propertyType': QueryAggregatePropertyPerGroupPropertyTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof QueryAggregatePropertyPerGroup
     */
    'propertyId'?: number;
    /**
     * 
     * @type {QueryAggregate}
     * @memberof QueryAggregatePropertyPerGroup
     */
    'aggregate': QueryAggregate;
    /**
     * 
     * @type {QueryAggregate}
     * @memberof QueryAggregatePropertyPerGroup
     */
    'aggregatePerGroup': QueryAggregate;
}

export const QueryAggregatePropertyPerGroupTypeEnum = {
    AggregatePropertyPerGroup: 'aggregatePropertyPerGroup'
} as const;

export type QueryAggregatePropertyPerGroupTypeEnum = typeof QueryAggregatePropertyPerGroupTypeEnum[keyof typeof QueryAggregatePropertyPerGroupTypeEnum];
export const QueryAggregatePropertyPerGroupPropertyTypeEnum = {
    Custom: 'custom',
    Event: 'event',
    User: 'user'
} as const;

export type QueryAggregatePropertyPerGroupPropertyTypeEnum = typeof QueryAggregatePropertyPerGroupPropertyTypeEnum[keyof typeof QueryAggregatePropertyPerGroupPropertyTypeEnum];

/**
 * 
 * @export
 * @interface QueryAggregatePropertyPerGroupAllOf
 */
export interface QueryAggregatePropertyPerGroupAllOf {
    /**
     * 
     * @type {string}
     * @memberof QueryAggregatePropertyPerGroupAllOf
     */
    'type'?: QueryAggregatePropertyPerGroupAllOfTypeEnum;
}

export const QueryAggregatePropertyPerGroupAllOfTypeEnum = {
    AggregatePropertyPerGroup: 'aggregatePropertyPerGroup'
} as const;

export type QueryAggregatePropertyPerGroupAllOfTypeEnum = typeof QueryAggregatePropertyPerGroupAllOfTypeEnum[keyof typeof QueryAggregatePropertyPerGroupAllOfTypeEnum];

/**
 * 
 * @export
 * @interface QueryAggregatePropertyPerGroupAllOf1
 */
export interface QueryAggregatePropertyPerGroupAllOf1 {
    /**
     * 
     * @type {QueryAggregate}
     * @memberof QueryAggregatePropertyPerGroupAllOf1
     */
    'aggregate'?: QueryAggregate;
    /**
     * 
     * @type {QueryAggregate}
     * @memberof QueryAggregatePropertyPerGroupAllOf1
     */
    'aggregatePerGroup'?: QueryAggregate;
}
/**
 * event count aggregate by group
 * @export
 * @interface QueryCountPerGroup
 */
export interface QueryCountPerGroup {
    /**
     * 
     * @type {string}
     * @memberof QueryCountPerGroup
     */
    'type': QueryCountPerGroupTypeEnum;
    /**
     * 
     * @type {QueryAggregate}
     * @memberof QueryCountPerGroup
     */
    'aggregate': QueryAggregate;
}

export const QueryCountPerGroupTypeEnum = {
    CountPerGroup: 'countPerGroup'
} as const;

export type QueryCountPerGroupTypeEnum = typeof QueryCountPerGroupTypeEnum[keyof typeof QueryCountPerGroupTypeEnum];

/**
 * apply formula
 * @export
 * @interface QueryFormula
 */
export interface QueryFormula {
    /**
     * 
     * @type {string}
     * @memberof QueryFormula
     */
    'type'?: QueryFormulaTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof QueryFormula
     */
    'formula'?: string;
}

export const QueryFormulaTypeEnum = {
    Formula: 'formula'
} as const;

export type QueryFormulaTypeEnum = typeof QueryFormulaTypeEnum[keyof typeof QueryFormulaTypeEnum];

/**
 * simple query without any additional agruments
 * @export
 * @interface QuerySimple
 */
export interface QuerySimple {
    /**
     * 
     * @type {string}
     * @memberof QuerySimple
     */
    'type': QuerySimpleTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof QuerySimple
     */
    'query': QuerySimpleQueryEnum;
}

export const QuerySimpleTypeEnum = {
    Simple: 'simple'
} as const;

export type QuerySimpleTypeEnum = typeof QuerySimpleTypeEnum[keyof typeof QuerySimpleTypeEnum];
export const QuerySimpleQueryEnum = {
    CountEvents: 'countEvents',
    CountUniqueGroups: 'countUniqueGroups',
    WeeklyActiveGroups: 'weeklyActiveGroups',
    MonthlyActiveGroups: 'monthlyActiveGroups'
} as const;

export type QuerySimpleQueryEnum = typeof QuerySimpleQueryEnum[keyof typeof QuerySimpleQueryEnum];

/**
 * @type SegmentCondition
 * @export
 */
export type SegmentCondition = SegmentConditionDidEvent | SegmentConditionFunnel | SegmentConditionHadPropertyValue | SegmentConditionHasPropertyValue | object;

/**
 * did event condition
 * @export
 * @interface SegmentConditionDidEvent
 */
export interface SegmentConditionDidEvent {
    /**
     * 
     * @type {string}
     * @memberof SegmentConditionDidEvent
     */
    'type'?: SegmentConditionDidEventTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SegmentConditionDidEvent
     */
    'eventName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SegmentConditionDidEvent
     */
    'eventType'?: SegmentConditionDidEventEventTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof SegmentConditionDidEvent
     */
    'eventId'?: number;
    /**
     * 
     * @type {Array<EventFilterByProperty>}
     * @memberof SegmentConditionDidEvent
     */
    'filters'?: Array<EventFilterByProperty>;
    /**
     * 
     * @type {DidEventCount | DidEventRelativeCount | DidEventAggregateProperty | DidEventHistoricalCount}
     * @memberof SegmentConditionDidEvent
     */
    'aggregate'?: DidEventCount | DidEventRelativeCount | DidEventAggregateProperty | DidEventHistoricalCount;
}

export const SegmentConditionDidEventTypeEnum = {
    DidEvent: 'didEvent'
} as const;

export type SegmentConditionDidEventTypeEnum = typeof SegmentConditionDidEventTypeEnum[keyof typeof SegmentConditionDidEventTypeEnum];
export const SegmentConditionDidEventEventTypeEnum = {
    Custom: 'custom'
} as const;

export type SegmentConditionDidEventEventTypeEnum = typeof SegmentConditionDidEventEventTypeEnum[keyof typeof SegmentConditionDidEventEventTypeEnum];

/**
 * 
 * @export
 * @interface SegmentConditionDidEventAllOf
 */
export interface SegmentConditionDidEventAllOf {
    /**
     * 
     * @type {string}
     * @memberof SegmentConditionDidEventAllOf
     */
    'type'?: SegmentConditionDidEventAllOfTypeEnum;
}

export const SegmentConditionDidEventAllOfTypeEnum = {
    DidEvent: 'didEvent'
} as const;

export type SegmentConditionDidEventAllOfTypeEnum = typeof SegmentConditionDidEventAllOfTypeEnum[keyof typeof SegmentConditionDidEventAllOfTypeEnum];

/**
 * 
 * @export
 * @interface SegmentConditionDidEventAllOf1
 */
export interface SegmentConditionDidEventAllOf1 {
    /**
     * 
     * @type {Array<EventFilterByProperty>}
     * @memberof SegmentConditionDidEventAllOf1
     */
    'filters'?: Array<EventFilterByProperty>;
    /**
     * 
     * @type {DidEventCount | DidEventRelativeCount | DidEventAggregateProperty | DidEventHistoricalCount}
     * @memberof SegmentConditionDidEventAllOf1
     */
    'aggregate'?: DidEventCount | DidEventRelativeCount | DidEventAggregateProperty | DidEventHistoricalCount;
}
/**
 * 
 * @export
 * @interface SegmentConditionFunnel
 */
export interface SegmentConditionFunnel {
    /**
     * 
     * @type {string}
     * @memberof SegmentConditionFunnel
     */
    'type'?: SegmentConditionFunnelTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof SegmentConditionFunnel
     */
    'last'?: number;
    /**
     * 
     * @type {TimeUnit}
     * @memberof SegmentConditionFunnel
     */
    'bucket'?: TimeUnit;
}

export const SegmentConditionFunnelTypeEnum = {
    Funnel: 'funnel'
} as const;

export type SegmentConditionFunnelTypeEnum = typeof SegmentConditionFunnelTypeEnum[keyof typeof SegmentConditionFunnelTypeEnum];

/**
 * check whether the user had a property with a value
 * @export
 * @interface SegmentConditionHadPropertyValue
 */
export interface SegmentConditionHadPropertyValue {
    /**
     * 
     * @type {string}
     * @memberof SegmentConditionHadPropertyValue
     */
    'type': SegmentConditionHadPropertyValueTypeEnum;
    /**
     * property name. Because property here is a user only, we don\'t need propertyType
     * @type {string}
     * @memberof SegmentConditionHadPropertyValue
     */
    'propertyName': string;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof SegmentConditionHadPropertyValue
     */
    'operation': PropertyFilterOperation;
    /**
     * one or more values. Doesn\'t need if operation is \"empty\" or \"exist\"
     * @type {Array<Value>}
     * @memberof SegmentConditionHadPropertyValue
     */
    'values'?: Array<Value>;
    /**
     * 
     * @type {SegmentConditionHadPropertyValueTime}
     * @memberof SegmentConditionHadPropertyValue
     */
    'time': SegmentConditionHadPropertyValueTime;
}

export const SegmentConditionHadPropertyValueTypeEnum = {
    HadPropertyValue: 'hadPropertyValue'
} as const;

export type SegmentConditionHadPropertyValueTypeEnum = typeof SegmentConditionHadPropertyValueTypeEnum[keyof typeof SegmentConditionHadPropertyValueTypeEnum];

/**
 * @type SegmentConditionHadPropertyValueTime
 * time frame
 * @export
 */
export type SegmentConditionHadPropertyValueTime = TimeBetween | TimeLast | TimeWindowEach;

/**
 * check whether the user currently has a property with a value
 * @export
 * @interface SegmentConditionHasPropertyValue
 */
export interface SegmentConditionHasPropertyValue {
    /**
     * 
     * @type {string}
     * @memberof SegmentConditionHasPropertyValue
     */
    'type': SegmentConditionHasPropertyValueTypeEnum;
    /**
     * property name. Because property here is a user only, we don\'t need propertyType
     * @type {string}
     * @memberof SegmentConditionHasPropertyValue
     */
    'propertyName': string;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof SegmentConditionHasPropertyValue
     */
    'operation': PropertyFilterOperation;
    /**
     * one or more values. Doesn\'t need if operation is \"empty\" or \"exist\"
     * @type {Array<Value>}
     * @memberof SegmentConditionHasPropertyValue
     */
    'values'?: Array<Value>;
}

export const SegmentConditionHasPropertyValueTypeEnum = {
    HasPropertyValue: 'hasPropertyValue'
} as const;

export type SegmentConditionHasPropertyValueTypeEnum = typeof SegmentConditionHasPropertyValueTypeEnum[keyof typeof SegmentConditionHasPropertyValueTypeEnum];

/**
 * time spent after the first use of event. Use in segmentation
 * @export
 * @interface TimeAfterFirstUse
 */
export interface TimeAfterFirstUse {
    /**
     * 
     * @type {string}
     * @memberof TimeAfterFirstUse
     */
    'type': TimeAfterFirstUseTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof TimeAfterFirstUse
     */
    'within': number;
    /**
     * 
     * @type {TimeUnit}
     * @memberof TimeAfterFirstUse
     */
    'unit': TimeUnit;
}

export const TimeAfterFirstUseTypeEnum = {
    AfterFirstUse: 'afterFirstUse'
} as const;

export type TimeAfterFirstUseTypeEnum = typeof TimeAfterFirstUseTypeEnum[keyof typeof TimeAfterFirstUseTypeEnum];

/**
 * time range between fixed values
 * @export
 * @interface TimeBetween
 */
export interface TimeBetween {
    /**
     * 
     * @type {string}
     * @memberof TimeBetween
     */
    'type': TimeBetweenTypeEnum;
    /**
     * start date
     * @type {string}
     * @memberof TimeBetween
     */
    'from': string;
    /**
     * end date
     * @type {string}
     * @memberof TimeBetween
     */
    'to': string;
}

export const TimeBetweenTypeEnum = {
    Between: 'between'
} as const;

export type TimeBetweenTypeEnum = typeof TimeBetweenTypeEnum[keyof typeof TimeBetweenTypeEnum];

/**
 * time range between fixed value and current time
 * @export
 * @interface TimeFrom
 */
export interface TimeFrom {
    /**
     * 
     * @type {string}
     * @memberof TimeFrom
     */
    'type': TimeFromTypeEnum;
    /**
     * start date
     * @type {string}
     * @memberof TimeFrom
     */
    'from': string;
}

export const TimeFromTypeEnum = {
    From: 'from'
} as const;

export type TimeFromTypeEnum = typeof TimeFromTypeEnum[keyof typeof TimeFromTypeEnum];

/**
 * take last N days/weeks
 * @export
 * @interface TimeLast
 */
export interface TimeLast {
    /**
     * 
     * @type {string}
     * @memberof TimeLast
     */
    'type': TimeLastTypeEnum;
    /**
     * N days/weeks
     * @type {number}
     * @memberof TimeLast
     */
    'n': number;
    /**
     * 
     * @type {TimeUnit}
     * @memberof TimeLast
     */
    'unit': TimeUnit;
}

export const TimeLastTypeEnum = {
    Last: 'last'
} as const;

export type TimeLastTypeEnum = typeof TimeLastTypeEnum[keyof typeof TimeLastTypeEnum];

/**
 * time unit
 * @export
 * @enum {string}
 */

export const TimeUnit = {
    Second: 'second',
    Minute: 'minute',
    Hour: 'hour',
    Day: 'day',
    Week: 'week',
    Month: 'month',
    Year: 'year'
} as const;

export type TimeUnit = typeof TimeUnit[keyof typeof TimeUnit];


/**
 * time unit with session
 * @export
 * @enum {string}
 */

export const TimeUnitWithSession = {
    Second: 'second',
    Minute: 'minute',
    Hour: 'hour',
    Day: 'day',
    Week: 'week',
    Month: 'month',
    Year: 'year',
    Session: 'session'
} as const;

export type TimeUnitWithSession = typeof TimeUnitWithSession[keyof typeof TimeUnitWithSession];


/**
 * window operation for segmentation. Tells that event should be triggered each timeunit (each day, for instance) {   \"time\": {     \"type\": \"each\",     \"unit\":\"day\"   } } 
 * @export
 * @interface TimeWindowEach
 */
export interface TimeWindowEach {
    /**
     * 
     * @type {string}
     * @memberof TimeWindowEach
     */
    'type': TimeWindowEachTypeEnum;
    /**
     * 
     * @type {TimeUnit}
     * @memberof TimeWindowEach
     */
    'unit': TimeUnit;
}

export const TimeWindowEachTypeEnum = {
    WindowEach: 'windowEach'
} as const;

export type TimeWindowEachTypeEnum = typeof TimeWindowEachTypeEnum[keyof typeof TimeWindowEachTypeEnum];

/**
 * Custom Event is an alias to an expression which is used while querying. You can use regular or custom events in expression. You can combine events in expression, you can use filter by properties.
 * @export
 * @interface UpdateCustomEventRequest
 */
export interface UpdateCustomEventRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomEventRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomEventRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomEventRequest
     */
    'status'?: UpdateCustomEventRequestStatusEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateCustomEventRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<CustomEventEvent>}
     * @memberof UpdateCustomEventRequest
     */
    'events': Array<CustomEventEvent>;
}

export const UpdateCustomEventRequestStatusEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type UpdateCustomEventRequestStatusEnum = typeof UpdateCustomEventRequestStatusEnum[keyof typeof UpdateCustomEventRequestStatusEnum];

/**
 * Update event request
 * @export
 * @interface UpdateEventRequest
 */
export interface UpdateEventRequest {
    /**
     * event name to display. If empty then name property is used.
     * @type {string}
     * @memberof UpdateEventRequest
     */
    'displayName'?: string;
    /**
     * description
     * @type {string}
     * @memberof UpdateEventRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEventRequest
     */
    'status'?: UpdateEventRequestStatusEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateEventRequest
     */
    'tags'?: Array<string>;
}

export const UpdateEventRequestStatusEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type UpdateEventRequestStatusEnum = typeof UpdateEventRequestStatusEnum[keyof typeof UpdateEventRequestStatusEnum];

/**
 * 
 * @export
 * @interface UpdateGroupRecordRequest
 */
export interface UpdateGroupRecordRequest {
    /**
     * map of group property name and property value pairs
     * @type {object}
     * @memberof UpdateGroupRecordRequest
     */
    'properties'?: object;
}
/**
 * Propetty update
 * @export
 * @interface UpdatePropertyRequest
 */
export interface UpdatePropertyRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdatePropertyRequest
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePropertyRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePropertyRequest
     */
    'status'?: UpdatePropertyRequestStatusEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdatePropertyRequest
     */
    'tags'?: Array<string>;
}

export const UpdatePropertyRequestStatusEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type UpdatePropertyRequestStatusEnum = typeof UpdatePropertyRequestStatusEnum[keyof typeof UpdatePropertyRequestStatusEnum];

/**
 * 
 * @export
 * @interface UserPropertiesList200Response
 */
export interface UserPropertiesList200Response {
    /**
     * 
     * @type {Array<Property>}
     * @memberof UserPropertiesList200Response
     */
    'events'?: Array<Property>;
    /**
     * 
     * @type {ListResponseMetadataMeta}
     * @memberof UserPropertiesList200Response
     */
    'meta'?: ListResponseMetadataMeta;
}
/**
 * 
 * @export
 * @interface UserPropertiesList200ResponseAllOf
 */
export interface UserPropertiesList200ResponseAllOf {
    /**
     * 
     * @type {Array<Property>}
     * @memberof UserPropertiesList200ResponseAllOf
     */
    'events'?: Array<Property>;
}
/**
 * @type Value
 * value
 * @export
 */
export type Value = boolean | number | string;


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Refresh access token
         * @param {AuthAccessRequest} authAccessRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAccess: async (authAccessRequest: AuthAccessRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authAccessRequest' is not null or undefined
            assertParamExists('authAccess', 'authAccessRequest', authAccessRequest)
            const localVarPath = `/v1/auth/access`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authAccessRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Basic login
         * @param {BasicLoginRequest} basicLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basicLogin: async (basicLoginRequest: BasicLoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'basicLoginRequest' is not null or undefined
            assertParamExists('basicLogin', 'basicLoginRequest', basicLoginRequest)
            const localVarPath = `/v1/auth/basic/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(basicLoginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Log out
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Refresh access token
         * @param {AuthAccessRequest} authAccessRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authAccess(authAccessRequest: AuthAccessRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthAccess200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authAccess(authAccessRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Basic login
         * @param {BasicLoginRequest} basicLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async basicLogin(basicLoginRequest: BasicLoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasicLogin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.basicLogin(basicLoginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Log out
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Refresh access token
         * @param {AuthAccessRequest} authAccessRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAccess(authAccessRequest: AuthAccessRequest, options?: any): AxiosPromise<AuthAccess200Response> {
            return localVarFp.authAccess(authAccessRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Basic login
         * @param {BasicLoginRequest} basicLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basicLogin(basicLoginRequest: BasicLoginRequest, options?: any): AxiosPromise<BasicLogin200Response> {
            return localVarFp.basicLogin(basicLoginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Log out
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<void> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Refresh access token
     * @param {AuthAccessRequest} authAccessRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authAccess(authAccessRequest: AuthAccessRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authAccess(authAccessRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Basic login
     * @param {BasicLoginRequest} basicLoginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public basicLogin(basicLoginRequest: BasicLoginRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).basicLogin(basicLoginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Log out
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logout(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create custom event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {CreateCustomEventRequest} createCustomEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomEvent: async (organizationId: number, projectId: number, createCustomEventRequest: CreateCustomEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createCustomEvent', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createCustomEvent', 'projectId', projectId)
            // verify required parameter 'createCustomEventRequest' is not null or undefined
            assertParamExists('createCustomEvent', 'createCustomEventRequest', createCustomEventRequest)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/custom-events`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCustomEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Custom events list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customEventsList: async (organizationId: number, projectId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('customEventsList', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('customEventsList', 'projectId', projectId)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/custom-events`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete custom event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomEvent: async (organizationId: number, projectId: number, eventId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteCustomEvent', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteCustomEvent', 'projectId', projectId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('deleteCustomEvent', 'eventId', eventId)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/custom-events/{event_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get events
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {EventRecordsListRequest} eventRecordsListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventRecordsList: async (organizationId: number, projectId: number, eventRecordsListRequest: EventRecordsListRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('eventRecordsList', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('eventRecordsList', 'projectId', projectId)
            // verify required parameter 'eventRecordsListRequest' is not null or undefined
            assertParamExists('eventRecordsList', 'eventRecordsListRequest', eventRecordsListRequest)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/data/event-records`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventRecordsListRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Events list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsList: async (organizationId: number, projectId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('eventsList', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('eventsList', 'projectId', projectId)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/events`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get custom event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomEvent: async (organizationId: number, projectId: number, eventId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getCustomEvent', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getCustomEvent', 'projectId', projectId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getCustomEvent', 'eventId', eventId)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/custom-events/{event_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent: async (organizationId: number, projectId: number, eventId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getEvent', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getEvent', 'projectId', projectId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEvent', 'eventId', eventId)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/events/{event_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get event property
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventProperty: async (organizationId: number, projectId: number, propertyId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getEventProperty', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getEventProperty', 'projectId', projectId)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('getEventProperty', 'propertyId', propertyId)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/event_properties/{property_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"property_id"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get event record
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} id Event Record ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventRecord: async (organizationId: number, projectId: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getEventRecord', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getEventRecord', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEventRecord', 'id', id)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/data/event-records/{id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user property
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProperty: async (organizationId: number, projectId: number, propertyId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getUserProperty', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getUserProperty', 'projectId', projectId)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('getUserProperty', 'propertyId', propertyId)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/user_properties/{property_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"property_id"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update custom event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {string} eventId Custom Event ID
         * @param {UpdateCustomEventRequest} updateCustomEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomEvent: async (organizationId: number, projectId: number, eventId: string, updateCustomEventRequest: UpdateCustomEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateCustomEvent', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateCustomEvent', 'projectId', projectId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateCustomEvent', 'eventId', eventId)
            // verify required parameter 'updateCustomEventRequest' is not null or undefined
            assertParamExists('updateCustomEvent', 'updateCustomEventRequest', updateCustomEventRequest)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/custom-events/{event_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCustomEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {string} eventId Event ID
         * @param {UpdateEventRequest} updateEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent: async (organizationId: number, projectId: number, eventId: string, updateEventRequest: UpdateEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateEvent', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateEvent', 'projectId', projectId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEvent', 'eventId', eventId)
            // verify required parameter 'updateEventRequest' is not null or undefined
            assertParamExists('updateEvent', 'updateEventRequest', updateEventRequest)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/events/{event_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create custom event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {CreateCustomEventRequest} createCustomEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomEvent(organizationId: number, projectId: number, createCustomEventRequest: CreateCustomEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomEvent(organizationId, projectId, createCustomEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Custom events list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customEventsList(organizationId: number, projectId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomEventsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customEventsList(organizationId, projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete custom event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomEvent(organizationId: number, projectId: number, eventId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomEvent(organizationId, projectId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get events
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {EventRecordsListRequest} eventRecordsListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventRecordsList(organizationId: number, projectId: number, eventRecordsListRequest: EventRecordsListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventRecordsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventRecordsList(organizationId, projectId, eventRecordsListRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Events list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsList(organizationId: number, projectId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsList(organizationId, projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get custom event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomEvent(organizationId: number, projectId: number, eventId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomEvent(organizationId, projectId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvent(organizationId: number, projectId: number, eventId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvent(organizationId, projectId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get event property
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventProperty(organizationId: number, projectId: number, propertyId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventProperty(organizationId, projectId, propertyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get event record
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} id Event Record ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventRecord(organizationId: number, projectId: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventRecord(organizationId, projectId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user property
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserProperty(organizationId: number, projectId: number, propertyId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserProperty(organizationId, projectId, propertyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update custom event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {string} eventId Custom Event ID
         * @param {UpdateCustomEventRequest} updateCustomEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomEvent(organizationId: number, projectId: number, eventId: string, updateCustomEventRequest: UpdateCustomEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomEvent(organizationId, projectId, eventId, updateCustomEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {string} eventId Event ID
         * @param {UpdateEventRequest} updateEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEvent(organizationId: number, projectId: number, eventId: string, updateEventRequest: UpdateEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvent(organizationId, projectId, eventId, updateEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create custom event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {CreateCustomEventRequest} createCustomEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomEvent(organizationId: number, projectId: number, createCustomEventRequest: CreateCustomEventRequest, options?: any): AxiosPromise<CustomEvent> {
            return localVarFp.createCustomEvent(organizationId, projectId, createCustomEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Custom events list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customEventsList(organizationId: number, projectId: number, options?: any): AxiosPromise<CustomEventsList200Response> {
            return localVarFp.customEventsList(organizationId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete custom event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomEvent(organizationId: number, projectId: number, eventId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCustomEvent(organizationId, projectId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get events
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {EventRecordsListRequest} eventRecordsListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventRecordsList(organizationId: number, projectId: number, eventRecordsListRequest: EventRecordsListRequest, options?: any): AxiosPromise<EventRecordsList200Response> {
            return localVarFp.eventRecordsList(organizationId, projectId, eventRecordsListRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Events list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsList(organizationId: number, projectId: number, options?: any): AxiosPromise<EventsList200Response> {
            return localVarFp.eventsList(organizationId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get custom event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomEvent(organizationId: number, projectId: number, eventId: number, options?: any): AxiosPromise<CustomEvent> {
            return localVarFp.getCustomEvent(organizationId, projectId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(organizationId: number, projectId: number, eventId: number, options?: any): AxiosPromise<Event> {
            return localVarFp.getEvent(organizationId, projectId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get event property
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventProperty(organizationId: number, projectId: number, propertyId: number, options?: any): AxiosPromise<Property> {
            return localVarFp.getEventProperty(organizationId, projectId, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get event record
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} id Event Record ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventRecord(organizationId: number, projectId: number, id: number, options?: any): AxiosPromise<EventRecord> {
            return localVarFp.getEventRecord(organizationId, projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user property
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProperty(organizationId: number, projectId: number, propertyId: number, options?: any): AxiosPromise<Property> {
            return localVarFp.getUserProperty(organizationId, projectId, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update custom event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {string} eventId Custom Event ID
         * @param {UpdateCustomEventRequest} updateCustomEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomEvent(organizationId: number, projectId: number, eventId: string, updateCustomEventRequest: UpdateCustomEventRequest, options?: any): AxiosPromise<CustomEvent> {
            return localVarFp.updateCustomEvent(organizationId, projectId, eventId, updateCustomEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {string} eventId Event ID
         * @param {UpdateEventRequest} updateEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent(organizationId: number, projectId: number, eventId: string, updateEventRequest: UpdateEventRequest, options?: any): AxiosPromise<Event> {
            return localVarFp.updateEvent(organizationId, projectId, eventId, updateEventRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * 
     * @summary Create custom event
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {CreateCustomEventRequest} createCustomEventRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public createCustomEvent(organizationId: number, projectId: number, createCustomEventRequest: CreateCustomEventRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).createCustomEvent(organizationId, projectId, createCustomEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Custom events list
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public customEventsList(organizationId: number, projectId: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).customEventsList(organizationId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete custom event
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {number} eventId Event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public deleteCustomEvent(organizationId: number, projectId: number, eventId: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).deleteCustomEvent(organizationId, projectId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get events
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {EventRecordsListRequest} eventRecordsListRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventRecordsList(organizationId: number, projectId: number, eventRecordsListRequest: EventRecordsListRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventRecordsList(organizationId, projectId, eventRecordsListRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Events list
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsList(organizationId: number, projectId: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsList(organizationId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get custom event
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {number} eventId Event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getCustomEvent(organizationId: number, projectId: number, eventId: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).getCustomEvent(organizationId, projectId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get event
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {number} eventId Event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEvent(organizationId: number, projectId: number, eventId: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEvent(organizationId, projectId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get event property
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {number} propertyId Property ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEventProperty(organizationId: number, projectId: number, propertyId: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEventProperty(organizationId, projectId, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get event record
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {number} id Event Record ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEventRecord(organizationId: number, projectId: number, id: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEventRecord(organizationId, projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user property
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {number} propertyId Property ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getUserProperty(organizationId: number, projectId: number, propertyId: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).getUserProperty(organizationId, projectId, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update custom event
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {string} eventId Custom Event ID
     * @param {UpdateCustomEventRequest} updateCustomEventRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateCustomEvent(organizationId: number, projectId: number, eventId: string, updateCustomEventRequest: UpdateCustomEventRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).updateCustomEvent(organizationId, projectId, eventId, updateCustomEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update event
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {string} eventId Event ID
     * @param {UpdateEventRequest} updateEventRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateEvent(organizationId: number, projectId: number, eventId: string, updateEventRequest: UpdateEventRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).updateEvent(organizationId, projectId, eventId, updateEventRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get group record
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} id Group Record ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupRecord: async (organizationId: number, projectId: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getGroupRecord', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getGroupRecord', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGroupRecord', 'id', id)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/data/group-records/{id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get group records
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {GroupRecordsListRequest} groupRecordsListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupEventsList: async (organizationId: number, projectId: number, groupRecordsListRequest: GroupRecordsListRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('groupEventsList', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('groupEventsList', 'projectId', projectId)
            // verify required parameter 'groupRecordsListRequest' is not null or undefined
            assertParamExists('groupEventsList', 'groupRecordsListRequest', groupRecordsListRequest)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/data/group-records`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupRecordsListRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update group record
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} id Group Record ID
         * @param {UpdateGroupRecordRequest} updateGroupRecordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupRecord: async (organizationId: number, projectId: number, id: number, updateGroupRecordRequest: UpdateGroupRecordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateGroupRecord', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateGroupRecord', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateGroupRecord', 'id', id)
            // verify required parameter 'updateGroupRecordRequest' is not null or undefined
            assertParamExists('updateGroupRecord', 'updateGroupRecordRequest', updateGroupRecordRequest)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/data/group-records/{id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGroupRecordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get group record
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} id Group Record ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupRecord(organizationId: number, projectId: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupRecord(organizationId, projectId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get group records
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {GroupRecordsListRequest} groupRecordsListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupEventsList(organizationId: number, projectId: number, groupRecordsListRequest: GroupRecordsListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupEventsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupEventsList(organizationId, projectId, groupRecordsListRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update group record
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} id Group Record ID
         * @param {UpdateGroupRecordRequest} updateGroupRecordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupRecord(organizationId: number, projectId: number, id: number, updateGroupRecordRequest: UpdateGroupRecordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupRecord(organizationId, projectId, id, updateGroupRecordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get group record
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} id Group Record ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupRecord(organizationId: number, projectId: number, id: number, options?: any): AxiosPromise<GroupRecord> {
            return localVarFp.getGroupRecord(organizationId, projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get group records
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {GroupRecordsListRequest} groupRecordsListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupEventsList(organizationId: number, projectId: number, groupRecordsListRequest: GroupRecordsListRequest, options?: any): AxiosPromise<GroupEventsList200Response> {
            return localVarFp.groupEventsList(organizationId, projectId, groupRecordsListRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update group record
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} id Group Record ID
         * @param {UpdateGroupRecordRequest} updateGroupRecordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupRecord(organizationId: number, projectId: number, id: number, updateGroupRecordRequest: UpdateGroupRecordRequest, options?: any): AxiosPromise<GroupRecord> {
            return localVarFp.updateGroupRecord(organizationId, projectId, id, updateGroupRecordRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * 
     * @summary Get group record
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {number} id Group Record ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupRecord(organizationId: number, projectId: number, id: number, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupRecord(organizationId, projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get group records
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {GroupRecordsListRequest} groupRecordsListRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupEventsList(organizationId: number, projectId: number, groupRecordsListRequest: GroupRecordsListRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupEventsList(organizationId, projectId, groupRecordsListRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update group record
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {number} id Group Record ID
     * @param {UpdateGroupRecordRequest} updateGroupRecordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public updateGroupRecord(organizationId: number, projectId: number, id: number, updateGroupRecordRequest: UpdateGroupRecordRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).updateGroupRecord(organizationId, projectId, id, updateGroupRecordRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PropertiesApi - axios parameter creator
 * @export
 */
export const PropertiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Event custom properties list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customPropertiesList: async (organizationId: number, projectId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('customPropertiesList', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('customPropertiesList', 'projectId', projectId)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/custom-properties`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Event properties list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventPropertiesList: async (organizationId: number, projectId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('eventPropertiesList', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('eventPropertiesList', 'projectId', projectId)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/event_properties`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of property values
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {PropertyValuesListRequest} propertyValuesListRequest property type and property id/name must be specified. Event is optional and works as a filter for values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propertyValuesList: async (organizationId: number, projectId: number, propertyValuesListRequest: PropertyValuesListRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('propertyValuesList', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('propertyValuesList', 'projectId', projectId)
            // verify required parameter 'propertyValuesListRequest' is not null or undefined
            assertParamExists('propertyValuesList', 'propertyValuesListRequest', propertyValuesListRequest)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/data/property-values`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(propertyValuesListRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update event property
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {string} propertyId Property ID
         * @param {UpdatePropertyRequest} updatePropertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventProperty: async (organizationId: number, projectId: number, propertyId: string, updatePropertyRequest: UpdatePropertyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateEventProperty', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateEventProperty', 'projectId', projectId)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('updateEventProperty', 'propertyId', propertyId)
            // verify required parameter 'updatePropertyRequest' is not null or undefined
            assertParamExists('updateEventProperty', 'updatePropertyRequest', updatePropertyRequest)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/event_properties/{property_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"property_id"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePropertyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user property
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {UpdatePropertyRequest} updatePropertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserProperty: async (organizationId: number, projectId: number, propertyId: number, updatePropertyRequest: UpdatePropertyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateUserProperty', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateUserProperty', 'projectId', projectId)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('updateUserProperty', 'propertyId', propertyId)
            // verify required parameter 'updatePropertyRequest' is not null or undefined
            assertParamExists('updateUserProperty', 'updatePropertyRequest', updatePropertyRequest)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/user_properties/{property_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"property_id"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePropertyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User properties list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPropertiesList: async (organizationId: number, projectId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('userPropertiesList', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('userPropertiesList', 'projectId', projectId)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/user_properties`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertiesApi - functional programming interface
 * @export
 */
export const PropertiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PropertiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Event custom properties list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customPropertiesList(organizationId: number, projectId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomPropertiesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customPropertiesList(organizationId, projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Event properties list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventPropertiesList(organizationId: number, projectId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPropertiesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventPropertiesList(organizationId, projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List of property values
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {PropertyValuesListRequest} propertyValuesListRequest property type and property id/name must be specified. Event is optional and works as a filter for values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async propertyValuesList(organizationId: number, projectId: number, propertyValuesListRequest: PropertyValuesListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyValuesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.propertyValuesList(organizationId, projectId, propertyValuesListRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update event property
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {string} propertyId Property ID
         * @param {UpdatePropertyRequest} updatePropertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventProperty(organizationId: number, projectId: number, propertyId: string, updatePropertyRequest: UpdatePropertyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventProperty(organizationId, projectId, propertyId, updatePropertyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user property
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {UpdatePropertyRequest} updatePropertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserProperty(organizationId: number, projectId: number, propertyId: number, updatePropertyRequest: UpdatePropertyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserProperty(organizationId, projectId, propertyId, updatePropertyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary User properties list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userPropertiesList(organizationId: number, projectId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPropertiesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userPropertiesList(organizationId, projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PropertiesApi - factory interface
 * @export
 */
export const PropertiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PropertiesApiFp(configuration)
    return {
        /**
         * 
         * @summary Event custom properties list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customPropertiesList(organizationId: number, projectId: number, options?: any): AxiosPromise<CustomPropertiesList200Response> {
            return localVarFp.customPropertiesList(organizationId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Event properties list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventPropertiesList(organizationId: number, projectId: number, options?: any): AxiosPromise<UserPropertiesList200Response> {
            return localVarFp.eventPropertiesList(organizationId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of property values
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {PropertyValuesListRequest} propertyValuesListRequest property type and property id/name must be specified. Event is optional and works as a filter for values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propertyValuesList(organizationId: number, projectId: number, propertyValuesListRequest: PropertyValuesListRequest, options?: any): AxiosPromise<PropertyValuesList200Response> {
            return localVarFp.propertyValuesList(organizationId, projectId, propertyValuesListRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update event property
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {string} propertyId Property ID
         * @param {UpdatePropertyRequest} updatePropertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventProperty(organizationId: number, projectId: number, propertyId: string, updatePropertyRequest: UpdatePropertyRequest, options?: any): AxiosPromise<Property> {
            return localVarFp.updateEventProperty(organizationId, projectId, propertyId, updatePropertyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user property
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {UpdatePropertyRequest} updatePropertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserProperty(organizationId: number, projectId: number, propertyId: number, updatePropertyRequest: UpdatePropertyRequest, options?: any): AxiosPromise<Property> {
            return localVarFp.updateUserProperty(organizationId, projectId, propertyId, updatePropertyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary User properties list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPropertiesList(organizationId: number, projectId: number, options?: any): AxiosPromise<UserPropertiesList200Response> {
            return localVarFp.userPropertiesList(organizationId, projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PropertiesApi - object-oriented interface
 * @export
 * @class PropertiesApi
 * @extends {BaseAPI}
 */
export class PropertiesApi extends BaseAPI {
    /**
     * 
     * @summary Event custom properties list
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public customPropertiesList(organizationId: number, projectId: number, options?: AxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).customPropertiesList(organizationId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Event properties list
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public eventPropertiesList(organizationId: number, projectId: number, options?: AxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).eventPropertiesList(organizationId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of property values
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {PropertyValuesListRequest} propertyValuesListRequest property type and property id/name must be specified. Event is optional and works as a filter for values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public propertyValuesList(organizationId: number, projectId: number, propertyValuesListRequest: PropertyValuesListRequest, options?: AxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).propertyValuesList(organizationId, projectId, propertyValuesListRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update event property
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {string} propertyId Property ID
     * @param {UpdatePropertyRequest} updatePropertyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public updateEventProperty(organizationId: number, projectId: number, propertyId: string, updatePropertyRequest: UpdatePropertyRequest, options?: AxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).updateEventProperty(organizationId, projectId, propertyId, updatePropertyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user property
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {number} propertyId Property ID
     * @param {UpdatePropertyRequest} updatePropertyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public updateUserProperty(organizationId: number, projectId: number, propertyId: number, updatePropertyRequest: UpdatePropertyRequest, options?: AxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).updateUserProperty(organizationId, projectId, propertyId, updatePropertyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary User properties list
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public userPropertiesList(organizationId: number, projectId: number, options?: AxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).userPropertiesList(organizationId, projectId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QueryApi - axios parameter creator
 * @export
 */
export const QueryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Funnel query
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {FunnelQuery} [funnelQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        funnelQuery: async (organizationId: number, projectId: number, funnelQuery?: FunnelQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('funnelQuery', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('funnelQuery', 'projectId', projectId)
            const localVarPath = `/organizations/{organization_id}/projects/{project_id}/reports/funnel`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(funnelQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryApi - functional programming interface
 * @export
 */
export const QueryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Funnel query
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {FunnelQuery} [funnelQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async funnelQuery(organizationId: number, projectId: number, funnelQuery?: FunnelQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataTableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.funnelQuery(organizationId, projectId, funnelQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QueryApi - factory interface
 * @export
 */
export const QueryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueryApiFp(configuration)
    return {
        /**
         * 
         * @summary Funnel query
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {FunnelQuery} [funnelQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        funnelQuery(organizationId: number, projectId: number, funnelQuery?: FunnelQuery, options?: any): AxiosPromise<DataTableResponse> {
            return localVarFp.funnelQuery(organizationId, projectId, funnelQuery, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export class QueryApi extends BaseAPI {
    /**
     * 
     * @summary Funnel query
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {FunnelQuery} [funnelQuery] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public funnelQuery(organizationId: number, projectId: number, funnelQuery?: FunnelQuery, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).funnelQuery(organizationId, projectId, funnelQuery, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReportsApi - axios parameter creator
 * @export
 */
export const ReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Event segmentation query
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {EventSegmentation} [eventSegmentation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventSegmentationQuery: async (organizationId: number, projectId: number, eventSegmentation?: EventSegmentation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('eventSegmentationQuery', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('eventSegmentationQuery', 'projectId', projectId)
            const localVarPath = `/organizations/{organization_id}/projects/{project_id}/reports/event-segmentation`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventSegmentation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportsApi - functional programming interface
 * @export
 */
export const ReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Event segmentation query
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {EventSegmentation} [eventSegmentation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventSegmentationQuery(organizationId: number, projectId: number, eventSegmentation?: EventSegmentation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataTableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventSegmentationQuery(organizationId, projectId, eventSegmentation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReportsApi - factory interface
 * @export
 */
export const ReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportsApiFp(configuration)
    return {
        /**
         * 
         * @summary Event segmentation query
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {EventSegmentation} [eventSegmentation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventSegmentationQuery(organizationId: number, projectId: number, eventSegmentation?: EventSegmentation, options?: any): AxiosPromise<DataTableResponse> {
            return localVarFp.eventSegmentationQuery(organizationId, projectId, eventSegmentation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReportsApi - object-oriented interface
 * @export
 * @class ReportsApi
 * @extends {BaseAPI}
 */
export class ReportsApi extends BaseAPI {
    /**
     * 
     * @summary Event segmentation query
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {EventSegmentation} [eventSegmentation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public eventSegmentationQuery(organizationId: number, projectId: number, eventSegmentation?: EventSegmentation, options?: AxiosRequestConfig) {
        return ReportsApiFp(this.configuration).eventSegmentationQuery(organizationId, projectId, eventSegmentation, options).then((request) => request(this.axios, this.basePath));
    }
}


