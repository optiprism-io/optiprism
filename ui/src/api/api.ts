/* tslint:disable */
/* eslint-disable */
/**
 * OptiPrism
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api@optiprism.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AnalysisCumulative
 */
export interface AnalysisCumulative {
    /**
     * 
     * @type {string}
     * @memberof AnalysisCumulative
     */
    'type'?: AnalysisCumulativeTypeEnum;
}

export const AnalysisCumulativeTypeEnum = {
    Cumulative: 'cumulative'
} as const;

export type AnalysisCumulativeTypeEnum = typeof AnalysisCumulativeTypeEnum[keyof typeof AnalysisCumulativeTypeEnum];

/**
 * 
 * @export
 * @interface AnalysisLinear
 */
export interface AnalysisLinear {
    /**
     * 
     * @type {string}
     * @memberof AnalysisLinear
     */
    'type'?: AnalysisLinearTypeEnum;
}

export const AnalysisLinearTypeEnum = {
    Linear: 'linear'
} as const;

export type AnalysisLinearTypeEnum = typeof AnalysisLinearTypeEnum[keyof typeof AnalysisLinearTypeEnum];

/**
 * 
 * @export
 * @interface AnalysisRollingAverage
 */
export interface AnalysisRollingAverage {
    /**
     * 
     * @type {string}
     * @memberof AnalysisRollingAverage
     */
    'type'?: AnalysisRollingAverageTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof AnalysisRollingAverage
     */
    'window'?: number;
}

export const AnalysisRollingAverageTypeEnum = {
    RollingAverage: 'rollingAverage'
} as const;

export type AnalysisRollingAverageTypeEnum = typeof AnalysisRollingAverageTypeEnum[keyof typeof AnalysisRollingAverageTypeEnum];

/**
 * 
 * @export
 * @interface AnalysisRollingWindow
 */
export interface AnalysisRollingWindow {
    /**
     * 
     * @type {string}
     * @memberof AnalysisRollingWindow
     */
    'type'?: AnalysisRollingWindowTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof AnalysisRollingWindow
     */
    'window'?: number;
}

export const AnalysisRollingWindowTypeEnum = {
    RollingWindow: 'rollingWindow'
} as const;

export type AnalysisRollingWindowTypeEnum = typeof AnalysisRollingWindowTypeEnum[keyof typeof AnalysisRollingWindowTypeEnum];

/**
 * breakdown by property.
 * @export
 * @interface BreakdownByProperty
 */
export interface BreakdownByProperty {
    /**
     * 
     * @type {string}
     * @memberof BreakdownByProperty
     */
    'type'?: BreakdownByPropertyTypeEnum;
    /**
     *
     * @type {string}
     * @memberof BreakdownByProperty
     */
    'propertyName'?: string;
    /**
     *
     * @type {string}
     * @memberof BreakdownByProperty
     */
    'propertyType': BreakdownByPropertyPropertyTypeEnum;
    /**
     *
     * @type {number}
     * @memberof BreakdownByProperty
     */
    'propertyId'?: number;
}

export const BreakdownByPropertyTypeEnum = {
    Property: 'property'
} as const;

export type BreakdownByPropertyTypeEnum = typeof BreakdownByPropertyTypeEnum[keyof typeof BreakdownByPropertyTypeEnum];
export const BreakdownByPropertyPropertyTypeEnum = {
    Custom: 'custom'
} as const;

export type BreakdownByPropertyPropertyTypeEnum = typeof BreakdownByPropertyPropertyTypeEnum[keyof typeof BreakdownByPropertyPropertyTypeEnum];

/**
 * chart type
 * @export
 * @enum {string}
 */

export const ChartType = {
    Line: 'line',
    Bar: 'bar'
} as const;

export type ChartType = typeof ChartType[keyof typeof ChartType];


/**
 * Custom Event is an alias to an expression which is used while querying. You can use regular or custom events in expression. You can combine events in expression, you can use filter by properties.
 * @export
 * @interface CreateCustomEventRequest
 */
export interface CreateCustomEventRequest {
    /**
     *
     * @type {string}
     * @memberof CreateCustomEventRequest
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof CreateCustomEventRequest
     */
    'description'?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof CreateCustomEventRequest
     */
    'tags'?: Array<string>;
    /**
     *
     * @type {Array<CustomEventEvent>}
     * @memberof CreateCustomEventRequest
     */
    'events': Array<CustomEventEvent>;
}
/**
 * Custom Event is an alias to an expression which is used while querying. You can use regular or custom events in expression. You can combine events in expression, you can use filter by properties.
 * @export
 * @interface CustomEvent
 */
export interface CustomEvent {
    /**
     *
     * @type {number}
     * @memberof CustomEvent
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof CustomEvent
     */
    'createdAt': string;
    /**
     *
     * @type {string}
     * @memberof CustomEvent
     */
    'updatedAt'?: string;
    /**
     *
     * @type {number}
     * @memberof CustomEvent
     */
    'createdBy': number;
    /**
     *
     * @type {number}
     * @memberof CustomEvent
     */
    'updatedBy'?: number;
    /**
     *
     * @type {number}
     * @memberof CustomEvent
     */
    'projectId': number;
    /**
     *
     * @type {boolean}
     * @memberof CustomEvent
     */
    'isSystem': boolean;
    /**
     *
     * @type {string}
     * @memberof CustomEvent
     */
    'status': CustomEventStatusEnum;
    /**
     *
     * @type {string}
     * @memberof CustomEvent
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof CustomEvent
     */
    'description'?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof CustomEvent
     */
    'tags'?: Array<string>;
    /**
     *
     * @type {Array<CustomEventEvent>}
     * @memberof CustomEvent
     */
    'events'?: Array<CustomEventEvent>;
    /**
     * array of id of properties contained in expression events
     * @type {Array<number>}
     * @memberof CustomEvent
     */
    'properties'?: Array<number>;
    /**
     * array of id of custom properties contained in expression events
     * @type {Array<number>}
     * @memberof CustomEvent
     */
    'custom_properties'?: Array<number>;
}

export const CustomEventStatusEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type CustomEventStatusEnum = typeof CustomEventStatusEnum[keyof typeof CustomEventStatusEnum];

/**
 * custom event will matches all of the provided events
 * @export
 * @interface CustomEventEvent
 */
export interface CustomEventEvent {
    /**
     *
     * @type {string}
     * @memberof CustomEventEvent
     */
    'eventName'?: string;
    /**
     *
     * @type {string}
     * @memberof CustomEventEvent
     */
    'eventType': CustomEventEventEventTypeEnum;
    /**
     *
     * @type {number}
     * @memberof CustomEventEvent
     */
    'eventId'?: number;
    /**
     * array of event filters
     * @type {Array<EventFilterByProperty>}
     * @memberof CustomEventEvent
     */
    'filters': Array<EventFilterByProperty>;
}

export const CustomEventEventEventTypeEnum = {
    Custom: 'custom'
} as const;

export type CustomEventEventEventTypeEnum = typeof CustomEventEventEventTypeEnum[keyof typeof CustomEventEventEventTypeEnum];

/**
 *
 * @export
 * @interface CustomEventEventAllOf
 */
export interface CustomEventEventAllOf {
    /**
     * array of event filters
     * @type {Array<EventFilterByProperty>}
     * @memberof CustomEventEventAllOf
     */
    'filters'?: Array<EventFilterByProperty>;
}
/**
 *
 * @export
 * @interface CustomProperty
 */
export interface CustomProperty {
    /**
     *
     * @type {number}
     * @memberof CustomProperty
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof CustomProperty
     */
    'createdAt'?: string;
    /**
     *
     * @type {string}
     * @memberof CustomProperty
     */
    'updatedAt'?: string;
    /**
     *
     * @type {number}
     * @memberof CustomProperty
     */
    'createdBy'?: number;
    /**
     *
     * @type {number}
     * @memberof CustomProperty
     */
    'updatedBy'?: number;
    /**
     *
     * @type {number}
     * @memberof CustomProperty
     */
    'projectId'?: number;
    /**
     *
     * @type {Array<number>}
     * @memberof CustomProperty
     */
    'events'?: Array<number>;
    /**
     *
     * @type {boolean}
     * @memberof CustomProperty
     */
    'isSystem'?: boolean;
    /**
     *
     * @type {string}
     * @memberof CustomProperty
     */
    'status'?: CustomPropertyStatusEnum;
    /**
     *
     * @type {string}
     * @memberof CustomProperty
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof CustomProperty
     */
    'description'?: string;
    /**
     *
     * @type {DataType}
     * @memberof CustomProperty
     */
    'type'?: DataType;
    /**
     *
     * @type {boolean}
     * @memberof CustomProperty
     */
    'nullable'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof CustomProperty
     */
    'isArray'?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof CustomProperty
     */
    'tags'?: Array<string>;
}

export const CustomPropertyStatusEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type CustomPropertyStatusEnum = typeof CustomPropertyStatusEnum[keyof typeof CustomPropertyStatusEnum];

/**
 * data type
 * @export
 * @enum {string}
 */

export const DataType = {
    String: 'string',
    Number: 'number',
    Boolean: 'boolean'
} as const;

export type DataType = typeof DataType[keyof typeof DataType];


/**
 * aggregate property and compare to value
 * @export
 * @interface DidEventAggregateProperty
 */
export interface DidEventAggregateProperty {
    /**
     *
     * @type {string}
     * @memberof DidEventAggregateProperty
     */
    'type': DidEventAggregatePropertyTypeEnum;
    /**
     *
     * @type {string}
     * @memberof DidEventAggregateProperty
     */
    'propertyName'?: string;
    /**
     *
     * @type {string}
     * @memberof DidEventAggregateProperty
     */
    'propertyType': DidEventAggregatePropertyPropertyTypeEnum;
    /**
     *
     * @type {number}
     * @memberof DidEventAggregateProperty
     */
    'propertyId'?: number;
    /**
     *
     * @type {QueryAggregateProperty}
     * @memberof DidEventAggregateProperty
     */
    'aggregate': QueryAggregateProperty;
    /**
     *
     * @type {PropertyFilterOperation}
     * @memberof DidEventAggregateProperty
     */
    'operation': PropertyFilterOperation;
    /**
     * one or more values. Doesn\'t need if operation is \"empty\" or \"exist\"
     * @type {number}
     * @memberof DidEventAggregateProperty
     */
    'value'?: number;
    /**
     * time frame
     * @type {TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach}
     * @memberof DidEventAggregateProperty
     */
    'time': TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach;
}

export const DidEventAggregatePropertyTypeEnum = {
    AggregateProperty: 'aggregateProperty'
} as const;

export type DidEventAggregatePropertyTypeEnum = typeof DidEventAggregatePropertyTypeEnum[keyof typeof DidEventAggregatePropertyTypeEnum];
export const DidEventAggregatePropertyPropertyTypeEnum = {
    Custom: 'custom'
} as const;

export type DidEventAggregatePropertyPropertyTypeEnum = typeof DidEventAggregatePropertyPropertyTypeEnum[keyof typeof DidEventAggregatePropertyPropertyTypeEnum];

/**
 *
 * @export
 * @interface DidEventAggregatePropertyAllOf
 */
export interface DidEventAggregatePropertyAllOf {
    /**
     *
     * @type {string}
     * @memberof DidEventAggregatePropertyAllOf
     */
    'type'?: DidEventAggregatePropertyAllOfTypeEnum;
}

export const DidEventAggregatePropertyAllOfTypeEnum = {
    AggregateProperty: 'aggregateProperty'
} as const;

export type DidEventAggregatePropertyAllOfTypeEnum = typeof DidEventAggregatePropertyAllOfTypeEnum[keyof typeof DidEventAggregatePropertyAllOfTypeEnum];

/**
 *
 * @export
 * @interface DidEventAggregatePropertyAllOf1
 */
export interface DidEventAggregatePropertyAllOf1 {
    /**
     *
     * @type {QueryAggregateProperty}
     * @memberof DidEventAggregatePropertyAllOf1
     */
    'aggregate'?: QueryAggregateProperty;
    /**
     *
     * @type {PropertyFilterOperation}
     * @memberof DidEventAggregatePropertyAllOf1
     */
    'operation'?: PropertyFilterOperation;
    /**
     * one or more values. Doesn\'t need if operation is \"empty\" or \"exist\"
     * @type {number}
     * @memberof DidEventAggregatePropertyAllOf1
     */
    'value'?: number;
    /**
     * time frame
     * @type {TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach}
     * @memberof DidEventAggregatePropertyAllOf1
     */
    'time'?: TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach;
}
/**
 * find all users who made event X times
 * @export
 * @interface DidEventCount
 */
export interface DidEventCount {
    /**
     *
     * @type {string}
     * @memberof DidEventCount
     */
    'type': DidEventCountTypeEnum;
    /**
     *
     * @type {PropertyFilterOperation}
     * @memberof DidEventCount
     */
    'operation': PropertyFilterOperation;
    /**
     * one or more values. Doesn\'t need if operation is \"empty\" or \"exist\"
     * @type {number}
     * @memberof DidEventCount
     */
    'value'?: number;
    /**
     * time frame
     * @type {TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach}
     * @memberof DidEventCount
     */
    'time': TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach;
}

export const DidEventCountTypeEnum = {
    DidEventCount: 'didEventCount'
} as const;

export type DidEventCountTypeEnum = typeof DidEventCountTypeEnum[keyof typeof DidEventCountTypeEnum];

/**
 * find users with Nth event occurance
 * @export
 * @interface DidEventHistoricalCount
 */
export interface DidEventHistoricalCount {
    /**
     *
     * @type {string}
     * @memberof DidEventHistoricalCount
     */
    'type': DidEventHistoricalCountTypeEnum;
    /**
     *
     * @type {PropertyFilterOperation}
     * @memberof DidEventHistoricalCount
     */
    'operation': PropertyFilterOperation;
    /**
     *
     * @type {number}
     * @memberof DidEventHistoricalCount
     */
    'value'?: number;
    /**
     *
     * @type {TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach}
     * @memberof DidEventHistoricalCount
     */
    'time': TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach;
}

export const DidEventHistoricalCountTypeEnum = {
    HistoricalCount: 'historicalCount'
} as const;

export type DidEventHistoricalCountTypeEnum = typeof DidEventHistoricalCountTypeEnum[keyof typeof DidEventHistoricalCountTypeEnum];

/**
 * find all users who made left event X time more/less than right event.
 * @export
 * @interface DidEventRelativeCount
 */
export interface DidEventRelativeCount {
    /**
     *
     * @type {string}
     * @memberof DidEventRelativeCount
     */
    'type': DidEventRelativeCountTypeEnum;
    /**
     *
     * @type {PropertyFilterOperation}
     * @memberof DidEventRelativeCount
     */
    'operation': PropertyFilterOperation;
    /**
     *
     * @type {EventRef}
     * @memberof DidEventRelativeCount
     */
    'rightEvent': EventRef;
    /**
     *
     * @type {TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach}
     * @memberof DidEventRelativeCount
     */
    'time': TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach;
}

export const DidEventRelativeCountTypeEnum = {
    DidEventRelativeCount: 'didEventRelativeCount'
} as const;

export type DidEventRelativeCountTypeEnum = typeof DidEventRelativeCountTypeEnum[keyof typeof DidEventRelativeCountTypeEnum];

/**
 * Event describes user event. User event is an action which user (client) might do on a product site/app. For instance, user might do a signup and it might be a \"Sign up\" event. Event Also has a properties. <br/><br/> Name must be unique among project events, including custom ones. E.g. you can\'t have multiple \"Sign up\" events. <br/><br/> Normally events are created and updated by admin in a project scope, but there are also system events, which can\'t be deleted or modified.
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * event unique id
     * @type {number}
     * @memberof Event
     */
    'id': number;
    /**
     * create date
     * @type {string}
     * @memberof Event
     */
    'createdAt': string;
    /**
     * update (once updated)
     * @type {string}
     * @memberof Event
     */
    'updatedAt'?: string;
    /**
     * id of creator User
     * @type {number}
     * @memberof Event
     */
    'createdBy': number;
    /**
     * id of updater User
     * @type {number}
     * @memberof Event
     */
    'updatedBy'?: number;
    /**
     * project id
     * @type {number}
     * @memberof Event
     */
    'projectId': number;
    /**
     * the event is a system-wide, shown in any project and can\'t be modified by a regular user
     * @type {boolean}
     * @memberof Event
     */
    'isSystyem'?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof Event
     */
    'tags'?: Array<string>;
    /**
     * event name. Must be unique among all project events (including custom). The name field is used while events ingesting.
     * @type {string}
     * @memberof Event
     */
    'name': string;
    /**
     * event name to display. If empty then name property is used.
     * @type {string}
     * @memberof Event
     */
    'displayName'?: string;
    /**
     * description
     * @type {string}
     * @memberof Event
     */
    'description'?: string;
    /**
     * event status
     * @type {string}
     * @memberof Event
     */
    'status': EventStatusEnum;
    /**
     * array of id of attached to event properties
     * @type {Array<number>}
     * @memberof Event
     */
    'properties'?: Array<number>;
    /**
     * array of id of attached to event custom properties
     * @type {Array<number>}
     * @memberof Event
     */
    'custom_properties'?: Array<number>;
}

export const EventStatusEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type EventStatusEnum = typeof EventStatusEnum[keyof typeof EventStatusEnum];

/**
 * event filter
 * @export
 * @interface EventFilter
 */
export interface EventFilter {
    /**
     *
     * @type {string}
     * @memberof EventFilter
     */
    'type'?: EventFilterTypeEnum;
    /**
     *
     * @type {number}
     * @memberof EventFilter
     */
    'cohortId'?: number;
    /**
     *
     * @type {string}
     * @memberof EventFilter
     */
    'propertyName'?: string;
    /**
     *
     * @type {string}
     * @memberof EventFilter
     */
    'propertyType': EventFilterPropertyTypeEnum;
    /**
     *
     * @type {number}
     * @memberof EventFilter
     */
    'propertyId'?: number;
    /**
     *
     * @type {PropertyFilterOperation}
     * @memberof EventFilter
     */
    'operation': PropertyFilterOperation;
    /**
     * one or several property values. May be not set if operation is \"empty\" or \"exist\"
     * @type {Array<Value>}
     * @memberof EventFilter
     */
    'value'?: Array<Value>;
}

export const EventFilterTypeEnum = {
    Property: 'property'
} as const;

export type EventFilterTypeEnum = typeof EventFilterTypeEnum[keyof typeof EventFilterTypeEnum];
export const EventFilterPropertyTypeEnum = {
    Custom: 'custom'
} as const;

export type EventFilterPropertyTypeEnum = typeof EventFilterPropertyTypeEnum[keyof typeof EventFilterPropertyTypeEnum];

/**
 *
 * @export
 * @interface EventFilterByCohort
 */
export interface EventFilterByCohort {
    /**
     *
     * @type {string}
     * @memberof EventFilterByCohort
     */
    'type'?: EventFilterByCohortTypeEnum;
    /**
     *
     * @type {number}
     * @memberof EventFilterByCohort
     */
    'cohortId'?: number;
}

export const EventFilterByCohortTypeEnum = {
    Cohort: 'cohort'
} as const;

export type EventFilterByCohortTypeEnum = typeof EventFilterByCohortTypeEnum[keyof typeof EventFilterByCohortTypeEnum];

/**
 * filter by property. Use this in event filters or in common filters. If you use it in event then event will be inherited, if you use filter as a common, then property should be commnon for all events.
 * @export
 * @interface EventFilterByProperty
 */
export interface EventFilterByProperty {
    /**
     *
     * @type {string}
     * @memberof EventFilterByProperty
     */
    'type'?: EventFilterByPropertyTypeEnum;
    /**
     *
     * @type {string}
     * @memberof EventFilterByProperty
     */
    'propertyName'?: string;
    /**
     *
     * @type {string}
     * @memberof EventFilterByProperty
     */
    'propertyType': EventFilterByPropertyPropertyTypeEnum;
    /**
     *
     * @type {number}
     * @memberof EventFilterByProperty
     */
    'propertyId'?: number;
    /**
     *
     * @type {PropertyFilterOperation}
     * @memberof EventFilterByProperty
     */
    'operation': PropertyFilterOperation;
    /**
     * one or several property values. May be not set if operation is \"empty\" or \"exist\"
     * @type {Array<Value>}
     * @memberof EventFilterByProperty
     */
    'value'?: Array<Value>;
}

export const EventFilterByPropertyTypeEnum = {
    Property: 'property'
} as const;

export type EventFilterByPropertyTypeEnum = typeof EventFilterByPropertyTypeEnum[keyof typeof EventFilterByPropertyTypeEnum];
export const EventFilterByPropertyPropertyTypeEnum = {
    Custom: 'custom'
} as const;

export type EventFilterByPropertyPropertyTypeEnum = typeof EventFilterByPropertyPropertyTypeEnum[keyof typeof EventFilterByPropertyPropertyTypeEnum];

/**
 *
 * @export
 * @interface EventFilterByPropertyAllOf
 */
export interface EventFilterByPropertyAllOf {
    /**
     *
     * @type {string}
     * @memberof EventFilterByPropertyAllOf
     */
    'type'?: EventFilterByPropertyAllOfTypeEnum;
}

export const EventFilterByPropertyAllOfTypeEnum = {
    Property: 'property'
} as const;

export type EventFilterByPropertyAllOfTypeEnum = typeof EventFilterByPropertyAllOfTypeEnum[keyof typeof EventFilterByPropertyAllOfTypeEnum];

/**
 *
 * @export
 * @interface EventFilterByPropertyAllOf1
 */
export interface EventFilterByPropertyAllOf1 {
    /**
     *
     * @type {PropertyFilterOperation}
     * @memberof EventFilterByPropertyAllOf1
     */
    'operation'?: PropertyFilterOperation;
    /**
     * one or several property values. May be not set if operation is \"empty\" or \"exist\"
     * @type {Array<Value>}
     * @memberof EventFilterByPropertyAllOf1
     */
    'value'?: Array<Value>;
}
/**
 * request events sorted by time of creation
 * @export
 * @interface EventListRequest
 */
export interface EventListRequest {
    /**
     * select time
     * @type {TimeBetween | TimeFrom | TimeLast}
     * @memberof EventListRequest
     */
    'time': TimeBetween | TimeFrom | TimeLast;
    /**
     *
     * @type {EventListRequestSearch}
     * @memberof EventListRequest
     */
    'search'?: EventListRequestSearch;
    /**
     * array of events to query
     * @type {Array<EventRef & object>}
     * @memberof EventListRequest
     */
    'events': Array<EventRef & object>;
    /**
     * array of common filters (which applies to all events)
     * @type {Array<EventFilterByProperty | EventFilterByCohort>}
     * @memberof EventListRequest
     */
    'filters'?: Array<EventFilterByProperty | EventFilterByCohort>;
}
/**
 * search in results
 * @export
 * @interface EventListRequestSearch
 */
export interface EventListRequestSearch {
    /**
     *
     * @type {string}
     * @memberof EventListRequestSearch
     */
    'term'?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof EventListRequestSearch
     */
    'eventProperties'?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof EventListRequestSearch
     */
    'userProperties'?: Array<string>;
}
/**
 * event query
 * @export
 * @interface EventQuery
 */
export interface EventQuery {
    /**
     *
     * @type {string}
     * @memberof EventQuery
     */
    'name'?: string;
    /**
     *
     * @type {QuerySimple | QueryCountPerGroup | QueryAggregatePropertyPerGroup | QueryAggregateProperty | QueryFormula}
     * @memberof EventQuery
     */
    'query': QuerySimple | QueryCountPerGroup | QueryAggregatePropertyPerGroup | QueryAggregateProperty | QueryFormula;
}
/**
 *
 * @export
 * @interface EventRecord
 */
export interface EventRecord {
    /**
     *
     * @type {string}
     * @memberof EventRecord
     */
    'name'?: string;
    /**
     * map of property name and property value pairs
     * @type {object}
     * @memberof EventRecord
     */
    'properties'?: object;
}
/**
 * @type EventRef
 * reference to event by its name and type
 * @export
 */
export type EventRef = EventRefOneOf | EventRefOneOf1;

/**
 *
 * @export
 * @interface EventRefOneOf
 */
export interface EventRefOneOf {
    /**
     *
     * @type {string}
     * @memberof EventRefOneOf
     */
    'eventName'?: string;
    /**
     *
     * @type {string}
     * @memberof EventRefOneOf
     */
    'eventType'?: EventRefOneOfEventTypeEnum;
}

export const EventRefOneOfEventTypeEnum = {
    Regular: 'regular'
} as const;

export type EventRefOneOfEventTypeEnum = typeof EventRefOneOfEventTypeEnum[keyof typeof EventRefOneOfEventTypeEnum];

/**
 *
 * @export
 * @interface EventRefOneOf1
 */
export interface EventRefOneOf1 {
    /**
     *
     * @type {number}
     * @memberof EventRefOneOf1
     */
    'eventId'?: number;
    /**
     *
     * @type {string}
     * @memberof EventRefOneOf1
     */
    'eventType'?: EventRefOneOf1EventTypeEnum;
}

export const EventRefOneOf1EventTypeEnum = {
    Custom: 'custom'
} as const;

export type EventRefOneOf1EventTypeEnum = typeof EventRefOneOf1EventTypeEnum[keyof typeof EventRefOneOf1EventTypeEnum];

/**
 * event segmentation report type main payload
 * @export
 * @interface EventSegmentation
 */
export interface EventSegmentation {
    /**
     * select time
     * @type {TimeBetween | TimeFrom | TimeLast}
     * @memberof EventSegmentation
     */
    'time': TimeBetween | TimeFrom | TimeLast;
    /**
     * group that is used in aggregations by group. For instance, group by user or group by organizartion.
     * @type {string}
     * @memberof EventSegmentation
     */
    'group': string;
    /**
     *
     * @type {TimeUnit}
     * @memberof EventSegmentation
     */
    'intervalUnit': TimeUnit;
    /**
     *
     * @type {ChartType}
     * @memberof EventSegmentation
     */
    'chartType': ChartType;
    /**
     * analysis type
     * @type {AnalysisLinear | AnalysisRollingAverage | AnalysisRollingWindow | AnalysisCumulative}
     * @memberof EventSegmentation
     */
    'analysis': AnalysisLinear | AnalysisRollingAverage | AnalysisRollingWindow | AnalysisCumulative;
    /**
     *
     * @type {EventSegmentationCompare}
     * @memberof EventSegmentation
     */
    'compare'?: EventSegmentationCompare;
    /**
     * array of events to query
     * @type {Array<EventSegmentationEvent>}
     * @memberof EventSegmentation
     */
    'events': Array<EventSegmentationEvent>;
    /**
     * array of common filters (which applies to all events)
     * @type {Array<EventFilterByProperty | EventFilterByCohort>}
     * @memberof EventSegmentation
     */
    'filters'?: Array<EventFilterByProperty | EventFilterByCohort>;
    /**
     * array of common breakdowns (which applies to all events)
     * @type {Array<BreakdownByProperty>}
     * @memberof EventSegmentation
     */
    'breakdowns'?: Array<BreakdownByProperty>;
    /**
     * array of segments
     * @type {Array<EventSegmentationSegment>}
     * @memberof EventSegmentation
     */
    'segments'?: Array<EventSegmentationSegment>;
}
/**
 * optional comparison with previous period
 * @export
 * @interface EventSegmentationCompare
 */
export interface EventSegmentationCompare {
    /**
     * offset in past in timeUnit
     * @type {number}
     * @memberof EventSegmentationCompare
     */
    'offset': number;
    /**
     *
     * @type {TimeUnit}
     * @memberof EventSegmentationCompare
     */
    'unit': TimeUnit;
}
/**
 * event object
 * @export
 * @interface EventSegmentationEvent
 */
export interface EventSegmentationEvent {
    /**
     *
     * @type {string}
     * @memberof EventSegmentationEvent
     */
    'eventName'?: string;
    /**
     *
     * @type {string}
     * @memberof EventSegmentationEvent
     */
    'eventType': EventSegmentationEventEventTypeEnum;
    /**
     *
     * @type {number}
     * @memberof EventSegmentationEvent
     */
    'eventId'?: number;
    /**
     * array of event filters
     * @type {Array<EventFilterByProperty>}
     * @memberof EventSegmentationEvent
     */
    'filters'?: Array<EventFilterByProperty>;
    /**
     *
     * @type {Array<BreakdownByProperty>}
     * @memberof EventSegmentationEvent
     */
    'breakdowns'?: Array<BreakdownByProperty>;
    /**
     * array of event queries
     * @type {Array<EventQuery>}
     * @memberof EventSegmentationEvent
     */
    'queries': Array<EventQuery>;
}

export const EventSegmentationEventEventTypeEnum = {
    Custom: 'custom'
} as const;

export type EventSegmentationEventEventTypeEnum = typeof EventSegmentationEventEventTypeEnum[keyof typeof EventSegmentationEventEventTypeEnum];

/**
 *
 * @export
 * @interface EventSegmentationEventAllOf
 */
export interface EventSegmentationEventAllOf {
    /**
     * array of event filters
     * @type {Array<EventFilterByProperty>}
     * @memberof EventSegmentationEventAllOf
     */
    'filters'?: Array<EventFilterByProperty>;
    /**
     *
     * @type {Array<BreakdownByProperty>}
     * @memberof EventSegmentationEventAllOf
     */
    'breakdowns'?: Array<BreakdownByProperty>;
    /**
     * array of event queries
     * @type {Array<EventQuery>}
     * @memberof EventSegmentationEventAllOf
     */
    'queries'?: Array<EventQuery>;
}
/**
 * segment
 * @export
 * @interface EventSegmentationSegment
 */
export interface EventSegmentationSegment {
    /**
     * name of segment
     * @type {string}
     * @memberof EventSegmentationSegment
     */
    'name'?: string;
    /**
     * array of conditions
     * @type {Array<SegmentCondition>}
     * @memberof EventSegmentationSegment
     */
    'conditions': Array<SegmentCondition>;
}
/**
 * possible event type
 * @export
 * @enum {string}
 */

export const EventType = {
    Regular: 'regular',
    Custom: 'custom'
} as const;

export type EventType = typeof EventType[keyof typeof EventType];


/**
 *
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * use event name only with eventType=event|user
     * @type {string}
     * @memberof InlineObject
     */
    'eventName'?: string;
    /**
     * use event id only with eventType=custom
     * @type {number}
     * @memberof InlineObject
     */
    'eventId'?: number;
    /**
     *
     * @type {string}
     * @memberof InlineObject
     */
    'eventType'?: InlineObjectEventTypeEnum;
    /**
     * use property name only with propertyType=event|user
     * @type {string}
     * @memberof InlineObject
     */
    'propertyName'?: string;
    /**
     * use property id only with propertyType=custom
     * @type {number}
     * @memberof InlineObject
     */
    'propertyId'?: number;
    /**
     *
     * @type {string}
     * @memberof InlineObject
     */
    'propertyType'?: InlineObjectPropertyTypeEnum;
}

export const InlineObjectEventTypeEnum = {
    Event: 'event',
    User: 'user',
    Custom: 'custom'
} as const;

export type InlineObjectEventTypeEnum = typeof InlineObjectEventTypeEnum[keyof typeof InlineObjectEventTypeEnum];
export const InlineObjectPropertyTypeEnum = {
    Event: 'event',
    User: 'user',
    Custom: 'custom'
} as const;

export type InlineObjectPropertyTypeEnum = typeof InlineObjectPropertyTypeEnum[keyof typeof InlineObjectPropertyTypeEnum];

/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     *
     * @type {Array<string> | Array<number> | Array<boolean>}
     * @memberof InlineResponse200
     */
    'values'?: Array<string> | Array<number> | Array<boolean>;
}
/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse2001
     */
    'dimensionHeaders'?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse2001
     */
    'metricHeaders'?: Array<string>;
    /**
     *
     * @type {Array<Array<string>>}
     * @memberof InlineResponse2001
     */
    'dimensions'?: Array<Array<string>>;
    /**
     *
     * @type {Array<number>}
     * @memberof InlineResponse2001
     */
    'singles'?: Array<number>;
    /**
     *
     * @type {Array<Array<number>>}
     * @memberof InlineResponse2001
     */
    'series'?: Array<Array<number>>;
    /**
     *
     * @type {InlineResponse2001Compare}
     * @memberof InlineResponse2001
     */
    'compare'?: InlineResponse2001Compare;
}
/**
 *
 * @export
 * @interface InlineResponse2001Compare
 */
export interface InlineResponse2001Compare {
    /**
     *
     * @type {Array<Array<string>>}
     * @memberof InlineResponse2001Compare
     */
    'dimensions'?: Array<Array<string>>;
    /**
     *
     * @type {Array<number>}
     * @memberof InlineResponse2001Compare
     */
    'singles'?: Array<number>;
    /**
     *
     * @type {Array<Array<number>>}
     * @memberof InlineResponse2001Compare
     */
    'series'?: Array<Array<number>>;
}
/**
 * list response metadata
 * @export
 * @interface ListResponseMetadata
 */
export interface ListResponseMetadata {
    /**
     *
     * @type {ListResponseMetadataMeta}
     * @memberof ListResponseMetadata
     */
    'meta'?: ListResponseMetadataMeta;
}
/**
 *
 * @export
 * @interface ListResponseMetadataMeta
 */
export interface ListResponseMetadataMeta {
    /**
     *
     * @type {string}
     * @memberof ListResponseMetadataMeta
     */
    'next'?: string;
    /**
     *
     * @type {string}
     * @memberof ListResponseMetadataMeta
     */
    'prev'?: string;
    /**
     *
     * @type {number}
     * @memberof ListResponseMetadataMeta
     */
    'total'?: number;
}
/**
 *
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     *
     * @type {Array<number>}
     * @memberof Organization
     */
    'teams'?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof Organization
     */
    'users'?: Array<number>;
}
/**
 *
 * @export
 * @interface Project
 */
export interface Project {
    /**
     *
     * @type {number}
     * @memberof Project
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof Project
     */
    'createdAt'?: string;
    /**
     *
     * @type {string}
     * @memberof Project
     */
    'updatedAt'?: string;
    /**
     *
     * @type {number}
     * @memberof Project
     */
    'createdBy'?: number;
    /**
     *
     * @type {number}
     * @memberof Project
     */
    'updatedBy'?: number;
    /**
     *
     * @type {string}
     * @memberof Project
     */
    'name'?: string;
    /**
     *
     * @type {number}
     * @memberof Project
     */
    'sessionTimeoutSeconds'?: number;
    /**
     *
     * @type {Array<number>}
     * @memberof Project
     */
    'teams'?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof Project
     */
    'users'?: Array<number>;
}
/**
 * property defines event or user property. For example, event \"Buy product\" may contains next properties like \"Product name\" and \"Price.\"
 * @export
 * @interface Property
 */
export interface Property {
    /**
     * property unique id
     * @type {number}
     * @memberof Property
     */
    'id': number;
    /**
     * create date
     * @type {string}
     * @memberof Property
     */
    'createdAt': string;
    /**
     * update (once updated)
     * @type {string}
     * @memberof Property
     */
    'updatedAt'?: string;
    /**
     * id of creator User
     * @type {number}
     * @memberof Property
     */
    'createdBy': number;
    /**
     * id of updater User
     * @type {number}
     * @memberof Property
     */
    'updatedBy'?: number;
    /**
     * project id
     * @type {number}
     * @memberof Property
     */
    'projectId': number;
    /**
     * list of id of events which use this property
     * @type {Array<number>}
     * @memberof Property
     */
    'events'?: Array<number>;
    /**
     *
     * @type {string}
     * @memberof Property
     */
    'type'?: PropertyTypeEnum;
    /**
     * the property is a system-wide, shown in any project and can\'t be modified by a regular user
     * @type {boolean}
     * @memberof Property
     */
    'isSystem': boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof Property
     */
    'tags'?: Array<string>;
    /**
     * property name. Must be unique
     * @type {string}
     * @memberof Property
     */
    'name': string;
    /**
     * property name to display. If empty then name is used.
     * @type {string}
     * @memberof Property
     */
    'displayName'?: string;
    /**
     * description
     * @type {string}
     * @memberof Property
     */
    'description'?: string;
    /**
     * property status
     * @type {string}
     * @memberof Property
     */
    'status': PropertyStatusEnum;
    /**
     *
     * @type {object & DataType}
     * @memberof Property
     */
    'dataType'?: object & DataType;
    /**
     * nullable property might contains null value
     * @type {boolean}
     * @memberof Property
     */
    'nullable': boolean;
    /**
     * array property might contents multiple values
     * @type {boolean}
     * @memberof Property
     */
    'isArray': boolean;
    /**
     * dictionary can efficiently packs strings provided that cardinality will be relatively log (16bits is a reasonable maximum)
     * @type {boolean}
     * @memberof Property
     */
    'isDictionary': boolean;
    /**
     *
     * @type {object & DataType}
     * @memberof Property
     */
    'dictionaryType'?: object & DataType;
}

export const PropertyTypeEnum = {
    Event: 'event',
    User: 'user'
} as const;

export type PropertyTypeEnum = typeof PropertyTypeEnum[keyof typeof PropertyTypeEnum];
export const PropertyStatusEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type PropertyStatusEnum = typeof PropertyStatusEnum[keyof typeof PropertyStatusEnum];

/**
 * operation
 * @export
 * @enum {string}
 */

export const PropertyFilterOperation = {
    Eq: 'eq',
    Neq: 'neq',
    Gt: 'gt',
    Gte: 'gte',
    Lt: 'lt',
    Lte: 'lte',
    True: 'true',
    False: 'false',
    Exists: 'exists',
    Empty: 'empty',
    ArrAll: 'arr_all',
    ArrAny: 'arr_any',
    ArrNone: 'arr_none',
    Regex: 'regex'
} as const;

export type PropertyFilterOperation = typeof PropertyFilterOperation[keyof typeof PropertyFilterOperation];


/**
 * @type PropertyRef
 * reference to a property by id or name, depends on property type
 * @export
 */
export type PropertyRef = PropertyRefOneOf | PropertyRefOneOf1;

/**
 *
 * @export
 * @interface PropertyRefOneOf
 */
export interface PropertyRefOneOf {
    /**
     *
     * @type {string}
     * @memberof PropertyRefOneOf
     */
    'propertyName'?: string;
    /**
     *
     * @type {string}
     * @memberof PropertyRefOneOf
     */
    'propertyType'?: PropertyRefOneOfPropertyTypeEnum;
}

export const PropertyRefOneOfPropertyTypeEnum = {
    Event: 'event',
    User: 'user'
} as const;

export type PropertyRefOneOfPropertyTypeEnum = typeof PropertyRefOneOfPropertyTypeEnum[keyof typeof PropertyRefOneOfPropertyTypeEnum];

/**
 *
 * @export
 * @interface PropertyRefOneOf1
 */
export interface PropertyRefOneOf1 {
    /**
     *
     * @type {number}
     * @memberof PropertyRefOneOf1
     */
    'propertyId'?: number;
    /**
     *
     * @type {string}
     * @memberof PropertyRefOneOf1
     */
    'propertyType'?: PropertyRefOneOf1PropertyTypeEnum;
}

export const PropertyRefOneOf1PropertyTypeEnum = {
    Custom: 'custom'
} as const;

export type PropertyRefOneOf1PropertyTypeEnum = typeof PropertyRefOneOf1PropertyTypeEnum[keyof typeof PropertyRefOneOf1PropertyTypeEnum];

/**
 * possible property type
 * @export
 * @enum {string}
 */

export const PropertyType = {
    Event: 'event',
    User: 'user',
    Custom: 'custom'
} as const;

export type PropertyType = typeof PropertyType[keyof typeof PropertyType];


/**
 *
 * @export
 * @enum {string}
 */

export const QueryAggregate = {
    Sum: 'sum',
    Avg: 'avg',
    Median: 'median',
    Min: 'min',
    Max: 'max',
    DistinctCount: 'distinctCount',
    _25thPercentile: '25thPercentile',
    _75thPercentile: '75thPercentile',
    _90thPercentile: '90thPercentile',
    _99thPercentile: '99thPercentile'
} as const;

export type QueryAggregate = typeof QueryAggregate[keyof typeof QueryAggregate];


/**
 * aggregate of property per by group
 * @export
 * @interface QueryAggregateProperty
 */
export interface QueryAggregateProperty {
    /**
     *
     * @type {string}
     * @memberof QueryAggregateProperty
     */
    'type': QueryAggregatePropertyTypeEnum;
    /**
     *
     * @type {string}
     * @memberof QueryAggregateProperty
     */
    'propertyName'?: string;
    /**
     *
     * @type {string}
     * @memberof QueryAggregateProperty
     */
    'propertyType': QueryAggregatePropertyPropertyTypeEnum;
    /**
     *
     * @type {number}
     * @memberof QueryAggregateProperty
     */
    'propertyId'?: number;
    /**
     *
     * @type {QueryAggregate}
     * @memberof QueryAggregateProperty
     */
    'aggregate': QueryAggregate;
}

export const QueryAggregatePropertyTypeEnum = {
    AggregateProperty: 'aggregateProperty'
} as const;

export type QueryAggregatePropertyTypeEnum = typeof QueryAggregatePropertyTypeEnum[keyof typeof QueryAggregatePropertyTypeEnum];
export const QueryAggregatePropertyPropertyTypeEnum = {
    Custom: 'custom'
} as const;

export type QueryAggregatePropertyPropertyTypeEnum = typeof QueryAggregatePropertyPropertyTypeEnum[keyof typeof QueryAggregatePropertyPropertyTypeEnum];

/**
 *
 * @export
 * @interface QueryAggregatePropertyAllOf
 */
export interface QueryAggregatePropertyAllOf {
    /**
     *
     * @type {QueryAggregate}
     * @memberof QueryAggregatePropertyAllOf
     */
    'aggregate'?: QueryAggregate;
}
/**
 * aggregate of property per by group
 * @export
 * @interface QueryAggregatePropertyPerGroup
 */
export interface QueryAggregatePropertyPerGroup {
    /**
     *
     * @type {string}
     * @memberof QueryAggregatePropertyPerGroup
     */
    'type': QueryAggregatePropertyPerGroupTypeEnum;
    /**
     *
     * @type {string}
     * @memberof QueryAggregatePropertyPerGroup
     */
    'propertyName'?: string;
    /**
     *
     * @type {string}
     * @memberof QueryAggregatePropertyPerGroup
     */
    'propertyType': QueryAggregatePropertyPerGroupPropertyTypeEnum;
    /**
     *
     * @type {number}
     * @memberof QueryAggregatePropertyPerGroup
     */
    'propertyId'?: number;
    /**
     *
     * @type {QueryAggregate}
     * @memberof QueryAggregatePropertyPerGroup
     */
    'aggregate': QueryAggregate;
    /**
     *
     * @type {QueryAggregate}
     * @memberof QueryAggregatePropertyPerGroup
     */
    'aggregatePerGroup': QueryAggregate;
}

export const QueryAggregatePropertyPerGroupTypeEnum = {
    AggregatePropertyPerGroup: 'aggregatePropertyPerGroup'
} as const;

export type QueryAggregatePropertyPerGroupTypeEnum = typeof QueryAggregatePropertyPerGroupTypeEnum[keyof typeof QueryAggregatePropertyPerGroupTypeEnum];
export const QueryAggregatePropertyPerGroupPropertyTypeEnum = {
    Custom: 'custom'
} as const;

export type QueryAggregatePropertyPerGroupPropertyTypeEnum = typeof QueryAggregatePropertyPerGroupPropertyTypeEnum[keyof typeof QueryAggregatePropertyPerGroupPropertyTypeEnum];

/**
 *
 * @export
 * @interface QueryAggregatePropertyPerGroupAllOf
 */
export interface QueryAggregatePropertyPerGroupAllOf {
    /**
     *
     * @type {string}
     * @memberof QueryAggregatePropertyPerGroupAllOf
     */
    'type'?: QueryAggregatePropertyPerGroupAllOfTypeEnum;
}

export const QueryAggregatePropertyPerGroupAllOfTypeEnum = {
    AggregatePropertyPerGroup: 'aggregatePropertyPerGroup'
} as const;

export type QueryAggregatePropertyPerGroupAllOfTypeEnum = typeof QueryAggregatePropertyPerGroupAllOfTypeEnum[keyof typeof QueryAggregatePropertyPerGroupAllOfTypeEnum];

/**
 *
 * @export
 * @interface QueryAggregatePropertyPerGroupAllOf1
 */
export interface QueryAggregatePropertyPerGroupAllOf1 {
    /**
     *
     * @type {QueryAggregate}
     * @memberof QueryAggregatePropertyPerGroupAllOf1
     */
    'aggregate'?: QueryAggregate;
    /**
     *
     * @type {QueryAggregate}
     * @memberof QueryAggregatePropertyPerGroupAllOf1
     */
    'aggregatePerGroup'?: QueryAggregate;
}
/**
 * event count aggregate by group
 * @export
 * @interface QueryCountPerGroup
 */
export interface QueryCountPerGroup {
    /**
     *
     * @type {string}
     * @memberof QueryCountPerGroup
     */
    'type': QueryCountPerGroupTypeEnum;
    /**
     *
     * @type {QueryAggregate}
     * @memberof QueryCountPerGroup
     */
    'aggregate': QueryAggregate;
}

export const QueryCountPerGroupTypeEnum = {
    CountPerGroup: 'countPerGroup'
} as const;

export type QueryCountPerGroupTypeEnum = typeof QueryCountPerGroupTypeEnum[keyof typeof QueryCountPerGroupTypeEnum];

/**
 * apply formula
 * @export
 * @interface QueryFormula
 */
export interface QueryFormula {
    /**
     *
     * @type {string}
     * @memberof QueryFormula
     */
    'type'?: QueryFormulaTypeEnum;
    /**
     *
     * @type {string}
     * @memberof QueryFormula
     */
    'formula'?: string;
}

export const QueryFormulaTypeEnum = {
    Formula: 'formula'
} as const;

export type QueryFormulaTypeEnum = typeof QueryFormulaTypeEnum[keyof typeof QueryFormulaTypeEnum];

/**
 * simple query without any additional agruments
 * @export
 * @interface QuerySimple
 */
export interface QuerySimple {
    /**
     *
     * @type {string}
     * @memberof QuerySimple
     */
    'type': QuerySimpleTypeEnum;
    /**
     *
     * @type {string}
     * @memberof QuerySimple
     */
    'query': QuerySimpleQueryEnum;
}

export const QuerySimpleTypeEnum = {
    Simple: 'simple'
} as const;

export type QuerySimpleTypeEnum = typeof QuerySimpleTypeEnum[keyof typeof QuerySimpleTypeEnum];
export const QuerySimpleQueryEnum = {
    CountEvents: 'countEvents',
    CountUniqueGroups: 'countUniqueGroups',
    WeeklyActiveGroups: 'weeklyActiveGroups',
    MonthlyActiveGroups: 'monthlyActiveGroups'
} as const;

export type QuerySimpleQueryEnum = typeof QuerySimpleQueryEnum[keyof typeof QuerySimpleQueryEnum];

/**
 * @type SegmentCondition
 * @export
 */
export type SegmentCondition = SegmentConditionDidEvent | SegmentConditionFunnel | SegmentConditionHadPropertyValue | SegmentConditionHasPropertyValue | object;

/**
 * did event condition
 * @export
 * @interface SegmentConditionDidEvent
 */
export interface SegmentConditionDidEvent {
    /**
     *
     * @type {string}
     * @memberof SegmentConditionDidEvent
     */
    'type'?: SegmentConditionDidEventTypeEnum;
    /**
     *
     * @type {string}
     * @memberof SegmentConditionDidEvent
     */
    'eventName'?: string;
    /**
     *
     * @type {string}
     * @memberof SegmentConditionDidEvent
     */
    'eventType'?: SegmentConditionDidEventEventTypeEnum;
    /**
     *
     * @type {number}
     * @memberof SegmentConditionDidEvent
     */
    'eventId'?: number;
    /**
     *
     * @type {Array<EventFilterByProperty>}
     * @memberof SegmentConditionDidEvent
     */
    'filters'?: Array<EventFilterByProperty>;
    /**
     *
     * @type {DidEventCount | DidEventRelativeCount | DidEventAggregateProperty | DidEventHistoricalCount}
     * @memberof SegmentConditionDidEvent
     */
    'aggregate'?: DidEventCount | DidEventRelativeCount | DidEventAggregateProperty | DidEventHistoricalCount;
}

export const SegmentConditionDidEventTypeEnum = {
    DidEvent: 'didEvent'
} as const;

export type SegmentConditionDidEventTypeEnum = typeof SegmentConditionDidEventTypeEnum[keyof typeof SegmentConditionDidEventTypeEnum];
export const SegmentConditionDidEventEventTypeEnum = {
    Custom: 'custom'
} as const;

export type SegmentConditionDidEventEventTypeEnum = typeof SegmentConditionDidEventEventTypeEnum[keyof typeof SegmentConditionDidEventEventTypeEnum];

/**
 *
 * @export
 * @interface SegmentConditionDidEventAllOf
 */
export interface SegmentConditionDidEventAllOf {
    /**
     *
     * @type {string}
     * @memberof SegmentConditionDidEventAllOf
     */
    'type'?: SegmentConditionDidEventAllOfTypeEnum;
}

export const SegmentConditionDidEventAllOfTypeEnum = {
    DidEvent: 'didEvent'
} as const;

export type SegmentConditionDidEventAllOfTypeEnum = typeof SegmentConditionDidEventAllOfTypeEnum[keyof typeof SegmentConditionDidEventAllOfTypeEnum];

/**
 *
 * @export
 * @interface SegmentConditionDidEventAllOf1
 */
export interface SegmentConditionDidEventAllOf1 {
    /**
     *
     * @type {Array<EventFilterByProperty>}
     * @memberof SegmentConditionDidEventAllOf1
     */
    'filters'?: Array<EventFilterByProperty>;
    /**
     *
     * @type {DidEventCount | DidEventRelativeCount | DidEventAggregateProperty | DidEventHistoricalCount}
     * @memberof SegmentConditionDidEventAllOf1
     */
    'aggregate'?: DidEventCount | DidEventRelativeCount | DidEventAggregateProperty | DidEventHistoricalCount;
}
/**
 *
 * @export
 * @interface SegmentConditionFunnel
 */
export interface SegmentConditionFunnel {
    /**
     *
     * @type {string}
     * @memberof SegmentConditionFunnel
     */
    'type'?: SegmentConditionFunnelTypeEnum;
    /**
     *
     * @type {number}
     * @memberof SegmentConditionFunnel
     */
    'last'?: number;
    /**
     *
     * @type {TimeUnit}
     * @memberof SegmentConditionFunnel
     */
    'bucket'?: TimeUnit;
}

export const SegmentConditionFunnelTypeEnum = {
    Funnel: 'funnel'
} as const;

export type SegmentConditionFunnelTypeEnum = typeof SegmentConditionFunnelTypeEnum[keyof typeof SegmentConditionFunnelTypeEnum];

/**
 * check whether the user had a property with a value
 * @export
 * @interface SegmentConditionHadPropertyValue
 */
export interface SegmentConditionHadPropertyValue {
    /**
     *
     * @type {string}
     * @memberof SegmentConditionHadPropertyValue
     */
    'type': SegmentConditionHadPropertyValueTypeEnum;
    /**
     * property name. Because property here is a user only, we don\'t need propertyType
     * @type {string}
     * @memberof SegmentConditionHadPropertyValue
     */
    'propertyName': string;
    /**
     *
     * @type {PropertyFilterOperation}
     * @memberof SegmentConditionHadPropertyValue
     */
    'operation': PropertyFilterOperation;
    /**
     * one or more values. Doesn\'t need if operation is \"empty\" or \"exist\"
     * @type {Array<Value>}
     * @memberof SegmentConditionHadPropertyValue
     */
    'values'?: Array<Value>;
    /**
     * time frame
     * @type {TimeBetween | TimeLast | TimeWindowEach}
     * @memberof SegmentConditionHadPropertyValue
     */
    'time': TimeBetween | TimeLast | TimeWindowEach;
}

export const SegmentConditionHadPropertyValueTypeEnum = {
    HadPropertyValue: 'hadPropertyValue'
} as const;

export type SegmentConditionHadPropertyValueTypeEnum = typeof SegmentConditionHadPropertyValueTypeEnum[keyof typeof SegmentConditionHadPropertyValueTypeEnum];

/**
 * check whether the user currently has a property with a value
 * @export
 * @interface SegmentConditionHasPropertyValue
 */
export interface SegmentConditionHasPropertyValue {
    /**
     *
     * @type {string}
     * @memberof SegmentConditionHasPropertyValue
     */
    'type': SegmentConditionHasPropertyValueTypeEnum;
    /**
     * property name. Because property here is a user only, we don\'t need propertyType
     * @type {string}
     * @memberof SegmentConditionHasPropertyValue
     */
    'propertyName': string;
    /**
     *
     * @type {PropertyFilterOperation}
     * @memberof SegmentConditionHasPropertyValue
     */
    'operation': PropertyFilterOperation;
    /**
     * one or more values. Doesn\'t need if operation is \"empty\" or \"exist\"
     * @type {Array<Value>}
     * @memberof SegmentConditionHasPropertyValue
     */
    'values'?: Array<Value>;
}

export const SegmentConditionHasPropertyValueTypeEnum = {
    HasPropertyValue: 'hasPropertyValue'
} as const;

export type SegmentConditionHasPropertyValueTypeEnum = typeof SegmentConditionHasPropertyValueTypeEnum[keyof typeof SegmentConditionHasPropertyValueTypeEnum];

/**
 * time spent after the first use of event. Use in segmentation
 * @export
 * @interface TimeAfterFirstUse
 */
export interface TimeAfterFirstUse {
    /**
     *
     * @type {string}
     * @memberof TimeAfterFirstUse
     */
    'type': TimeAfterFirstUseTypeEnum;
    /**
     *
     * @type {number}
     * @memberof TimeAfterFirstUse
     */
    'within': number;
    /**
     *
     * @type {TimeUnit}
     * @memberof TimeAfterFirstUse
     */
    'unit': TimeUnit;
}

export const TimeAfterFirstUseTypeEnum = {
    AfterFirstUse: 'afterFirstUse'
} as const;

export type TimeAfterFirstUseTypeEnum = typeof TimeAfterFirstUseTypeEnum[keyof typeof TimeAfterFirstUseTypeEnum];

/**
 * time range between fixed values
 * @export
 * @interface TimeBetween
 */
export interface TimeBetween {
    /**
     *
     * @type {string}
     * @memberof TimeBetween
     */
    'type': TimeBetweenTypeEnum;
    /**
     * start date
     * @type {string}
     * @memberof TimeBetween
     */
    'from': string;
    /**
     * end date
     * @type {string}
     * @memberof TimeBetween
     */
    'to': string;
}

export const TimeBetweenTypeEnum = {
    Between: 'between'
} as const;

export type TimeBetweenTypeEnum = typeof TimeBetweenTypeEnum[keyof typeof TimeBetweenTypeEnum];

/**
 * time range between fixed value and current time
 * @export
 * @interface TimeFrom
 */
export interface TimeFrom {
    /**
     *
     * @type {string}
     * @memberof TimeFrom
     */
    'type': TimeFromTypeEnum;
    /**
     * start date
     * @type {string}
     * @memberof TimeFrom
     */
    'from': string;
}

export const TimeFromTypeEnum = {
    From: 'from'
} as const;

export type TimeFromTypeEnum = typeof TimeFromTypeEnum[keyof typeof TimeFromTypeEnum];

/**
 * take last N days/weeks
 * @export
 * @interface TimeLast
 */
export interface TimeLast {
    /**
     *
     * @type {string}
     * @memberof TimeLast
     */
    'type': TimeLastTypeEnum;
    /**
     * N days/weeks
     * @type {number}
     * @memberof TimeLast
     */
    'n': number;
    /**
     *
     * @type {TimeUnit}
     * @memberof TimeLast
     */
    'unit': TimeUnit;
}

export const TimeLastTypeEnum = {
    Last: 'last'
} as const;

export type TimeLastTypeEnum = typeof TimeLastTypeEnum[keyof typeof TimeLastTypeEnum];

/**
 * time unit
 * @export
 * @enum {string}
 */

export const TimeUnit = {
    Second: 'second',
    Minute: 'minute',
    Hour: 'hour',
    Day: 'day',
    Week: 'week',
    Month: 'month',
    Year: 'year'
} as const;

export type TimeUnit = typeof TimeUnit[keyof typeof TimeUnit];


/**
 * window operation for segmentation. Tells that event should be triggered each timeunit (each day, for instance) {   \"time\": {     \"type\": \"each\",     \"unit\":\"day\"   } }
 * @export
 * @interface TimeWindowEach
 */
export interface TimeWindowEach {
    /**
     *
     * @type {string}
     * @memberof TimeWindowEach
     */
    'type': TimeWindowEachTypeEnum;
    /**
     *
     * @type {TimeUnit}
     * @memberof TimeWindowEach
     */
    'unit': TimeUnit;
}

export const TimeWindowEachTypeEnum = {
    WindowEach: 'windowEach'
} as const;

export type TimeWindowEachTypeEnum = typeof TimeWindowEachTypeEnum[keyof typeof TimeWindowEachTypeEnum];

/**
 * Custom Event is an alias to an expression which is used while querying. You can use regular or custom events in expression. You can combine events in expression, you can use filter by properties.
 * @export
 * @interface UpdateCustomEventRequest
 */
export interface UpdateCustomEventRequest {
    /**
     *
     * @type {string}
     * @memberof UpdateCustomEventRequest
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof UpdateCustomEventRequest
     */
    'description'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateCustomEventRequest
     */
    'status'?: UpdateCustomEventRequestStatusEnum;
    /**
     *
     * @type {Array<string>}
     * @memberof UpdateCustomEventRequest
     */
    'tags'?: Array<string>;
    /**
     *
     * @type {Array<CustomEventEvent>}
     * @memberof UpdateCustomEventRequest
     */
    'events': Array<CustomEventEvent>;
}

export const UpdateCustomEventRequestStatusEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type UpdateCustomEventRequestStatusEnum = typeof UpdateCustomEventRequestStatusEnum[keyof typeof UpdateCustomEventRequestStatusEnum];

/**
 * Update event request
 * @export
 * @interface UpdateEventRequest
 */
export interface UpdateEventRequest {
    /**
     * event name to display. If empty then name property is used.
     * @type {string}
     * @memberof UpdateEventRequest
     */
    'displayName'?: string;
    /**
     * description
     * @type {string}
     * @memberof UpdateEventRequest
     */
    'description'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateEventRequest
     */
    'status'?: UpdateEventRequestStatusEnum;
    /**
     *
     * @type {Array<string>}
     * @memberof UpdateEventRequest
     */
    'tags'?: Array<string>;
}

export const UpdateEventRequestStatusEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type UpdateEventRequestStatusEnum = typeof UpdateEventRequestStatusEnum[keyof typeof UpdateEventRequestStatusEnum];

/**
 * Propetty update
 * @export
 * @interface UpdatePropertyRequest
 */
export interface UpdatePropertyRequest {
    /**
     *
     * @type {string}
     * @memberof UpdatePropertyRequest
     */
    'displayName'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdatePropertyRequest
     */
    'description'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdatePropertyRequest
     */
    'status'?: UpdatePropertyRequestStatusEnum;
    /**
     *
     * @type {Array<string>}
     * @memberof UpdatePropertyRequest
     */
    'tags'?: Array<string>;
}

export const UpdatePropertyRequestStatusEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type UpdatePropertyRequestStatusEnum = typeof UpdatePropertyRequestStatusEnum[keyof typeof UpdatePropertyRequestStatusEnum];

/**
 *
 * @export
 * @interface User
 */
export interface User {
    /**
     *
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'createdAt'?: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'updatedAt'?: string;
    /**
     *
     * @type {number}
     * @memberof User
     */
    'createdBy'?: number;
    /**
     *
     * @type {number}
     * @memberof User
     */
    'updatedBy'?: number;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'firstName'?: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'lastName'?: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'role'?: string;
    /**
     *
     * @type {Array<number>}
     * @memberof User
     */
    'teams'?: Array<number>;
    /**
     *
     * @type {Array<UserProjects>}
     * @memberof User
     */
    'projects'?: Array<UserProjects>;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'status'?: string;
}
/**
 *
 * @export
 * @interface UserProjects
 */
export interface UserProjects {
    /**
     *
     * @type {number}
     * @memberof UserProjects
     */
    'projectId'?: number;
    /**
     *
     * @type {string}
     * @memberof UserProjects
     */
    'role'?: string;
}
/**
 * @type Value
 * value
 * @export
 */
export type Value = boolean | number | string;


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create custom event
         * @param {string} projectId Project ID
         * @param {CreateCustomEventRequest} createCustomEventRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomEvent: async (projectId: string, createCustomEventRequest: CreateCustomEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createCustomEvent', 'projectId', projectId)
            // verify required parameter 'createCustomEventRequest' is not null or undefined
            assertParamExists('createCustomEvent', 'createCustomEventRequest', createCustomEventRequest)
            const localVarPath = `/v1/projects/{project_id}/schema/custom-events`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCustomEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Custom events list
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customEventsList: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('customEventsList', 'projectId', projectId)
            const localVarPath = `/v1/projects/{project_id}/schema/custom-events`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Events list
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsList: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('eventsList', 'projectId', projectId)
            const localVarPath = `/v1/projects/{project_id}/schema/events`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get ingested events
         * @param {string} projectId Project ID
         * @param {EventListRequest} eventListRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsStream: async (projectId: string, eventListRequest: EventListRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('eventsStream', 'projectId', projectId)
            // verify required parameter 'eventListRequest' is not null or undefined
            assertParamExists('eventsStream', 'eventListRequest', eventListRequest)
            const localVarPath = `/v1/projects/{project_id}/data/events-stream`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventListRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update custom event
         * @param {string} projectId Project ID
         * @param {string} eventId Custom Event ID
         * @param {UpdateCustomEventRequest} updateCustomEventRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomEvent: async (projectId: string, eventId: string, updateCustomEventRequest: UpdateCustomEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateCustomEvent', 'projectId', projectId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateCustomEvent', 'eventId', eventId)
            // verify required parameter 'updateCustomEventRequest' is not null or undefined
            assertParamExists('updateCustomEvent', 'updateCustomEventRequest', updateCustomEventRequest)
            const localVarPath = `/v1/projects/{project_id}/schema/custom-events/{event_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCustomEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update event
         * @param {string} projectId Project ID
         * @param {string} eventId Event ID
         * @param {UpdateEventRequest} updateEventRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent: async (projectId: string, eventId: string, updateEventRequest: UpdateEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateEvent', 'projectId', projectId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEvent', 'eventId', eventId)
            // verify required parameter 'updateEventRequest' is not null or undefined
            assertParamExists('updateEvent', 'updateEventRequest', updateEventRequest)
            const localVarPath = `/v1/projects/{project_id}/schema/events/{event_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Create custom event
         * @param {string} projectId Project ID
         * @param {CreateCustomEventRequest} createCustomEventRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomEvent(projectId: string, createCustomEventRequest: CreateCustomEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomEvent(projectId, createCustomEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Custom events list
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customEventsList(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object & ListResponseMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customEventsList(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Events list
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsList(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object & ListResponseMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsList(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get ingested events
         * @param {string} projectId Project ID
         * @param {EventListRequest} eventListRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsStream(projectId: string, eventListRequest: EventListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object & ListResponseMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsStream(projectId, eventListRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Update custom event
         * @param {string} projectId Project ID
         * @param {string} eventId Custom Event ID
         * @param {UpdateCustomEventRequest} updateCustomEventRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomEvent(projectId: string, eventId: string, updateCustomEventRequest: UpdateCustomEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomEvent(projectId, eventId, updateCustomEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Update event
         * @param {string} projectId Project ID
         * @param {string} eventId Event ID
         * @param {UpdateEventRequest} updateEventRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEvent(projectId: string, eventId: string, updateEventRequest: UpdateEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvent(projectId, eventId, updateEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         *
         * @summary Create custom event
         * @param {string} projectId Project ID
         * @param {CreateCustomEventRequest} createCustomEventRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomEvent(projectId: string, createCustomEventRequest: CreateCustomEventRequest, options?: any): AxiosPromise<CustomEvent> {
            return localVarFp.createCustomEvent(projectId, createCustomEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Custom events list
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customEventsList(projectId: string, options?: any): AxiosPromise<object & ListResponseMetadata> {
            return localVarFp.customEventsList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Events list
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsList(projectId: string, options?: any): AxiosPromise<object & ListResponseMetadata> {
            return localVarFp.eventsList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get ingested events
         * @param {string} projectId Project ID
         * @param {EventListRequest} eventListRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsStream(projectId: string, eventListRequest: EventListRequest, options?: any): AxiosPromise<object & ListResponseMetadata> {
            return localVarFp.eventsStream(projectId, eventListRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update custom event
         * @param {string} projectId Project ID
         * @param {string} eventId Custom Event ID
         * @param {UpdateCustomEventRequest} updateCustomEventRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomEvent(projectId: string, eventId: string, updateCustomEventRequest: UpdateCustomEventRequest, options?: any): AxiosPromise<CustomEvent> {
            return localVarFp.updateCustomEvent(projectId, eventId, updateCustomEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update event
         * @param {string} projectId Project ID
         * @param {string} eventId Event ID
         * @param {UpdateEventRequest} updateEventRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent(projectId: string, eventId: string, updateEventRequest: UpdateEventRequest, options?: any): AxiosPromise<Event> {
            return localVarFp.updateEvent(projectId, eventId, updateEventRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     *
     * @summary Create custom event
     * @param {string} projectId Project ID
     * @param {CreateCustomEventRequest} createCustomEventRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public createCustomEvent(projectId: string, createCustomEventRequest: CreateCustomEventRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).createCustomEvent(projectId, createCustomEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Custom events list
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public customEventsList(projectId: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).customEventsList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Events list
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsList(projectId: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get ingested events
     * @param {string} projectId Project ID
     * @param {EventListRequest} eventListRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsStream(projectId: string, eventListRequest: EventListRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsStream(projectId, eventListRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update custom event
     * @param {string} projectId Project ID
     * @param {string} eventId Custom Event ID
     * @param {UpdateCustomEventRequest} updateCustomEventRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateCustomEvent(projectId: string, eventId: string, updateCustomEventRequest: UpdateCustomEventRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).updateCustomEvent(projectId, eventId, updateCustomEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update event
     * @param {string} projectId Project ID
     * @param {string} eventId Event ID
     * @param {UpdateEventRequest} updateEventRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateEvent(projectId: string, eventId: string, updateEventRequest: UpdateEventRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).updateEvent(projectId, eventId, updateEventRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PropertiesApi - axios parameter creator
 * @export
 */
export const PropertiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Event custom properties list
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customPropertiesList: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('customPropertiesList', 'projectId', projectId)
            const localVarPath = `/v1/projects/{project_id}/schema/custom-properties`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Properties list
         * @param {string} projectId Project ID
         * @param {'event' | 'user'} type Property type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propertiesList: async (projectId: string, type: 'event' | 'user', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('propertiesList', 'projectId', projectId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('propertiesList', 'type', type)
            const localVarPath = `/v1/projects/{project_id}/schema/properties`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List of property values
         * @param {string} projectId Project ID
         * @param {InlineObject} inlineObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propertyValuesList: async (projectId: string, inlineObject: InlineObject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('propertyValuesList', 'projectId', projectId)
            // verify required parameter 'inlineObject' is not null or undefined
            assertParamExists('propertyValuesList', 'inlineObject', inlineObject)
            const localVarPath = `/v1/projects/{project_id}/data/property-values`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update property
         * @param {string} projectId Project ID
         * @param {string} propertyId Property ID
         * @param {UpdatePropertyRequest} updatePropertyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProperty: async (projectId: string, propertyId: string, updatePropertyRequest: UpdatePropertyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateProperty', 'projectId', projectId)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('updateProperty', 'propertyId', propertyId)
            // verify required parameter 'updatePropertyRequest' is not null or undefined
            assertParamExists('updateProperty', 'updatePropertyRequest', updatePropertyRequest)
            const localVarPath = `/v1/projects/{project_id}/schema/properties/{property_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"property_id"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePropertyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertiesApi - functional programming interface
 * @export
 */
export const PropertiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PropertiesApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Event custom properties list
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customPropertiesList(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object & ListResponseMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customPropertiesList(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Properties list
         * @param {string} projectId Project ID
         * @param {'event' | 'user'} type Property type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async propertiesList(projectId: string, type: 'event' | 'user', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object & ListResponseMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.propertiesList(projectId, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary List of property values
         * @param {string} projectId Project ID
         * @param {InlineObject} inlineObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async propertyValuesList(projectId: string, inlineObject: InlineObject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.propertyValuesList(projectId, inlineObject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Update property
         * @param {string} projectId Project ID
         * @param {string} propertyId Property ID
         * @param {UpdatePropertyRequest} updatePropertyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProperty(projectId: string, propertyId: string, updatePropertyRequest: UpdatePropertyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProperty(projectId, propertyId, updatePropertyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PropertiesApi - factory interface
 * @export
 */
export const PropertiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PropertiesApiFp(configuration)
    return {
        /**
         *
         * @summary Event custom properties list
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customPropertiesList(projectId: string, options?: any): AxiosPromise<object & ListResponseMetadata> {
            return localVarFp.customPropertiesList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Properties list
         * @param {string} projectId Project ID
         * @param {'event' | 'user'} type Property type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propertiesList(projectId: string, type: 'event' | 'user', options?: any): AxiosPromise<object & ListResponseMetadata> {
            return localVarFp.propertiesList(projectId, type, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List of property values
         * @param {string} projectId Project ID
         * @param {InlineObject} inlineObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propertyValuesList(projectId: string, inlineObject: InlineObject, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.propertyValuesList(projectId, inlineObject, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update property
         * @param {string} projectId Project ID
         * @param {string} propertyId Property ID
         * @param {UpdatePropertyRequest} updatePropertyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProperty(projectId: string, propertyId: string, updatePropertyRequest: UpdatePropertyRequest, options?: any): AxiosPromise<Property> {
            return localVarFp.updateProperty(projectId, propertyId, updatePropertyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PropertiesApi - object-oriented interface
 * @export
 * @class PropertiesApi
 * @extends {BaseAPI}
 */
export class PropertiesApi extends BaseAPI {
    /**
     *
     * @summary Event custom properties list
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public customPropertiesList(projectId: string, options?: AxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).customPropertiesList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Properties list
     * @param {string} projectId Project ID
     * @param {'event' | 'user'} type Property type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public propertiesList(projectId: string, type: 'event' | 'user', options?: AxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).propertiesList(projectId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary List of property values
     * @param {string} projectId Project ID
     * @param {InlineObject} inlineObject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public propertyValuesList(projectId: string, inlineObject: InlineObject, options?: AxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).propertyValuesList(projectId, inlineObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update property
     * @param {string} projectId Project ID
     * @param {string} propertyId Property ID
     * @param {UpdatePropertyRequest} updatePropertyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public updateProperty(projectId: string, propertyId: string, updatePropertyRequest: UpdatePropertyRequest, options?: AxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).updateProperty(projectId, propertyId, updatePropertyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReportsApi - axios parameter creator
 * @export
 */
export const ReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Event segmentation query
         * @param {EventSegmentation} [eventSegmentation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventSegmentation: async (eventSegmentation?: EventSegmentation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/event-segmentation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventSegmentation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportsApi - functional programming interface
 * @export
 */
export const ReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Event segmentation query
         * @param {EventSegmentation} [eventSegmentation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventSegmentation(eventSegmentation?: EventSegmentation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventSegmentation(eventSegmentation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReportsApi - factory interface
 * @export
 */
export const ReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportsApiFp(configuration)
    return {
        /**
         *
         * @summary Event segmentation query
         * @param {EventSegmentation} [eventSegmentation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventSegmentation(eventSegmentation?: EventSegmentation, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.createEventSegmentation(eventSegmentation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReportsApi - object-oriented interface
 * @export
 * @class ReportsApi
 * @extends {BaseAPI}
 */
export class ReportsApi extends BaseAPI {
    /**
     *
     * @summary Event segmentation query
     * @param {EventSegmentation} [eventSegmentation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public createEventSegmentation(eventSegmentation?: EventSegmentation, options?: AxiosRequestConfig) {
        return ReportsApiFp(this.configuration).createEventSegmentation(eventSegmentation, options).then((request) => request(this.axios, this.basePath));
    }
}