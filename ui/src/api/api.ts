/* tslint:disable */
/* eslint-disable */
/**
 * OptiPrism
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api@optiprism.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AnalysisCumulative
 */
export interface AnalysisCumulative {
    /**
     * 
     * @type {string}
     * @memberof AnalysisCumulative
     */
    'type'?: AnalysisCumulativeTypeEnum;
}

export const AnalysisCumulativeTypeEnum = {
    Cumulative: 'cumulative'
} as const;

export type AnalysisCumulativeTypeEnum = typeof AnalysisCumulativeTypeEnum[keyof typeof AnalysisCumulativeTypeEnum];

/**
 * 
 * @export
 * @interface AnalysisLinear
 */
export interface AnalysisLinear {
    /**
     * 
     * @type {string}
     * @memberof AnalysisLinear
     */
    'type'?: AnalysisLinearTypeEnum;
}

export const AnalysisLinearTypeEnum = {
    Linear: 'linear'
} as const;

export type AnalysisLinearTypeEnum = typeof AnalysisLinearTypeEnum[keyof typeof AnalysisLinearTypeEnum];

/**
 * 
 * @export
 * @interface AnalysisRollingAverage
 */
export interface AnalysisRollingAverage {
    /**
     * 
     * @type {string}
     * @memberof AnalysisRollingAverage
     */
    'type'?: AnalysisRollingAverageTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof AnalysisRollingAverage
     */
    'window'?: number;
}

export const AnalysisRollingAverageTypeEnum = {
    RollingAverage: 'rollingAverage'
} as const;

export type AnalysisRollingAverageTypeEnum = typeof AnalysisRollingAverageTypeEnum[keyof typeof AnalysisRollingAverageTypeEnum];

/**
 * 
 * @export
 * @interface AnalysisRollingWindow
 */
export interface AnalysisRollingWindow {
    /**
     * 
     * @type {string}
     * @memberof AnalysisRollingWindow
     */
    'type'?: AnalysisRollingWindowTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof AnalysisRollingWindow
     */
    'window'?: number;
}

export const AnalysisRollingWindowTypeEnum = {
    RollingWindow: 'rollingWindow'
} as const;

export type AnalysisRollingWindowTypeEnum = typeof AnalysisRollingWindowTypeEnum[keyof typeof AnalysisRollingWindowTypeEnum];

/**
 * breakdown by property.
 * @export
 * @interface BreakdownByProperty
 */
export interface BreakdownByProperty {
    /**
     * 
     * @type {string}
     * @memberof BreakdownByProperty
     */
    'breakdownType': BreakdownByPropertyBreakdownTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof BreakdownByProperty
     */
    'propertyName': string;
    /**
     * 
     * @type {PropertyType}
     * @memberof BreakdownByProperty
     */
    'propertyType': PropertyType;
}

export const BreakdownByPropertyBreakdownTypeEnum = {
    Property: 'property'
} as const;

export type BreakdownByPropertyBreakdownTypeEnum = typeof BreakdownByPropertyBreakdownTypeEnum[keyof typeof BreakdownByPropertyBreakdownTypeEnum];

/**
 * 
 * @export
 * @interface BreakdownByPropertyAllOf
 */
export interface BreakdownByPropertyAllOf {
    /**
     * 
     * @type {string}
     * @memberof BreakdownByPropertyAllOf
     */
    'breakdownType'?: BreakdownByPropertyAllOfBreakdownTypeEnum;
}

export const BreakdownByPropertyAllOfBreakdownTypeEnum = {
    Property: 'property'
} as const;

export type BreakdownByPropertyAllOfBreakdownTypeEnum = typeof BreakdownByPropertyAllOfBreakdownTypeEnum[keyof typeof BreakdownByPropertyAllOfBreakdownTypeEnum];

/**
 * chart type
 * @export
 * @enum {string}
 */

export const ChartType = {
    Line: 'line',
    Bar: 'bar'
} as const;

export type ChartType = typeof ChartType[keyof typeof ChartType];


/**
 * Custom Event is an alias to an expression which is used while querying. You can use regular or custom events in expression. You can combine events in expression, you can use filter by properties.
 * @export
 * @interface CreateCustomEventRequest
 */
export interface CreateCustomEventRequest {
    /**
     * 
     * @type {number}
     * @memberof CreateCustomEventRequest
     */
    'projectId': number;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomEventRequest
     */
    'name': string;
    /**
     * 
     * @type {Array<CustomEventEvent>}
     * @memberof CreateCustomEventRequest
     */
    'events'?: Array<CustomEventEvent>;
}
/**
 * Custom Event is an alias to an expression which is used while querying. You can use regular or custom events in expression. You can combine events in expression, you can use filter by properties.
 * @export
 * @interface CustomEvent
 */
export interface CustomEvent {
    /**
     * 
     * @type {number}
     * @memberof CustomEvent
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CustomEvent
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CustomEvent
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof CustomEvent
     */
    'createdBy': number;
    /**
     * 
     * @type {number}
     * @memberof CustomEvent
     */
    'updatedBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomEvent
     */
    'projectId': number;
    /**
     * 
     * @type {boolean}
     * @memberof CustomEvent
     */
    'isSystem': boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomEvent
     */
    'status': CustomEventStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CustomEvent
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CustomEvent
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CustomEvent
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<CustomEventEvent>}
     * @memberof CustomEvent
     */
    'events'?: Array<CustomEventEvent>;
    /**
     * array of id of properties contained in expression events
     * @type {Array<number>}
     * @memberof CustomEvent
     */
    'properties'?: Array<number>;
    /**
     * array of id of custom properties contained in expression events
     * @type {Array<number>}
     * @memberof CustomEvent
     */
    'custom_properties'?: Array<number>;
}

export const CustomEventStatusEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type CustomEventStatusEnum = typeof CustomEventStatusEnum[keyof typeof CustomEventStatusEnum];

/**
 * custom event will matches all of the provided events
 * @export
 * @interface CustomEventEvent
 */
export interface CustomEventEvent {
    /**
     * 
     * @type {string}
     * @memberof CustomEventEvent
     */
    'eventName': string;
    /**
     * 
     * @type {EventType}
     * @memberof CustomEventEvent
     */
    'eventType': EventType;
    /**
     * array of event filters
     * @type {Array<EventFilterByProperty>}
     * @memberof CustomEventEvent
     */
    'filters'?: Array<EventFilterByProperty>;
}
/**
 * 
 * @export
 * @interface CustomEventEventAllOf
 */
export interface CustomEventEventAllOf {
    /**
     * array of event filters
     * @type {Array<EventFilterByProperty>}
     * @memberof CustomEventEventAllOf
     */
    'filters'?: Array<EventFilterByProperty>;
}
/**
 * 
 * @export
 * @interface CustomProperty
 */
export interface CustomProperty {
    /**
     * 
     * @type {number}
     * @memberof CustomProperty
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomProperty
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomProperty
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof CustomProperty
     */
    'createdBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomProperty
     */
    'updatedBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomProperty
     */
    'projectId'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof CustomProperty
     */
    'events'?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof CustomProperty
     */
    'isSystem'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomProperty
     */
    'status'?: CustomPropertyStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CustomProperty
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomProperty
     */
    'description'?: string;
    /**
     * 
     * @type {DataType}
     * @memberof CustomProperty
     */
    'type'?: DataType;
    /**
     * 
     * @type {boolean}
     * @memberof CustomProperty
     */
    'nullable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomProperty
     */
    'isArray'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CustomProperty
     */
    'tags'?: Array<string>;
}

export const CustomPropertyStatusEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type CustomPropertyStatusEnum = typeof CustomPropertyStatusEnum[keyof typeof CustomPropertyStatusEnum];

/**
 * data type
 * @export
 * @enum {string}
 */

export const DataType = {
    String: 'string',
    Number: 'number',
    Boolean: 'boolean'
} as const;

export type DataType = typeof DataType[keyof typeof DataType];


/**
 * aggregate property and compare to value
 * @export
 * @interface DidEventAggregateProperty
 */
export interface DidEventAggregateProperty {
    /**
     * 
     * @type {string}
     * @memberof DidEventAggregateProperty
     */
    'type': DidEventAggregatePropertyTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DidEventAggregateProperty
     */
    'propertyName': string;
    /**
     * 
     * @type {PropertyType}
     * @memberof DidEventAggregateProperty
     */
    'propertyType': PropertyType;
    /**
     * 
     * @type {QueryAggregateProperty}
     * @memberof DidEventAggregateProperty
     */
    'aggregate': QueryAggregateProperty;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof DidEventAggregateProperty
     */
    'operation': PropertyFilterOperation;
    /**
     * one or more values. Doesn\'t need if operation is \"empty\" or \"exist\"
     * @type {number}
     * @memberof DidEventAggregateProperty
     */
    'value'?: number;
    /**
     * time frame
     * @type {TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach}
     * @memberof DidEventAggregateProperty
     */
    'time': TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach;
}

export const DidEventAggregatePropertyTypeEnum = {
    AggregateProperty: 'aggregateProperty'
} as const;

export type DidEventAggregatePropertyTypeEnum = typeof DidEventAggregatePropertyTypeEnum[keyof typeof DidEventAggregatePropertyTypeEnum];

/**
 * 
 * @export
 * @interface DidEventAggregatePropertyAllOf
 */
export interface DidEventAggregatePropertyAllOf {
    /**
     * 
     * @type {string}
     * @memberof DidEventAggregatePropertyAllOf
     */
    'type'?: DidEventAggregatePropertyAllOfTypeEnum;
}

export const DidEventAggregatePropertyAllOfTypeEnum = {
    AggregateProperty: 'aggregateProperty'
} as const;

export type DidEventAggregatePropertyAllOfTypeEnum = typeof DidEventAggregatePropertyAllOfTypeEnum[keyof typeof DidEventAggregatePropertyAllOfTypeEnum];

/**
 * 
 * @export
 * @interface DidEventAggregatePropertyAllOf1
 */
export interface DidEventAggregatePropertyAllOf1 {
    /**
     * 
     * @type {QueryAggregateProperty}
     * @memberof DidEventAggregatePropertyAllOf1
     */
    'aggregate'?: QueryAggregateProperty;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof DidEventAggregatePropertyAllOf1
     */
    'operation'?: PropertyFilterOperation;
    /**
     * one or more values. Doesn\'t need if operation is \"empty\" or \"exist\"
     * @type {number}
     * @memberof DidEventAggregatePropertyAllOf1
     */
    'value'?: number;
    /**
     * time frame
     * @type {TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach}
     * @memberof DidEventAggregatePropertyAllOf1
     */
    'time'?: TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach;
}
/**
 * find all users who made event X times
 * @export
 * @interface DidEventCount
 */
export interface DidEventCount {
    /**
     * 
     * @type {string}
     * @memberof DidEventCount
     */
    'type': DidEventCountTypeEnum;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof DidEventCount
     */
    'operation': PropertyFilterOperation;
    /**
     * one or more values. Doesn\'t need if operation is \"empty\" or \"exist\"
     * @type {number}
     * @memberof DidEventCount
     */
    'value'?: number;
    /**
     * time frame
     * @type {TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach}
     * @memberof DidEventCount
     */
    'time': TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach;
}

export const DidEventCountTypeEnum = {
    DidEventCount: 'didEventCount'
} as const;

export type DidEventCountTypeEnum = typeof DidEventCountTypeEnum[keyof typeof DidEventCountTypeEnum];

/**
 * find users with Nth event occurance
 * @export
 * @interface DidEventHistoricalCount
 */
export interface DidEventHistoricalCount {
    /**
     * 
     * @type {string}
     * @memberof DidEventHistoricalCount
     */
    'type': DidEventHistoricalCountTypeEnum;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof DidEventHistoricalCount
     */
    'operation': PropertyFilterOperation;
    /**
     * 
     * @type {number}
     * @memberof DidEventHistoricalCount
     */
    'value'?: number;
    /**
     * 
     * @type {TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach}
     * @memberof DidEventHistoricalCount
     */
    'time': TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach;
}

export const DidEventHistoricalCountTypeEnum = {
    HistoricalCount: 'historicalCount'
} as const;

export type DidEventHistoricalCountTypeEnum = typeof DidEventHistoricalCountTypeEnum[keyof typeof DidEventHistoricalCountTypeEnum];

/**
 * find all users who made left event X time more/less than right event.
 * @export
 * @interface DidEventRelativeCount
 */
export interface DidEventRelativeCount {
    /**
     * 
     * @type {string}
     * @memberof DidEventRelativeCount
     */
    'type': DidEventRelativeCountTypeEnum;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof DidEventRelativeCount
     */
    'operation': PropertyFilterOperation;
    /**
     * 
     * @type {EventRef}
     * @memberof DidEventRelativeCount
     */
    'rightEvent': EventRef;
    /**
     * 
     * @type {TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach}
     * @memberof DidEventRelativeCount
     */
    'time': TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach;
}

export const DidEventRelativeCountTypeEnum = {
    DidEventRelativeCount: 'didEventRelativeCount'
} as const;

export type DidEventRelativeCountTypeEnum = typeof DidEventRelativeCountTypeEnum[keyof typeof DidEventRelativeCountTypeEnum];

/**
 * Event describes user event. User event is an action which user (client) might do on a product site/app. For instance, user might do a signup and it might be a \"Sign up\" event. Event Also has a properties. <br/><br/> Name must be unique among project events, including custom ones. E.g. you can\'t have multiple \"Sign up\" events. <br/><br/> Normally events are created and updated by admin in a project scope, but there are also system events, which can\'t be deleted or modified.
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * event unique id
     * @type {number}
     * @memberof Event
     */
    'id': number;
    /**
     * create date
     * @type {string}
     * @memberof Event
     */
    'createdAt': string;
    /**
     * update (once updated)
     * @type {string}
     * @memberof Event
     */
    'updatedAt'?: string;
    /**
     * id of creator User
     * @type {number}
     * @memberof Event
     */
    'createdBy': number;
    /**
     * id of updater User
     * @type {number}
     * @memberof Event
     */
    'updatedBy'?: number;
    /**
     * project id
     * @type {number}
     * @memberof Event
     */
    'projectId': number;
    /**
     * the event is a system-wide, shown in any project and can\'t be modified by a regular user
     * @type {boolean}
     * @memberof Event
     */
    'isSystyem'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Event
     */
    'tags'?: Array<string>;
    /**
     * event name. Must be unique among all project events (including custom). The name field is used while events ingesting.
     * @type {string}
     * @memberof Event
     */
    'name': string;
    /**
     * event name to display. If empty then name property is used.
     * @type {string}
     * @memberof Event
     */
    'displayName'?: string;
    /**
     * description
     * @type {string}
     * @memberof Event
     */
    'description'?: string;
    /**
     * event status
     * @type {string}
     * @memberof Event
     */
    'status': EventStatusEnum;
    /**
     * array of id of attached to event properties
     * @type {Array<number>}
     * @memberof Event
     */
    'properties'?: Array<number>;
    /**
     * array of id of attached to event custom properties
     * @type {Array<number>}
     * @memberof Event
     */
    'custom_properties'?: Array<number>;
}

export const EventStatusEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type EventStatusEnum = typeof EventStatusEnum[keyof typeof EventStatusEnum];

/**
 * event filter
 * @export
 * @interface EventFilter
 */
export interface EventFilter {
    /**
     * 
     * @type {string}
     * @memberof EventFilter
     */
    'filteType'?: EventFilterFilteTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EventFilter
     */
    'cohortId'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventFilter
     */
    'filterType': EventFilterFilterTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof EventFilter
     */
    'propertyName': string;
    /**
     * 
     * @type {PropertyType}
     * @memberof EventFilter
     */
    'propertyType': PropertyType;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof EventFilter
     */
    'operation': PropertyFilterOperation;
    /**
     * one or several property values. May be not set if operation is \"empty\" or \"exist\"
     * @type {Array<Value>}
     * @memberof EventFilter
     */
    'value'?: Array<Value>;
}

export const EventFilterFilteTypeEnum = {
    Cohort: 'cohort'
} as const;

export type EventFilterFilteTypeEnum = typeof EventFilterFilteTypeEnum[keyof typeof EventFilterFilteTypeEnum];
export const EventFilterFilterTypeEnum = {
    Property: 'property'
} as const;

export type EventFilterFilterTypeEnum = typeof EventFilterFilterTypeEnum[keyof typeof EventFilterFilterTypeEnum];

/**
 * 
 * @export
 * @interface EventFilterByCohort
 */
export interface EventFilterByCohort {
    /**
     * 
     * @type {string}
     * @memberof EventFilterByCohort
     */
    'filteType'?: EventFilterByCohortFilteTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EventFilterByCohort
     */
    'cohortId'?: number;
}

export const EventFilterByCohortFilteTypeEnum = {
    Cohort: 'cohort'
} as const;

export type EventFilterByCohortFilteTypeEnum = typeof EventFilterByCohortFilteTypeEnum[keyof typeof EventFilterByCohortFilteTypeEnum];

/**
 * filter by property. Use this in event filters or in common filters. If you use it in event then event will be inherited, if you use filter as a common, then property should be commnon for all events.
 * @export
 * @interface EventFilterByProperty
 */
export interface EventFilterByProperty {
    /**
     * 
     * @type {string}
     * @memberof EventFilterByProperty
     */
    'filterType': EventFilterByPropertyFilterTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof EventFilterByProperty
     */
    'propertyName': string;
    /**
     * 
     * @type {PropertyType}
     * @memberof EventFilterByProperty
     */
    'propertyType': PropertyType;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof EventFilterByProperty
     */
    'operation': PropertyFilterOperation;
    /**
     * one or several property values. May be not set if operation is \"empty\" or \"exist\"
     * @type {Array<Value>}
     * @memberof EventFilterByProperty
     */
    'value'?: Array<Value>;
}

export const EventFilterByPropertyFilterTypeEnum = {
    Property: 'property'
} as const;

export type EventFilterByPropertyFilterTypeEnum = typeof EventFilterByPropertyFilterTypeEnum[keyof typeof EventFilterByPropertyFilterTypeEnum];

/**
 * 
 * @export
 * @interface EventFilterByPropertyAllOf
 */
export interface EventFilterByPropertyAllOf {
    /**
     * 
     * @type {string}
     * @memberof EventFilterByPropertyAllOf
     */
    'filterType'?: EventFilterByPropertyAllOfFilterTypeEnum;
}

export const EventFilterByPropertyAllOfFilterTypeEnum = {
    Property: 'property'
} as const;

export type EventFilterByPropertyAllOfFilterTypeEnum = typeof EventFilterByPropertyAllOfFilterTypeEnum[keyof typeof EventFilterByPropertyAllOfFilterTypeEnum];

/**
 * 
 * @export
 * @interface EventFilterByPropertyAllOf1
 */
export interface EventFilterByPropertyAllOf1 {
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof EventFilterByPropertyAllOf1
     */
    'operation'?: PropertyFilterOperation;
    /**
     * one or several property values. May be not set if operation is \"empty\" or \"exist\"
     * @type {Array<Value>}
     * @memberof EventFilterByPropertyAllOf1
     */
    'value'?: Array<Value>;
}
/**
 * request events sorted by time of creation
 * @export
 * @interface EventListRequest
 */
export interface EventListRequest {
    /**
     * select time
     * @type {TimeBetween | TimeFrom | TimeLast}
     * @memberof EventListRequest
     */
    'time': TimeBetween | TimeFrom | TimeLast;
    /**
     * 
     * @type {EventListRequestSearch}
     * @memberof EventListRequest
     */
    'search'?: EventListRequestSearch;
    /**
     * array of events to query
     * @type {Array<EventRef & object>}
     * @memberof EventListRequest
     */
    'events': Array<EventRef & object>;
    /**
     * array of common filters (which applies to all events)
     * @type {Array<EventFilterByProperty | EventFilterByCohort>}
     * @memberof EventListRequest
     */
    'filters'?: Array<EventFilterByProperty | EventFilterByCohort>;
}
/**
 * search in results
 * @export
 * @interface EventListRequestSearch
 */
export interface EventListRequestSearch {
    /**
     * 
     * @type {string}
     * @memberof EventListRequestSearch
     */
    'term'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EventListRequestSearch
     */
    'eventProperties'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EventListRequestSearch
     */
    'userProperties'?: Array<string>;
}
/**
 * event query
 * @export
 * @interface EventQuery
 */
export interface EventQuery {
    /**
     * 
     * @type {string}
     * @memberof EventQuery
     */
    'name'?: string;
    /**
     * 
     * @type {QuerySimple | QueryCountPerGroup | QueryAggregatePropertyPerGroup | QueryAggregateProperty | QueryFormula}
     * @memberof EventQuery
     */
    'query': QuerySimple | QueryCountPerGroup | QueryAggregatePropertyPerGroup | QueryAggregateProperty | QueryFormula;
}
/**
 * 
 * @export
 * @interface EventRecord
 */
export interface EventRecord {
    /**
     * 
     * @type {string}
     * @memberof EventRecord
     */
    'name'?: string;
    /**
     * map of property name and property value pairs
     * @type {object}
     * @memberof EventRecord
     */
    'properties'?: object;
}
/**
 * reference to event by its name and type
 * @export
 * @interface EventRef
 */
export interface EventRef {
    /**
     * 
     * @type {string}
     * @memberof EventRef
     */
    'eventName'?: string;
    /**
     * 
     * @type {EventType}
     * @memberof EventRef
     */
    'eventType'?: EventType;
}
/**
 * event segmentation report type main payload
 * @export
 * @interface EventSegmentation
 */
export interface EventSegmentation {
    /**
     * select time
     * @type {TimeBetween | TimeFrom | TimeLast}
     * @memberof EventSegmentation
     */
    'time': TimeBetween | TimeFrom | TimeLast;
    /**
     * group that is used in aggregations by group. For instance, group by user or group by organizartion.
     * @type {string}
     * @memberof EventSegmentation
     */
    'group': string;
    /**
     * 
     * @type {TimeUnit}
     * @memberof EventSegmentation
     */
    'intervalUnit': TimeUnit;
    /**
     * 
     * @type {ChartType}
     * @memberof EventSegmentation
     */
    'chartType': ChartType;
    /**
     * analysis type
     * @type {AnalysisLinear | AnalysisRollingAverage | AnalysisRollingWindow | AnalysisCumulative}
     * @memberof EventSegmentation
     */
    'analysis': AnalysisLinear | AnalysisRollingAverage | AnalysisRollingWindow | AnalysisCumulative;
    /**
     * 
     * @type {EventSegmentationCompare}
     * @memberof EventSegmentation
     */
    'compare'?: EventSegmentationCompare;
    /**
     * array of events to query
     * @type {Array<EventSegmentationEvent>}
     * @memberof EventSegmentation
     */
    'events': Array<EventSegmentationEvent>;
    /**
     * array of common filters (which applies to all events)
     * @type {Array<EventFilterByProperty | EventFilterByCohort>}
     * @memberof EventSegmentation
     */
    'filters'?: Array<EventFilterByProperty | EventFilterByCohort>;
    /**
     * array of common breakdowns (which applies to all events)
     * @type {Array<BreakdownByProperty>}
     * @memberof EventSegmentation
     */
    'breakdowns'?: Array<BreakdownByProperty>;
    /**
     * array of segments
     * @type {Array<EventSegmentationSegment>}
     * @memberof EventSegmentation
     */
    'segments'?: Array<EventSegmentationSegment>;
}
/**
 * optional comparison with previous period
 * @export
 * @interface EventSegmentationCompare
 */
export interface EventSegmentationCompare {
    /**
     * offset in past in timeUnit
     * @type {number}
     * @memberof EventSegmentationCompare
     */
    'offset': number;
    /**
     * 
     * @type {TimeUnit}
     * @memberof EventSegmentationCompare
     */
    'unit': TimeUnit;
}
/**
 * event object
 * @export
 * @interface EventSegmentationEvent
 */
export interface EventSegmentationEvent {
    /**
     * 
     * @type {string}
     * @memberof EventSegmentationEvent
     */
    'eventName': string;
    /**
     * 
     * @type {EventType}
     * @memberof EventSegmentationEvent
     */
    'eventType': EventType;
    /**
     * array of event filters
     * @type {Array<EventFilterByProperty>}
     * @memberof EventSegmentationEvent
     */
    'filters'?: Array<EventFilterByProperty>;
    /**
     * 
     * @type {Array<BreakdownByProperty>}
     * @memberof EventSegmentationEvent
     */
    'breakdowns'?: Array<BreakdownByProperty>;
    /**
     * array of event queries
     * @type {Array<EventQuery>}
     * @memberof EventSegmentationEvent
     */
    'queries': Array<EventQuery>;
}
/**
 * 
 * @export
 * @interface EventSegmentationEventAllOf
 */
export interface EventSegmentationEventAllOf {
    /**
     * array of event filters
     * @type {Array<EventFilterByProperty>}
     * @memberof EventSegmentationEventAllOf
     */
    'filters'?: Array<EventFilterByProperty>;
    /**
     * 
     * @type {Array<BreakdownByProperty>}
     * @memberof EventSegmentationEventAllOf
     */
    'breakdowns'?: Array<BreakdownByProperty>;
    /**
     * array of event queries
     * @type {Array<EventQuery>}
     * @memberof EventSegmentationEventAllOf
     */
    'queries'?: Array<EventQuery>;
}
/**
 * segment
 * @export
 * @interface EventSegmentationSegment
 */
export interface EventSegmentationSegment {
    /**
     * name of segment
     * @type {string}
     * @memberof EventSegmentationSegment
     */
    'name'?: string;
    /**
     * array of conditions
     * @type {Array<SegmentCondition>}
     * @memberof EventSegmentationSegment
     */
    'conditions': Array<SegmentCondition>;
}
/**
 * possible event type
 * @export
 * @enum {string}
 */

export const EventType = {
    Regular: 'regular',
    Custom: 'custom'
} as const;

export type EventType = typeof EventType[keyof typeof EventType];


/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {Array<string> | Array<number>}
     * @memberof InlineResponse200
     */
    'values'?: Array<string> | Array<number>;
}
/**
 * list response metadata
 * @export
 * @interface ListResponseMetadata
 */
export interface ListResponseMetadata {
    /**
     * 
     * @type {ListResponseMetadataMeta}
     * @memberof ListResponseMetadata
     */
    'meta'?: ListResponseMetadataMeta;
}
/**
 * 
 * @export
 * @interface ListResponseMetadataMeta
 */
export interface ListResponseMetadataMeta {
    /**
     * 
     * @type {string}
     * @memberof ListResponseMetadataMeta
     */
    'next'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListResponseMetadataMeta
     */
    'prev'?: string;
    /**
     * 
     * @type {number}
     * @memberof ListResponseMetadataMeta
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {Array<number>}
     * @memberof Organization
     */
    'teams'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Organization
     */
    'users'?: Array<number>;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'createdBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'updatedBy'?: number;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'sessionTimeoutSeconds'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Project
     */
    'teams'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Project
     */
    'users'?: Array<number>;
}
/**
 * property defines event or user property. For example, event \"Buy product\" may contains next properties like \"Product name\" and \"Price.\"
 * @export
 * @interface Property
 */
export interface Property {
    /**
     * property unique id
     * @type {number}
     * @memberof Property
     */
    'id': number;
    /**
     * create date
     * @type {string}
     * @memberof Property
     */
    'createdAt': string;
    /**
     * update (once updated)
     * @type {string}
     * @memberof Property
     */
    'updatedAt'?: string;
    /**
     * id of creator User
     * @type {number}
     * @memberof Property
     */
    'createdBy': number;
    /**
     * id of updater User
     * @type {number}
     * @memberof Property
     */
    'updatedBy'?: number;
    /**
     * project id
     * @type {number}
     * @memberof Property
     */
    'projectId': number;
    /**
     * list of id of events which use this property
     * @type {Array<number>}
     * @memberof Property
     */
    'events'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    'scope': PropertyScopeEnum;
    /**
     * the property is a system-wide, shown in any project and can\'t be modified by a regular user
     * @type {boolean}
     * @memberof Property
     */
    'isSystem': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Property
     */
    'tags'?: Array<string>;
    /**
     * property name. Must be unique
     * @type {string}
     * @memberof Property
     */
    'name': string;
    /**
     * property name to display. If empty then name is used.
     * @type {string}
     * @memberof Property
     */
    'displayName'?: string;
    /**
     * description
     * @type {string}
     * @memberof Property
     */
    'description'?: string;
    /**
     * property status
     * @type {string}
     * @memberof Property
     */
    'status': PropertyStatusEnum;
    /**
     * 
     * @type {object & DataType}
     * @memberof Property
     */
    'dataType'?: object & DataType;
    /**
     * nullable property might contains null value
     * @type {boolean}
     * @memberof Property
     */
    'nullable': boolean;
    /**
     * array property might contents multiple values
     * @type {boolean}
     * @memberof Property
     */
    'isArray': boolean;
    /**
     * dictionary can efficiently packs strings provided that cardinality will be relatively log (16bits is a reasonable maximum)
     * @type {boolean}
     * @memberof Property
     */
    'isDictionary': boolean;
    /**
     * 
     * @type {object & DataType}
     * @memberof Property
     */
    'dictionaryType'?: object & DataType;
}

export const PropertyScopeEnum = {
    Event: 'event',
    User: 'user'
} as const;

export type PropertyScopeEnum = typeof PropertyScopeEnum[keyof typeof PropertyScopeEnum];
export const PropertyStatusEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type PropertyStatusEnum = typeof PropertyStatusEnum[keyof typeof PropertyStatusEnum];

/**
 * operation
 * @export
 * @enum {string}
 */

export const PropertyFilterOperation = {
    Equal: '=',
    Neq: 'neq',
    Gt: 'gt',
    Gte: 'gte',
    Lt: 'lt',
    Lte: 'lte',
    True: 'true',
    False: 'false',
    Exists: 'exists',
    Empty: 'empty',
    ArrAll: 'arr_all',
    ArrAny: 'arr_any',
    ArrNone: 'arr_none',
    Regex: 'regex'
} as const;

export type PropertyFilterOperation = typeof PropertyFilterOperation[keyof typeof PropertyFilterOperation];


/**
 * reference to property by its name and type
 * @export
 * @interface PropertyRef
 */
export interface PropertyRef {
    /**
     * 
     * @type {string}
     * @memberof PropertyRef
     */
    'propertyName'?: string;
    /**
     * 
     * @type {PropertyType}
     * @memberof PropertyRef
     */
    'propertyType'?: PropertyType;
}
/**
 * possible property type
 * @export
 * @enum {string}
 */

export const PropertyType = {
    Event: 'event',
    User: 'user',
    Custom: 'custom'
} as const;

export type PropertyType = typeof PropertyType[keyof typeof PropertyType];


/**
 * 
 * @export
 * @enum {string}
 */

export const QueryAggregate = {
    Sum: 'sum',
    Avg: 'avg',
    Median: 'median',
    Min: 'min',
    Max: 'max',
    DistinctCount: 'distinctCount',
    _25thPercentile: '25thPercentile',
    _75thPercentile: '75thPercentile',
    _90thPercentile: '90thPercentile',
    _99thPercentile: '99thPercentile'
} as const;

export type QueryAggregate = typeof QueryAggregate[keyof typeof QueryAggregate];


/**
 * aggregate of property per by group
 * @export
 * @interface QueryAggregateProperty
 */
export interface QueryAggregateProperty {
    /**
     * 
     * @type {string}
     * @memberof QueryAggregateProperty
     */
    'queryType': QueryAggregatePropertyQueryTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof QueryAggregateProperty
     */
    'propertyName': string;
    /**
     * 
     * @type {PropertyType}
     * @memberof QueryAggregateProperty
     */
    'propertyType': PropertyType;
    /**
     * 
     * @type {QueryAggregate}
     * @memberof QueryAggregateProperty
     */
    'aggregate': QueryAggregate;
}

export const QueryAggregatePropertyQueryTypeEnum = {
    AggregateProperty: 'aggregateProperty'
} as const;

export type QueryAggregatePropertyQueryTypeEnum = typeof QueryAggregatePropertyQueryTypeEnum[keyof typeof QueryAggregatePropertyQueryTypeEnum];

/**
 * 
 * @export
 * @interface QueryAggregatePropertyAllOf
 */
export interface QueryAggregatePropertyAllOf {
    /**
     * 
     * @type {string}
     * @memberof QueryAggregatePropertyAllOf
     */
    'queryType'?: QueryAggregatePropertyAllOfQueryTypeEnum;
}

export const QueryAggregatePropertyAllOfQueryTypeEnum = {
    AggregateProperty: 'aggregateProperty'
} as const;

export type QueryAggregatePropertyAllOfQueryTypeEnum = typeof QueryAggregatePropertyAllOfQueryTypeEnum[keyof typeof QueryAggregatePropertyAllOfQueryTypeEnum];

/**
 * 
 * @export
 * @interface QueryAggregatePropertyAllOf1
 */
export interface QueryAggregatePropertyAllOf1 {
    /**
     * 
     * @type {QueryAggregate}
     * @memberof QueryAggregatePropertyAllOf1
     */
    'aggregate'?: QueryAggregate;
}
/**
 * aggregate of property per by group
 * @export
 * @interface QueryAggregatePropertyPerGroup
 */
export interface QueryAggregatePropertyPerGroup {
    /**
     * 
     * @type {string}
     * @memberof QueryAggregatePropertyPerGroup
     */
    'queryType': QueryAggregatePropertyPerGroupQueryTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof QueryAggregatePropertyPerGroup
     */
    'propertyName': string;
    /**
     * 
     * @type {PropertyType}
     * @memberof QueryAggregatePropertyPerGroup
     */
    'propertyType': PropertyType;
    /**
     * 
     * @type {QueryAggregate}
     * @memberof QueryAggregatePropertyPerGroup
     */
    'aggregate': QueryAggregate;
    /**
     * 
     * @type {QueryAggregate}
     * @memberof QueryAggregatePropertyPerGroup
     */
    'aggregatePerGroup': QueryAggregate;
}

export const QueryAggregatePropertyPerGroupQueryTypeEnum = {
    AggregatePropertyPerGroup: 'aggregatePropertyPerGroup'
} as const;

export type QueryAggregatePropertyPerGroupQueryTypeEnum = typeof QueryAggregatePropertyPerGroupQueryTypeEnum[keyof typeof QueryAggregatePropertyPerGroupQueryTypeEnum];

/**
 * 
 * @export
 * @interface QueryAggregatePropertyPerGroupAllOf
 */
export interface QueryAggregatePropertyPerGroupAllOf {
    /**
     * 
     * @type {string}
     * @memberof QueryAggregatePropertyPerGroupAllOf
     */
    'queryType'?: QueryAggregatePropertyPerGroupAllOfQueryTypeEnum;
}

export const QueryAggregatePropertyPerGroupAllOfQueryTypeEnum = {
    AggregatePropertyPerGroup: 'aggregatePropertyPerGroup'
} as const;

export type QueryAggregatePropertyPerGroupAllOfQueryTypeEnum = typeof QueryAggregatePropertyPerGroupAllOfQueryTypeEnum[keyof typeof QueryAggregatePropertyPerGroupAllOfQueryTypeEnum];

/**
 * 
 * @export
 * @interface QueryAggregatePropertyPerGroupAllOf1
 */
export interface QueryAggregatePropertyPerGroupAllOf1 {
    /**
     * 
     * @type {QueryAggregate}
     * @memberof QueryAggregatePropertyPerGroupAllOf1
     */
    'aggregate'?: QueryAggregate;
    /**
     * 
     * @type {QueryAggregate}
     * @memberof QueryAggregatePropertyPerGroupAllOf1
     */
    'aggregatePerGroup'?: QueryAggregate;
}
/**
 * event count aggregate by group
 * @export
 * @interface QueryCountPerGroup
 */
export interface QueryCountPerGroup {
    /**
     * 
     * @type {string}
     * @memberof QueryCountPerGroup
     */
    'queryType': QueryCountPerGroupQueryTypeEnum;
    /**
     * 
     * @type {QueryAggregate}
     * @memberof QueryCountPerGroup
     */
    'aggregate': QueryAggregate;
}

export const QueryCountPerGroupQueryTypeEnum = {
    CountPerGroup: 'countPerGroup'
} as const;

export type QueryCountPerGroupQueryTypeEnum = typeof QueryCountPerGroupQueryTypeEnum[keyof typeof QueryCountPerGroupQueryTypeEnum];

/**
 * apply formula
 * @export
 * @interface QueryFormula
 */
export interface QueryFormula {
    /**
     * 
     * @type {string}
     * @memberof QueryFormula
     */
    'queryType'?: QueryFormulaQueryTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof QueryFormula
     */
    'formula'?: string;
}

export const QueryFormulaQueryTypeEnum = {
    Formula: 'formula'
} as const;

export type QueryFormulaQueryTypeEnum = typeof QueryFormulaQueryTypeEnum[keyof typeof QueryFormulaQueryTypeEnum];

/**
 * simple query without any additional agruments
 * @export
 * @interface QuerySimple
 */
export interface QuerySimple {
    /**
     * 
     * @type {string}
     * @memberof QuerySimple
     */
    'queryType': QuerySimpleQueryTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof QuerySimple
     */
    'query': QuerySimpleQueryEnum;
}

export const QuerySimpleQueryTypeEnum = {
    Simple: 'simple'
} as const;

export type QuerySimpleQueryTypeEnum = typeof QuerySimpleQueryTypeEnum[keyof typeof QuerySimpleQueryTypeEnum];
export const QuerySimpleQueryEnum = {
    CountEvents: 'countEvents',
    CountUniqueGroups: 'countUniqueGroups',
    WeeklyActiveGroups: 'weeklyActiveGroups',
    MonthlyActiveGroups: 'monthlyActiveGroups'
} as const;

export type QuerySimpleQueryEnum = typeof QuerySimpleQueryEnum[keyof typeof QuerySimpleQueryEnum];

/**
 * @type SegmentCondition
 * @export
 */
export type SegmentCondition = SegmentConditionDidEvent | SegmentConditionFunnel | SegmentConditionHadPropertyValue | SegmentConditionHasPropertyValue | object;

/**
 * did event condition
 * @export
 * @interface SegmentConditionDidEvent
 */
export interface SegmentConditionDidEvent {
    /**
     * 
     * @type {string}
     * @memberof SegmentConditionDidEvent
     */
    'conditionType'?: SegmentConditionDidEventConditionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SegmentConditionDidEvent
     */
    'eventName'?: string;
    /**
     * 
     * @type {EventType}
     * @memberof SegmentConditionDidEvent
     */
    'eventType'?: EventType;
    /**
     * 
     * @type {Array<EventFilterByProperty>}
     * @memberof SegmentConditionDidEvent
     */
    'filters'?: Array<EventFilterByProperty>;
    /**
     * 
     * @type {DidEventCount | DidEventRelativeCount | DidEventAggregateProperty | DidEventHistoricalCount}
     * @memberof SegmentConditionDidEvent
     */
    'aggregate'?: DidEventCount | DidEventRelativeCount | DidEventAggregateProperty | DidEventHistoricalCount;
}

export const SegmentConditionDidEventConditionTypeEnum = {
    DidEvent: 'didEvent'
} as const;

export type SegmentConditionDidEventConditionTypeEnum = typeof SegmentConditionDidEventConditionTypeEnum[keyof typeof SegmentConditionDidEventConditionTypeEnum];

/**
 * 
 * @export
 * @interface SegmentConditionDidEventAllOf
 */
export interface SegmentConditionDidEventAllOf {
    /**
     * 
     * @type {string}
     * @memberof SegmentConditionDidEventAllOf
     */
    'conditionType'?: SegmentConditionDidEventAllOfConditionTypeEnum;
}

export const SegmentConditionDidEventAllOfConditionTypeEnum = {
    DidEvent: 'didEvent'
} as const;

export type SegmentConditionDidEventAllOfConditionTypeEnum = typeof SegmentConditionDidEventAllOfConditionTypeEnum[keyof typeof SegmentConditionDidEventAllOfConditionTypeEnum];

/**
 * 
 * @export
 * @interface SegmentConditionDidEventAllOf1
 */
export interface SegmentConditionDidEventAllOf1 {
    /**
     * 
     * @type {Array<EventFilterByProperty>}
     * @memberof SegmentConditionDidEventAllOf1
     */
    'filters'?: Array<EventFilterByProperty>;
    /**
     * 
     * @type {DidEventCount | DidEventRelativeCount | DidEventAggregateProperty | DidEventHistoricalCount}
     * @memberof SegmentConditionDidEventAllOf1
     */
    'aggregate'?: DidEventCount | DidEventRelativeCount | DidEventAggregateProperty | DidEventHistoricalCount;
}
/**
 * 
 * @export
 * @interface SegmentConditionFunnel
 */
export interface SegmentConditionFunnel {
    /**
     * 
     * @type {string}
     * @memberof SegmentConditionFunnel
     */
    'conditionType'?: SegmentConditionFunnelConditionTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof SegmentConditionFunnel
     */
    'last'?: number;
    /**
     * 
     * @type {TimeUnit}
     * @memberof SegmentConditionFunnel
     */
    'bucket'?: TimeUnit;
}

export const SegmentConditionFunnelConditionTypeEnum = {
    Funnel: 'funnel'
} as const;

export type SegmentConditionFunnelConditionTypeEnum = typeof SegmentConditionFunnelConditionTypeEnum[keyof typeof SegmentConditionFunnelConditionTypeEnum];

/**
 * check whether the user had a property with a value
 * @export
 * @interface SegmentConditionHadPropertyValue
 */
export interface SegmentConditionHadPropertyValue {
    /**
     * 
     * @type {string}
     * @memberof SegmentConditionHadPropertyValue
     */
    'conditionType': SegmentConditionHadPropertyValueConditionTypeEnum;
    /**
     * property name. Because property here is a user only, we don\'t need propertyType
     * @type {string}
     * @memberof SegmentConditionHadPropertyValue
     */
    'propertyName': string;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof SegmentConditionHadPropertyValue
     */
    'operation': PropertyFilterOperation;
    /**
     * one or more values. Doesn\'t need if operation is \"empty\" or \"exist\"
     * @type {Array<Value>}
     * @memberof SegmentConditionHadPropertyValue
     */
    'values'?: Array<Value>;
    /**
     * time frame
     * @type {TimeBetween | TimeLast | TimeWindowEach}
     * @memberof SegmentConditionHadPropertyValue
     */
    'time': TimeBetween | TimeLast | TimeWindowEach;
}

export const SegmentConditionHadPropertyValueConditionTypeEnum = {
    HadPropertyValue: 'hadPropertyValue'
} as const;

export type SegmentConditionHadPropertyValueConditionTypeEnum = typeof SegmentConditionHadPropertyValueConditionTypeEnum[keyof typeof SegmentConditionHadPropertyValueConditionTypeEnum];

/**
 * check whether the user currently has a property with a value
 * @export
 * @interface SegmentConditionHasPropertyValue
 */
export interface SegmentConditionHasPropertyValue {
    /**
     * 
     * @type {string}
     * @memberof SegmentConditionHasPropertyValue
     */
    'conditionType': SegmentConditionHasPropertyValueConditionTypeEnum;
    /**
     * property name. Because property here is a user only, we don\'t need propertyType
     * @type {string}
     * @memberof SegmentConditionHasPropertyValue
     */
    'propertyName': string;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof SegmentConditionHasPropertyValue
     */
    'operation': PropertyFilterOperation;
    /**
     * one or more values. Doesn\'t need if operation is \"empty\" or \"exist\"
     * @type {Array<Value>}
     * @memberof SegmentConditionHasPropertyValue
     */
    'values'?: Array<Value>;
}

export const SegmentConditionHasPropertyValueConditionTypeEnum = {
    HasPropertyValue: 'hasPropertyValue'
} as const;

export type SegmentConditionHasPropertyValueConditionTypeEnum = typeof SegmentConditionHasPropertyValueConditionTypeEnum[keyof typeof SegmentConditionHasPropertyValueConditionTypeEnum];

/**
 * time spent after the first use of event. Use in segmentation
 * @export
 * @interface TimeAfterFirstUse
 */
export interface TimeAfterFirstUse {
    /**
     * 
     * @type {string}
     * @memberof TimeAfterFirstUse
     */
    'type': TimeAfterFirstUseTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof TimeAfterFirstUse
     */
    'within': number;
    /**
     * 
     * @type {TimeUnit}
     * @memberof TimeAfterFirstUse
     */
    'unit': TimeUnit;
}

export const TimeAfterFirstUseTypeEnum = {
    AfterFirstUse: 'afterFirstUse'
} as const;

export type TimeAfterFirstUseTypeEnum = typeof TimeAfterFirstUseTypeEnum[keyof typeof TimeAfterFirstUseTypeEnum];

/**
 * time range between fixed values
 * @export
 * @interface TimeBetween
 */
export interface TimeBetween {
    /**
     * 
     * @type {string}
     * @memberof TimeBetween
     */
    'type': TimeBetweenTypeEnum;
    /**
     * start date
     * @type {string}
     * @memberof TimeBetween
     */
    'from': string;
    /**
     * end date
     * @type {string}
     * @memberof TimeBetween
     */
    'to': string;
}

export const TimeBetweenTypeEnum = {
    Between: 'between'
} as const;

export type TimeBetweenTypeEnum = typeof TimeBetweenTypeEnum[keyof typeof TimeBetweenTypeEnum];

/**
 * time range between fixed value and current time
 * @export
 * @interface TimeFrom
 */
export interface TimeFrom {
    /**
     * 
     * @type {string}
     * @memberof TimeFrom
     */
    'type': TimeFromTypeEnum;
    /**
     * start date
     * @type {string}
     * @memberof TimeFrom
     */
    'from': string;
}

export const TimeFromTypeEnum = {
    From: 'from'
} as const;

export type TimeFromTypeEnum = typeof TimeFromTypeEnum[keyof typeof TimeFromTypeEnum];

/**
 * take last N days/weeks
 * @export
 * @interface TimeLast
 */
export interface TimeLast {
    /**
     * 
     * @type {string}
     * @memberof TimeLast
     */
    'type': TimeLastTypeEnum;
    /**
     * N days/weeks
     * @type {number}
     * @memberof TimeLast
     */
    'n': number;
    /**
     * 
     * @type {TimeUnit}
     * @memberof TimeLast
     */
    'unit': TimeUnit;
}

export const TimeLastTypeEnum = {
    Last: 'last'
} as const;

export type TimeLastTypeEnum = typeof TimeLastTypeEnum[keyof typeof TimeLastTypeEnum];

/**
 * time unit
 * @export
 * @enum {string}
 */

export const TimeUnit = {
    Second: 'second',
    Minute: 'minute',
    Hour: 'hour',
    Day: 'day',
    Week: 'week',
    Month: 'month',
    Year: 'year'
} as const;

export type TimeUnit = typeof TimeUnit[keyof typeof TimeUnit];


/**
 * window operation for segmentation. Tells that event should be triggered each timeunit (each day, for instance) {   \"time\": {     \"type\": \"each\",     \"unit\":\"day\"   } } 
 * @export
 * @interface TimeWindowEach
 */
export interface TimeWindowEach {
    /**
     * 
     * @type {string}
     * @memberof TimeWindowEach
     */
    'type': TimeWindowEachTypeEnum;
    /**
     * 
     * @type {TimeUnit}
     * @memberof TimeWindowEach
     */
    'unit': TimeUnit;
}

export const TimeWindowEachTypeEnum = {
    WindowEach: 'windowEach'
} as const;

export type TimeWindowEachTypeEnum = typeof TimeWindowEachTypeEnum[keyof typeof TimeWindowEachTypeEnum];

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'createdBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'updatedBy'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'role'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof User
     */
    'teams'?: Array<number>;
    /**
     * 
     * @type {Array<UserProjects>}
     * @memberof User
     */
    'projects'?: Array<UserProjects>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface UserProjects
 */
export interface UserProjects {
    /**
     * 
     * @type {number}
     * @memberof UserProjects
     */
    'projectId'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserProjects
     */
    'role'?: string;
}
/**
 * @type Value
 * value
 * @export
 */
export type Value = boolean | number | string;


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Event custom properties list
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomProperties: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getCustomProperties', 'projectId', projectId)
            const localVarPath = `/v1/projects/{project_id}/schema/custom-properties`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Events list
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getEvents', 'projectId', projectId)
            const localVarPath = `/v1/projects/{project_id}/schema/events`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Properties list
         * @param {string} projectId Project ID
         * @param {'event' | 'user'} type Property type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProperties: async (projectId: string, type: 'event' | 'user', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProperties', 'projectId', projectId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getProperties', 'type', type)
            const localVarPath = `/v1/projects/{project_id}/schema/properties`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * for event property you should include event_name and event_type <br/><br/> examples: <br/> /v1/projects/1/data/property-values?event_name=Buy%20Product&event_type=regular&property_name=Name&property_type=regular /v1/projects/1/data/property-values?event_name=Buy%20Product&event_type=regular&property_name=Total%20Revenue&property_type=custom /v1/projects/1/data/property-values?event_name=Custom&event_type=custom&property_name=SomeProp&property_type=regular /v1/projects/1/data/property-values?property_name=Country&property_type=regular /v1/projects/1/data/property-values?property_name=Full%Name&property_type=custom 
         * @summary List property values
         * @param {string} projectId Project ID
         * @param {string} [eventName] Event Name. Required if property has event type
         * @param {EventType} [eventType] Event Type. Required if property has event type
         * @param {string} [propertyName] Property Name
         * @param {PropertyType} [propertyType] Property Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyValues: async (projectId: string, eventName?: string, eventType?: EventType, propertyName?: string, propertyType?: PropertyType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getPropertyValues', 'projectId', projectId)
            const localVarPath = `/v1/projects/{project_id}/data/property-values`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eventName !== undefined) {
                localVarQueryParameter['event_name'] = eventName;
            }

            if (eventType !== undefined) {
                localVarQueryParameter['event_type'] = eventType;
            }

            if (propertyName !== undefined) {
                localVarQueryParameter['property_name'] = propertyName;
            }

            if (propertyType !== undefined) {
                localVarQueryParameter['property_type'] = propertyType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Custom events list
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getustomEvents: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getustomEvents', 'projectId', projectId)
            const localVarPath = `/v1/projects/{project_id}/schema/custom-events`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create custom event
         * @param {string} projectId Project ID
         * @param {CreateCustomEventRequest} createCustomEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomEvent: async (projectId: string, createCustomEventRequest: CreateCustomEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('postCustomEvent', 'projectId', projectId)
            // verify required parameter 'createCustomEventRequest' is not null or undefined
            assertParamExists('postCustomEvent', 'createCustomEventRequest', createCustomEventRequest)
            const localVarPath = `/v1/projects/{project_id}/schema/custom-events`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCustomEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Events list
         * @param {string} projectId Project ID
         * @param {EventListRequest} eventListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postEventsStream: async (projectId: string, eventListRequest: EventListRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('postEventsStream', 'projectId', projectId)
            // verify required parameter 'eventListRequest' is not null or undefined
            assertParamExists('postEventsStream', 'eventListRequest', eventListRequest)
            const localVarPath = `/v1/projects/{project_id}/data/events-stream`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventListRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Event custom properties list
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomProperties(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object & ListResponseMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomProperties(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Events list
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object & ListResponseMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Properties list
         * @param {string} projectId Project ID
         * @param {'event' | 'user'} type Property type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProperties(projectId: string, type: 'event' | 'user', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object & ListResponseMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProperties(projectId, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * for event property you should include event_name and event_type <br/><br/> examples: <br/> /v1/projects/1/data/property-values?event_name=Buy%20Product&event_type=regular&property_name=Name&property_type=regular /v1/projects/1/data/property-values?event_name=Buy%20Product&event_type=regular&property_name=Total%20Revenue&property_type=custom /v1/projects/1/data/property-values?event_name=Custom&event_type=custom&property_name=SomeProp&property_type=regular /v1/projects/1/data/property-values?property_name=Country&property_type=regular /v1/projects/1/data/property-values?property_name=Full%Name&property_type=custom 
         * @summary List property values
         * @param {string} projectId Project ID
         * @param {string} [eventName] Event Name. Required if property has event type
         * @param {EventType} [eventType] Event Type. Required if property has event type
         * @param {string} [propertyName] Property Name
         * @param {PropertyType} [propertyType] Property Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPropertyValues(projectId: string, eventName?: string, eventType?: EventType, propertyName?: string, propertyType?: PropertyType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPropertyValues(projectId, eventName, eventType, propertyName, propertyType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Custom events list
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getustomEvents(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object & ListResponseMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getustomEvents(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create custom event
         * @param {string} projectId Project ID
         * @param {CreateCustomEventRequest} createCustomEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCustomEvent(projectId: string, createCustomEventRequest: CreateCustomEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCustomEvent(projectId, createCustomEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Events list
         * @param {string} projectId Project ID
         * @param {EventListRequest} eventListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postEventsStream(projectId: string, eventListRequest: EventListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object & ListResponseMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postEventsStream(projectId, eventListRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Event custom properties list
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomProperties(projectId: string, options?: any): AxiosPromise<object & ListResponseMetadata> {
            return localVarFp.getCustomProperties(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Events list
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(projectId: string, options?: any): AxiosPromise<object & ListResponseMetadata> {
            return localVarFp.getEvents(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Properties list
         * @param {string} projectId Project ID
         * @param {'event' | 'user'} type Property type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProperties(projectId: string, type: 'event' | 'user', options?: any): AxiosPromise<object & ListResponseMetadata> {
            return localVarFp.getProperties(projectId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * for event property you should include event_name and event_type <br/><br/> examples: <br/> /v1/projects/1/data/property-values?event_name=Buy%20Product&event_type=regular&property_name=Name&property_type=regular /v1/projects/1/data/property-values?event_name=Buy%20Product&event_type=regular&property_name=Total%20Revenue&property_type=custom /v1/projects/1/data/property-values?event_name=Custom&event_type=custom&property_name=SomeProp&property_type=regular /v1/projects/1/data/property-values?property_name=Country&property_type=regular /v1/projects/1/data/property-values?property_name=Full%Name&property_type=custom 
         * @summary List property values
         * @param {string} projectId Project ID
         * @param {string} [eventName] Event Name. Required if property has event type
         * @param {EventType} [eventType] Event Type. Required if property has event type
         * @param {string} [propertyName] Property Name
         * @param {PropertyType} [propertyType] Property Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyValues(projectId: string, eventName?: string, eventType?: EventType, propertyName?: string, propertyType?: PropertyType, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.getPropertyValues(projectId, eventName, eventType, propertyName, propertyType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Custom events list
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getustomEvents(projectId: string, options?: any): AxiosPromise<object & ListResponseMetadata> {
            return localVarFp.getustomEvents(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create custom event
         * @param {string} projectId Project ID
         * @param {CreateCustomEventRequest} createCustomEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomEvent(projectId: string, createCustomEventRequest: CreateCustomEventRequest, options?: any): AxiosPromise<CustomEvent> {
            return localVarFp.postCustomEvent(projectId, createCustomEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Events list
         * @param {string} projectId Project ID
         * @param {EventListRequest} eventListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postEventsStream(projectId: string, eventListRequest: EventListRequest, options?: any): AxiosPromise<object & ListResponseMetadata> {
            return localVarFp.postEventsStream(projectId, eventListRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Event custom properties list
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCustomProperties(projectId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCustomProperties(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Events list
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEvents(projectId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getEvents(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Properties list
     * @param {string} projectId Project ID
     * @param {'event' | 'user'} type Property type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProperties(projectId: string, type: 'event' | 'user', options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProperties(projectId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * for event property you should include event_name and event_type <br/><br/> examples: <br/> /v1/projects/1/data/property-values?event_name=Buy%20Product&event_type=regular&property_name=Name&property_type=regular /v1/projects/1/data/property-values?event_name=Buy%20Product&event_type=regular&property_name=Total%20Revenue&property_type=custom /v1/projects/1/data/property-values?event_name=Custom&event_type=custom&property_name=SomeProp&property_type=regular /v1/projects/1/data/property-values?property_name=Country&property_type=regular /v1/projects/1/data/property-values?property_name=Full%Name&property_type=custom 
     * @summary List property values
     * @param {string} projectId Project ID
     * @param {string} [eventName] Event Name. Required if property has event type
     * @param {EventType} [eventType] Event Type. Required if property has event type
     * @param {string} [propertyName] Property Name
     * @param {PropertyType} [propertyType] Property Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPropertyValues(projectId: string, eventName?: string, eventType?: EventType, propertyName?: string, propertyType?: PropertyType, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPropertyValues(projectId, eventName, eventType, propertyName, propertyType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Custom events list
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getustomEvents(projectId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getustomEvents(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create custom event
     * @param {string} projectId Project ID
     * @param {CreateCustomEventRequest} createCustomEventRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postCustomEvent(projectId: string, createCustomEventRequest: CreateCustomEventRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postCustomEvent(projectId, createCustomEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Events list
     * @param {string} projectId Project ID
     * @param {EventListRequest} eventListRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postEventsStream(projectId: string, eventListRequest: EventListRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postEventsStream(projectId, eventListRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


