struct Column(Vec<i64>);

struct RecordBatch(Vec<Column>);

struct Funnel {}

impl Funnel {
    fn new(seq: Vec<usize>) -> Self {
        unimplemented!()
    }

    fn push(&mut self, batch: RecordBatch) -> Option<Vec<bool>> {
        unimplemented!()
    }
    fn finalize(&self) -> bool {
        unimplemented!()
    }
}

// Определения:
// Колонка — набор значений одного типа (Column)
// Батч — набор колонок одинакового размера (RecordBatch)
// Партиция - часть данных, объединённая одним значением ключа. В примере - 1,2,3,4
// Ключ — значения из первой колонки
// Значение — значения из второй колонки, В примере - 1,2,3,1,2,3,...
// Последовательность - требуемая последовательность значений в заданном порядке
// Последовательность задана как: 1,2,3
// Между искомыми значениями могут встречаться произвольные значения
//
// Задача:
// Для каждой партиции считать true, если последовательность найдена, иначе false
// Учиывать то, что партиции (и значения) могут содержаться в разных батчах
// Решение должно быть stateful. То есть каждый раз, когда батч "пушится", должен
// возвращаться результат посчитанных партиций, либо None
// Метод finalize возвращает последний результат, если он есть, либо false
// Следует также учесть, что в реальности может быть произвольное количество батчей
//
// Пример ([партиция],[значения]):
// Найденная партиция: [1,1,1],[1,2,3]
// Найденная партиция: [1,1,1,1],[1,2,4,3]
// Не найденная партиция: [1,1,1],[1,3,2]
// Не найденная партиция: [1,1],[1,2]

#[cfg(test)]
mod tests {
    use crate::Column;
    use crate::Funnel;
    use crate::RecordBatch;

    #[test]
    fn it_works() {
        let mut funnel = Funnel::new(vec![1, 2, 3]);

        let b1 = RecordBatch(vec![
            Column(vec![1, 1, 1, 2, 2]),
            Column(vec![1, 2, 3, 1, 2]),
        ]);

        let res = funnel.push(b1);
        // партиция 1 найдена, результат партиции 2 ещё не определён
        assert_eq!(Some(vec![true]), res);

        let b2 = RecordBatch(vec![
            Column(vec![2, 3, 3, 3, 3, 3, 4]),
            Column(vec![3, 1, 2, 1, 4, 3, 1]),
        ]);

        let res = funnel.push(b2);
        // партиция 2 собрана из двух батчей и найдена, также найдена партиция 3
        assert_eq!(Some(vec![true, true]), res);

        let b3 = RecordBatch(vec![Column(vec![4]), Column(vec![2])]);
        // поскольку в батче только одна партиция, мы не можем знать, есть ли она дальше
        // в батчах, поэтому возвращаем None
        assert_eq!(None, res);

        let res = funnel.finalize();
        // финализируем результат, то есть вычисляем результат 4й прартиции. 4 партиция не имеет
        // полной последовательности, поэтому falsr
        assert_eq!(false, res);
    }
}
