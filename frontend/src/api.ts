/* tslint:disable */
/* eslint-disable */
/**
 * OptiPrism
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api@optiprism.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    updatedAt?: string;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    createdBy?: number;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    updatedBy?: number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    role?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof Account
     */
    teams?: Array<number>;
    /**
     * 
     * @type {Array<AccountProjects>}
     * @memberof Account
     */
    projects?: Array<AccountProjects>;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface AccountProjects
 */
export interface AccountProjects {
    /**
     * 
     * @type {number}
     * @memberof AccountProjects
     */
    projectId?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountProjects
     */
    role?: string;
}
/**
 * 
 * @export
 * @interface AnalysisCumulative
 */
export interface AnalysisCumulative {
    /**
     * 
     * @type {string}
     * @memberof AnalysisCumulative
     */
    type?: AnalysisCumulativeTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum AnalysisCumulativeTypeEnum {
    Cumulative = 'cumulative'
}

/**
 * 
 * @export
 * @interface AnalysisLinear
 */
export interface AnalysisLinear {
    /**
     * 
     * @type {string}
     * @memberof AnalysisLinear
     */
    type?: AnalysisLinearTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum AnalysisLinearTypeEnum {
    Linear = 'linear'
}

/**
 * 
 * @export
 * @interface AnalysisRollingAverage
 */
export interface AnalysisRollingAverage {
    /**
     * 
     * @type {string}
     * @memberof AnalysisRollingAverage
     */
    type?: AnalysisRollingAverageTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof AnalysisRollingAverage
     */
    window?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum AnalysisRollingAverageTypeEnum {
    RollingAverage = 'rollingAverage'
}

/**
 * 
 * @export
 * @interface AnalysisRollingWindow
 */
export interface AnalysisRollingWindow {
    /**
     * 
     * @type {string}
     * @memberof AnalysisRollingWindow
     */
    type?: AnalysisRollingWindowTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof AnalysisRollingWindow
     */
    window?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum AnalysisRollingWindowTypeEnum {
    RollingWindow = 'rollingWindow'
}

/**
 * breakdown by property.
 * @export
 * @interface BreakdownByProperty
 */
export interface BreakdownByProperty {
    /**
     * 
     * @type {string}
     * @memberof BreakdownByProperty
     */
    type?: BreakdownByPropertyTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof BreakdownByProperty
     */
    propertyName?: string;
    /**
     * 
     * @type {string}
     * @memberof BreakdownByProperty
     */
    propertyType: BreakdownByPropertyPropertyTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof BreakdownByProperty
     */
    propertyId?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum BreakdownByPropertyTypeEnum {
    Property = 'property'
}
/**
    * @export
    * @enum {string}
    */
export enum BreakdownByPropertyPropertyTypeEnum {
    Custom = 'custom',
    Event = 'event',
    User = 'user'
}

/**
 * Custom Event is an alias to an expression which is used while querying. You can use regular or custom events in expression. You can combine events in expression, you can use filter by properties.
 * @export
 * @interface CreateCustomEventRequest
 */
export interface CreateCustomEventRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCustomEventRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomEventRequest
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateCustomEventRequest
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Array<CustomEventEvent>}
     * @memberof CreateCustomEventRequest
     */
    events: Array<CustomEventEvent>;
}
/**
 * 
 * @export
 * @interface CreateDashboardRequest
 */
export interface CreateDashboardRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateDashboardRequest
     */
    tags?: Array<string>;
    /**
     * dashboard name
     * @type {string}
     * @memberof CreateDashboardRequest
     */
    name?: string;
    /**
     * description
     * @type {string}
     * @memberof CreateDashboardRequest
     */
    description?: string;
    /**
     * 
     * @type {Array<CreateDashboardRequestRows>}
     * @memberof CreateDashboardRequest
     */
    rows?: Array<CreateDashboardRequestRows>;
}
/**
 * 
 * @export
 * @interface CreateDashboardRequestPanels
 */
export interface CreateDashboardRequestPanels {
    /**
     * span
     * @type {number}
     * @memberof CreateDashboardRequestPanels
     */
    span?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateDashboardRequestPanels
     */
    type?: CreateDashboardRequestPanelsTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof CreateDashboardRequestPanels
     */
    reportId?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateDashboardRequestPanelsTypeEnum {
    Report = 'report'
}

/**
 * 
 * @export
 * @interface CreateDashboardRequestRows
 */
export interface CreateDashboardRequestRows {
    /**
     * 
     * @type {Array<CreateDashboardRequestPanels>}
     * @memberof CreateDashboardRequestRows
     */
    panels?: Array<CreateDashboardRequestPanels>;
}
/**
 * 
 * @export
 * @interface CreateReportRequest
 */
export interface CreateReportRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateReportRequest
     */
    tags?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateReportRequest
     */
    name?: string;
    /**
     * description
     * @type {string}
     * @memberof CreateReportRequest
     */
    description?: string;
    /**
     * 
     * @type {object & EventSegmentation | FunnelQuery}
     * @memberof CreateReportRequest
     */
    report?: object & EventSegmentation | FunnelQuery;
}
/**
 * Custom Event is an alias to an expression which is used while querying. You can use regular or custom events in expression. You can combine events in expression, you can use filter by properties.
 * @export
 * @interface CustomEvent
 */
export interface CustomEvent {
    /**
     * 
     * @type {number}
     * @memberof CustomEvent
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof CustomEvent
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof CustomEvent
     */
    updatedAt?: string;
    /**
     * 
     * @type {number}
     * @memberof CustomEvent
     */
    createdBy: number;
    /**
     * 
     * @type {number}
     * @memberof CustomEvent
     */
    updatedBy?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomEvent
     */
    projectId: number;
    /**
     * 
     * @type {boolean}
     * @memberof CustomEvent
     */
    isSystem: boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomEvent
     */
    status: CustomEventStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CustomEvent
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CustomEvent
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CustomEvent
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Array<CustomEventEvent>}
     * @memberof CustomEvent
     */
    events?: Array<CustomEventEvent>;
}

/**
    * @export
    * @enum {string}
    */
export enum CustomEventStatusEnum {
    Enabled = 'enabled',
    Disabled = 'disabled'
}

/**
 * custom event will matches all of the provided events
 * @export
 * @interface CustomEventEvent
 */
export interface CustomEventEvent {
    /**
     * 
     * @type {string}
     * @memberof CustomEventEvent
     */
    eventName?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomEventEvent
     */
    eventType: CustomEventEventEventTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof CustomEventEvent
     */
    eventId?: number;
    /**
     * array of event filters
     * @type {Array<EventFilterByProperty>}
     * @memberof CustomEventEvent
     */
    filters: Array<EventFilterByProperty>;
}

/**
    * @export
    * @enum {string}
    */
export enum CustomEventEventEventTypeEnum {
    Custom = 'custom'
}

/**
 * 
 * @export
 * @interface CustomEventEventAllOf
 */
export interface CustomEventEventAllOf {
    /**
     * array of event filters
     * @type {Array<EventFilterByProperty>}
     * @memberof CustomEventEventAllOf
     */
    filters?: Array<EventFilterByProperty>;
}
/**
 * 
 * @export
 * @interface CustomProperty
 */
export interface CustomProperty {
    /**
     * 
     * @type {number}
     * @memberof CustomProperty
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomProperty
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomProperty
     */
    updatedAt?: string;
    /**
     * 
     * @type {number}
     * @memberof CustomProperty
     */
    createdBy?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomProperty
     */
    updatedBy?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomProperty
     */
    projectId?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof CustomProperty
     */
    events?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof CustomProperty
     */
    isSystem?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomProperty
     */
    status?: CustomPropertyStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CustomProperty
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomProperty
     */
    description?: string;
    /**
     * 
     * @type {DataType}
     * @memberof CustomProperty
     */
    type?: DataType;
    /**
     * 
     * @type {boolean}
     * @memberof CustomProperty
     */
    nullable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomProperty
     */
    isArray?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CustomProperty
     */
    tags?: Array<string>;
}

/**
    * @export
    * @enum {string}
    */
export enum CustomPropertyStatusEnum {
    Enabled = 'enabled',
    Disabled = 'disabled'
}

/**
 * 
 * @export
 * @interface Dashboard
 */
export interface Dashboard {
    /**
     * dashboard unique id
     * @type {number}
     * @memberof Dashboard
     */
    id?: number;
    /**
     * create date
     * @type {string}
     * @memberof Dashboard
     */
    createdAt?: string;
    /**
     * update (once updated)
     * @type {string}
     * @memberof Dashboard
     */
    updatedAt?: string;
    /**
     * id of creator User
     * @type {number}
     * @memberof Dashboard
     */
    createdBy?: number;
    /**
     * id of updater User
     * @type {number}
     * @memberof Dashboard
     */
    updatedBy?: number;
    /**
     * project id
     * @type {number}
     * @memberof Dashboard
     */
    projectId?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Dashboard
     */
    tags?: Array<string>;
    /**
     * event name. Must be unique among all project events (including custom). The name field is used while events ingesting.
     * @type {string}
     * @memberof Dashboard
     */
    name?: string;
    /**
     * description
     * @type {string}
     * @memberof Dashboard
     */
    description?: string;
    /**
     * 
     * @type {Array<DashboardRows>}
     * @memberof Dashboard
     */
    rows?: Array<DashboardRows>;
}
/**
 * 
 * @export
 * @interface DashboardPanels
 */
export interface DashboardPanels {
    /**
     * project id
     * @type {number}
     * @memberof DashboardPanels
     */
    span?: number;
    /**
     * 
     * @type {string}
     * @memberof DashboardPanels
     */
    type?: DashboardPanelsTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof DashboardPanels
     */
    reportId?: number;
    /**
     * 
     * @type {Report}
     * @memberof DashboardPanels
     */
    report?: Report;
}

/**
    * @export
    * @enum {string}
    */
export enum DashboardPanelsTypeEnum {
    Report = 'report'
}

/**
 * 
 * @export
 * @interface DashboardRows
 */
export interface DashboardRows {
    /**
     * 
     * @type {Array<DashboardPanels>}
     * @memberof DashboardRows
     */
    panels?: Array<DashboardPanels>;
}
/**
 * 
 * @export
 * @interface DataTableResponse
 */
export interface DataTableResponse {
    /**
     * 
     * @type {Array<DataTableResponseColumns>}
     * @memberof DataTableResponse
     */
    columns?: Array<DataTableResponseColumns>;
}
/**
 * 
 * @export
 * @interface DataTableResponseColumns
 */
export interface DataTableResponseColumns {
    /**
     * 
     * @type {string}
     * @memberof DataTableResponseColumns
     */
    type?: DataTableResponseColumnsTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof DataTableResponseColumns
     */
    step?: number;
    /**
     * 
     * @type {DataType}
     * @memberof DataTableResponseColumns
     */
    dataType?: DataType;
    /**
     * 
     * @type {string}
     * @memberof DataTableResponseColumns
     */
    name?: string;
    /**
     * 
     * @type {Array<string> | Array<number> | Array<boolean>}
     * @memberof DataTableResponseColumns
     */
    values?: Array<string> | Array<number> | Array<boolean>;
    /**
     * 
     * @type {Array<string> | Array<number> | Array<boolean>}
     * @memberof DataTableResponseColumns
     */
    compareValues?: Array<string> | Array<number> | Array<boolean>;
}

/**
    * @export
    * @enum {string}
    */
export enum DataTableResponseColumnsTypeEnum {
    Dimension = 'dimension',
    Metric = 'metric',
    MetricValue = 'metricValue',
    FunnelMetricValue = 'funnelMetricValue'
}

/**
 * data type
 * @export
 * @enum {string}
 */
export enum DataType {
    String = 'string',
    Number = 'number',
    Boolean = 'boolean'
}

/**
 * aggregate property and compare to value
 * @export
 * @interface DidEventAggregateProperty
 */
export interface DidEventAggregateProperty {
    /**
     * 
     * @type {string}
     * @memberof DidEventAggregateProperty
     */
    type: DidEventAggregatePropertyTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DidEventAggregateProperty
     */
    propertyName?: string;
    /**
     * 
     * @type {string}
     * @memberof DidEventAggregateProperty
     */
    propertyType: DidEventAggregatePropertyPropertyTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof DidEventAggregateProperty
     */
    propertyId?: number;
    /**
     * 
     * @type {QueryAggregateProperty}
     * @memberof DidEventAggregateProperty
     */
    aggregate: QueryAggregateProperty;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof DidEventAggregateProperty
     */
    operation: PropertyFilterOperation;
    /**
     * one or more values. Doesn\'t need if operation is \"empty\" or \"exist\"
     * @type {number}
     * @memberof DidEventAggregateProperty
     */
    value?: number;
    /**
     * time frame
     * @type {TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach}
     * @memberof DidEventAggregateProperty
     */
    time: TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach;
}

/**
    * @export
    * @enum {string}
    */
export enum DidEventAggregatePropertyTypeEnum {
    AggregateProperty = 'aggregateProperty'
}
/**
    * @export
    * @enum {string}
    */
export enum DidEventAggregatePropertyPropertyTypeEnum {
    Custom = 'custom',
    Event = 'event',
    User = 'user'
}

/**
 * 
 * @export
 * @interface DidEventAggregatePropertyAllOf
 */
export interface DidEventAggregatePropertyAllOf {
    /**
     * 
     * @type {string}
     * @memberof DidEventAggregatePropertyAllOf
     */
    type?: DidEventAggregatePropertyAllOfTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum DidEventAggregatePropertyAllOfTypeEnum {
    AggregateProperty = 'aggregateProperty'
}

/**
 * 
 * @export
 * @interface DidEventAggregatePropertyAllOf1
 */
export interface DidEventAggregatePropertyAllOf1 {
    /**
     * 
     * @type {QueryAggregateProperty}
     * @memberof DidEventAggregatePropertyAllOf1
     */
    aggregate?: QueryAggregateProperty;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof DidEventAggregatePropertyAllOf1
     */
    operation?: PropertyFilterOperation;
    /**
     * one or more values. Doesn\'t need if operation is \"empty\" or \"exist\"
     * @type {number}
     * @memberof DidEventAggregatePropertyAllOf1
     */
    value?: number;
    /**
     * time frame
     * @type {TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach}
     * @memberof DidEventAggregatePropertyAllOf1
     */
    time?: TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach;
}
/**
 * find all users who made event X times
 * @export
 * @interface DidEventCount
 */
export interface DidEventCount {
    /**
     * 
     * @type {string}
     * @memberof DidEventCount
     */
    type: DidEventCountTypeEnum;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof DidEventCount
     */
    operation: PropertyFilterOperation;
    /**
     * one or more values. Doesn\'t need if operation is \"empty\" or \"exist\"
     * @type {number}
     * @memberof DidEventCount
     */
    value?: number;
    /**
     * time frame
     * @type {TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach}
     * @memberof DidEventCount
     */
    time: TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach;
}

/**
    * @export
    * @enum {string}
    */
export enum DidEventCountTypeEnum {
    DidEventCount = 'didEventCount'
}

/**
 * find users with Nth event occurance
 * @export
 * @interface DidEventHistoricalCount
 */
export interface DidEventHistoricalCount {
    /**
     * 
     * @type {string}
     * @memberof DidEventHistoricalCount
     */
    type: DidEventHistoricalCountTypeEnum;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof DidEventHistoricalCount
     */
    operation: PropertyFilterOperation;
    /**
     * 
     * @type {number}
     * @memberof DidEventHistoricalCount
     */
    value?: number;
    /**
     * 
     * @type {TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach}
     * @memberof DidEventHistoricalCount
     */
    time: TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach;
}

/**
    * @export
    * @enum {string}
    */
export enum DidEventHistoricalCountTypeEnum {
    HistoricalCount = 'historicalCount'
}

/**
 * find all users who made left event X time more/less than right event.
 * @export
 * @interface DidEventRelativeCount
 */
export interface DidEventRelativeCount {
    /**
     * 
     * @type {string}
     * @memberof DidEventRelativeCount
     */
    type: DidEventRelativeCountTypeEnum;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof DidEventRelativeCount
     */
    operation: PropertyFilterOperation;
    /**
     * 
     * @type {EventRef}
     * @memberof DidEventRelativeCount
     */
    rightEvent: EventRef;
    /**
     * 
     * @type {TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach}
     * @memberof DidEventRelativeCount
     */
    time: TimeBetween | TimeLast | TimeAfterFirstUse | TimeWindowEach;
}

/**
    * @export
    * @enum {string}
    */
export enum DidEventRelativeCountTypeEnum {
    DidEventRelativeCount = 'didEventRelativeCount'
}

/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    code?: ErrorResponseCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    message?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ErrorResponse
     */
    fields?: { [key: string]: string; };
}

/**
    * @export
    * @enum {string}
    */
export enum ErrorResponseCodeEnum {
    _1000InvalidToken = '1000_invalid_token'
}

/**
 * Event describes user event. User event is an action which user (client) might do on a product site/app. For instance, user might do a signup and it might be a \"Sign up\" event. Event Also has a properties. <br/><br/> Name must be unique among project events, including custom ones. E.g. you can\'t have multiple \"Sign up\" events. <br/><br/> Normally events are created and updated by admin in a project scope, but there are also system events, which can\'t be deleted or modified.
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * event unique id
     * @type {number}
     * @memberof Event
     */
    id: number;
    /**
     * create date
     * @type {string}
     * @memberof Event
     */
    createdAt: string;
    /**
     * update (once updated)
     * @type {string}
     * @memberof Event
     */
    updatedAt?: string;
    /**
     * id of creator User
     * @type {number}
     * @memberof Event
     */
    createdBy: number;
    /**
     * id of updater User
     * @type {number}
     * @memberof Event
     */
    updatedBy?: number;
    /**
     * project id
     * @type {number}
     * @memberof Event
     */
    projectId: number;
    /**
     * the event is a system-wide, shown in any project and can\'t be modified by a regular user
     * @type {boolean}
     * @memberof Event
     */
    isSystem: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Event
     */
    tags?: Array<string>;
    /**
     * event name. Must be unique among all project events (including custom). The name field is used while events ingesting.
     * @type {string}
     * @memberof Event
     */
    name: string;
    /**
     * event name to display. If empty then name property is used.
     * @type {string}
     * @memberof Event
     */
    displayName?: string;
    /**
     * description
     * @type {string}
     * @memberof Event
     */
    description?: string;
    /**
     * event status
     * @type {string}
     * @memberof Event
     */
    status: EventStatusEnum;
    /**
     * array of id of attached to event properties
     * @type {Array<number>}
     * @memberof Event
     */
    eventProperties?: Array<number>;
    /**
     * array of id of attached to user properties
     * @type {Array<number>}
     * @memberof Event
     */
    userProperties?: Array<number>;
}

/**
    * @export
    * @enum {string}
    */
export enum EventStatusEnum {
    Enabled = 'enabled',
    Disabled = 'disabled'
}

/**
 * chart type
 * @export
 * @enum {string}
 */
export enum EventChartType {
    Line = 'line',
    Bar = 'bar',
    SingleValue = 'singleValue'
}

/**
 * 
 * @export
 * @interface EventFilterByCohort
 */
export interface EventFilterByCohort {
    /**
     * 
     * @type {string}
     * @memberof EventFilterByCohort
     */
    type?: EventFilterByCohortTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EventFilterByCohort
     */
    cohortId?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum EventFilterByCohortTypeEnum {
    Cohort = 'cohort'
}

/**
 * 
 * @export
 * @interface EventFilterByGroup
 */
export interface EventFilterByGroup {
    /**
     * 
     * @type {string}
     * @memberof EventFilterByGroup
     */
    type?: EventFilterByGroupTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EventFilterByGroup
     */
    groupId?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum EventFilterByGroupTypeEnum {
    Group = 'group'
}

/**
 * filter by property
 * @export
 * @interface EventFilterByProperty
 */
export interface EventFilterByProperty {
    /**
     * 
     * @type {string}
     * @memberof EventFilterByProperty
     */
    type?: EventFilterByPropertyTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof EventFilterByProperty
     */
    propertyName?: string;
    /**
     * 
     * @type {string}
     * @memberof EventFilterByProperty
     */
    propertyType: EventFilterByPropertyPropertyTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EventFilterByProperty
     */
    propertyId?: number;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof EventFilterByProperty
     */
    operation: PropertyFilterOperation;
    /**
     * one or several property values. May be not set if operation is \"empty\" or \"exist\"
     * @type {Array<Value>}
     * @memberof EventFilterByProperty
     */
    value?: Array<Value>;
}

/**
    * @export
    * @enum {string}
    */
export enum EventFilterByPropertyTypeEnum {
    Property = 'property'
}
/**
    * @export
    * @enum {string}
    */
export enum EventFilterByPropertyPropertyTypeEnum {
    Custom = 'custom',
    Event = 'event',
    User = 'user'
}

/**
 * 
 * @export
 * @interface EventFilterByPropertyAllOf
 */
export interface EventFilterByPropertyAllOf {
    /**
     * 
     * @type {string}
     * @memberof EventFilterByPropertyAllOf
     */
    type?: EventFilterByPropertyAllOfTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum EventFilterByPropertyAllOfTypeEnum {
    Property = 'property'
}

/**
 * 
 * @export
 * @interface EventFilterByPropertyAllOf1
 */
export interface EventFilterByPropertyAllOf1 {
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof EventFilterByPropertyAllOf1
     */
    operation?: PropertyFilterOperation;
    /**
     * one or several property values. May be not set if operation is \"empty\" or \"exist\"
     * @type {Array<Value>}
     * @memberof EventFilterByPropertyAllOf1
     */
    value?: Array<Value>;
}
/**
 * event filters
 * @export
 * @interface EventFilters
 */
export interface EventFilters {
    /**
     * 
     * @type {string}
     * @memberof EventFilters
     */
    groupsCondition?: EventFiltersGroupsConditionEnum;
    /**
     * 
     * @type {Array<EventFiltersGroups>}
     * @memberof EventFilters
     */
    groups?: Array<EventFiltersGroups>;
}

/**
    * @export
    * @enum {string}
    */
export enum EventFiltersGroupsConditionEnum {
    And = 'and',
    Or = 'or'
}

/**
 * 
 * @export
 * @interface EventFiltersGroups
 */
export interface EventFiltersGroups {
    /**
     * 
     * @type {string}
     * @memberof EventFiltersGroups
     */
    filtersCondition?: EventFiltersGroupsFiltersConditionEnum;
    /**
     * 
     * @type {Array<EventFilterByCohort | EventFilterByProperty | EventFilterByGroup>}
     * @memberof EventFiltersGroups
     */
    filters?: Array<EventFilterByCohort | EventFilterByProperty | EventFilterByGroup>;
}

/**
    * @export
    * @enum {string}
    */
export enum EventFiltersGroupsFiltersConditionEnum {
    And = 'and',
    Or = 'or'
}

/**
 * event query
 * @export
 * @interface EventQuery
 */
export interface EventQuery {
    /**
     * 
     * @type {string}
     * @memberof EventQuery
     */
    name?: string;
    /**
     * 
     * @type {QuerySimple | QueryCountPerGroup | QueryAggregatePropertyPerGroup | QueryAggregateProperty | QueryFormula}
     * @memberof EventQuery
     */
    query: QuerySimple | QueryCountPerGroup | QueryAggregatePropertyPerGroup | QueryAggregateProperty | QueryFormula;
}
/**
 * 
 * @export
 * @interface EventRecord
 */
export interface EventRecord {
    /**
     * 
     * @type {number}
     * @memberof EventRecord
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof EventRecord
     */
    name?: string;
    /**
     * map of property name and property value pairs
     * @type {object}
     * @memberof EventRecord
     */
    properties?: object;
    /**
     * map of user name and property value pairs
     * @type {object}
     * @memberof EventRecord
     */
    userProperties?: object;
    /**
     * 
     * @type {Array<EventRecordMatchedCustomEvents>}
     * @memberof EventRecord
     */
    matchedCustomEvents?: Array<EventRecordMatchedCustomEvents>;
}
/**
 * 
 * @export
 * @interface EventRecordMatchedCustomEvents
 */
export interface EventRecordMatchedCustomEvents {
    /**
     * 
     * @type {number}
     * @memberof EventRecordMatchedCustomEvents
     */
    id?: number;
}
/**
 * request event records sorted by time of creation
 * @export
 * @interface EventRecordsListRequest
 */
export interface EventRecordsListRequest {
    /**
     * select time
     * @type {TimeBetween | TimeFrom | TimeLast}
     * @memberof EventRecordsListRequest
     */
    time: TimeBetween | TimeFrom | TimeLast;
    /**
     * group that is used in aggregations by group. For instance, group by user or group by organization.
     * @type {string}
     * @memberof EventRecordsListRequest
     */
    group?: string;
    /**
     * 
     * @type {EventRecordsListRequestSearch}
     * @memberof EventRecordsListRequest
     */
    search?: EventRecordsListRequestSearch;
    /**
     * array of events to query
     * @type {Array<EventRef & object>}
     * @memberof EventRecordsListRequest
     */
    events?: Array<EventRef & object>;
    /**
     * 
     * @type {EventFilters}
     * @memberof EventRecordsListRequest
     */
    filters?: EventFilters;
}
/**
 * search in results
 * @export
 * @interface EventRecordsListRequestSearch
 */
export interface EventRecordsListRequestSearch {
    /**
     * 
     * @type {string}
     * @memberof EventRecordsListRequestSearch
     */
    term?: string;
    /**
     * 
     * @type {Array<string | number>}
     * @memberof EventRecordsListRequestSearch
     */
    inEventProperties?: Array<string | number>;
    /**
     * 
     * @type {Array<string | number>}
     * @memberof EventRecordsListRequestSearch
     */
    inUserProperties?: Array<string | number>;
}
/**
 * @type EventRef
 * reference to event by its name and type
 * @export
 */
export type EventRef = EventRefOneOf | EventRefOneOf1;

/**
 * 
 * @export
 * @interface EventRefOneOf
 */
export interface EventRefOneOf {
    /**
     * 
     * @type {string}
     * @memberof EventRefOneOf
     */
    eventName?: string;
    /**
     * 
     * @type {string}
     * @memberof EventRefOneOf
     */
    eventType?: EventRefOneOfEventTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum EventRefOneOfEventTypeEnum {
    Regular = 'regular'
}

/**
 * 
 * @export
 * @interface EventRefOneOf1
 */
export interface EventRefOneOf1 {
    /**
     * 
     * @type {number}
     * @memberof EventRefOneOf1
     */
    eventId?: number;
    /**
     * 
     * @type {string}
     * @memberof EventRefOneOf1
     */
    eventType?: EventRefOneOf1EventTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum EventRefOneOf1EventTypeEnum {
    Custom = 'custom'
}

/**
 * event segmentation report type main payload
 * @export
 * @interface EventSegmentation
 */
export interface EventSegmentation {
    /**
     * select time
     * @type {TimeBetween | TimeFrom | TimeLast}
     * @memberof EventSegmentation
     */
    time: TimeBetween | TimeFrom | TimeLast;
    /**
     * group that is used in aggregations by group. For instance, group by user or group by organizartion.
     * @type {string}
     * @memberof EventSegmentation
     */
    group: string;
    /**
     * 
     * @type {TimeUnit}
     * @memberof EventSegmentation
     */
    intervalUnit: TimeUnit;
    /**
     * 
     * @type {EventChartType}
     * @memberof EventSegmentation
     */
    chartType: EventChartType;
    /**
     * analysis type
     * @type {AnalysisLinear | AnalysisRollingAverage | AnalysisRollingWindow | AnalysisCumulative}
     * @memberof EventSegmentation
     */
    analysis: AnalysisLinear | AnalysisRollingAverage | AnalysisRollingWindow | AnalysisCumulative;
    /**
     * 
     * @type {EventSegmentationCompare}
     * @memberof EventSegmentation
     */
    compare?: EventSegmentationCompare;
    /**
     * array of events to query
     * @type {Array<EventSegmentationEvent>}
     * @memberof EventSegmentation
     */
    events: Array<EventSegmentationEvent>;
    /**
     * 
     * @type {EventFilters}
     * @memberof EventSegmentation
     */
    filters?: EventFilters;
    /**
     * array of common breakdowns (which applies to all events)
     * @type {Array<BreakdownByProperty>}
     * @memberof EventSegmentation
     */
    breakdowns?: Array<BreakdownByProperty>;
    /**
     * array of segments
     * @type {Array<EventSegmentationSegment>}
     * @memberof EventSegmentation
     */
    segments?: Array<EventSegmentationSegment>;
}
/**
 * optional comparison with previous period
 * @export
 * @interface EventSegmentationCompare
 */
export interface EventSegmentationCompare {
    /**
     * offset in past in timeUnit
     * @type {number}
     * @memberof EventSegmentationCompare
     */
    offset: number;
    /**
     * 
     * @type {TimeUnit}
     * @memberof EventSegmentationCompare
     */
    unit: TimeUnit;
}
/**
 * event object
 * @export
 * @interface EventSegmentationEvent
 */
export interface EventSegmentationEvent {
    /**
     * 
     * @type {string}
     * @memberof EventSegmentationEvent
     */
    eventName?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSegmentationEvent
     */
    eventType: EventSegmentationEventEventTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EventSegmentationEvent
     */
    eventId?: number;
    /**
     * array of event filters
     * @type {Array<EventFilterByProperty>}
     * @memberof EventSegmentationEvent
     */
    filters?: Array<EventFilterByProperty>;
    /**
     * 
     * @type {Array<BreakdownByProperty>}
     * @memberof EventSegmentationEvent
     */
    breakdowns?: Array<BreakdownByProperty>;
    /**
     * array of event queries
     * @type {Array<EventQuery>}
     * @memberof EventSegmentationEvent
     */
    queries: Array<EventQuery>;
}

/**
    * @export
    * @enum {string}
    */
export enum EventSegmentationEventEventTypeEnum {
    Custom = 'custom'
}

/**
 * 
 * @export
 * @interface EventSegmentationEventAllOf
 */
export interface EventSegmentationEventAllOf {
    /**
     * array of event filters
     * @type {Array<EventFilterByProperty>}
     * @memberof EventSegmentationEventAllOf
     */
    filters?: Array<EventFilterByProperty>;
    /**
     * 
     * @type {Array<BreakdownByProperty>}
     * @memberof EventSegmentationEventAllOf
     */
    breakdowns?: Array<BreakdownByProperty>;
    /**
     * array of event queries
     * @type {Array<EventQuery>}
     * @memberof EventSegmentationEventAllOf
     */
    queries?: Array<EventQuery>;
}
/**
 * segment
 * @export
 * @interface EventSegmentationSegment
 */
export interface EventSegmentationSegment {
    /**
     * name of segment
     * @type {string}
     * @memberof EventSegmentationSegment
     */
    name?: string;
    /**
     * array of conditions
     * @type {Array<SegmentCondition>}
     * @memberof EventSegmentationSegment
     */
    conditions: Array<SegmentCondition>;
}
/**
 * possible event type
 * @export
 * @enum {string}
 */
export enum EventType {
    Regular = 'regular',
    Custom = 'custom'
}

/**
 * 
 * @export
 * @interface FunnelConversionOverTimeChartType
 */
export interface FunnelConversionOverTimeChartType {
    /**
     * 
     * @type {string}
     * @memberof FunnelConversionOverTimeChartType
     */
    type?: FunnelConversionOverTimeChartTypeTypeEnum;
    /**
     * 
     * @type {TimeUnit}
     * @memberof FunnelConversionOverTimeChartType
     */
    intervalUnit?: TimeUnit;
}

/**
    * @export
    * @enum {string}
    */
export enum FunnelConversionOverTimeChartTypeTypeEnum {
    ConversionOverTime = 'conversionOverTime'
}

/**
 * 
 * @export
 * @interface FunnelConversionStepsChartType
 */
export interface FunnelConversionStepsChartType {
    /**
     * 
     * @type {string}
     * @memberof FunnelConversionStepsChartType
     */
    type?: FunnelConversionStepsChartTypeTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum FunnelConversionStepsChartTypeTypeEnum {
    ConversionSteps = 'conversionSteps'
}

/**
 * 
 * @export
 * @interface FunnelConversionStepsChartTypeResponse
 */
export interface FunnelConversionStepsChartTypeResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof FunnelConversionStepsChartTypeResponse
     */
    dimensionHeaders?: Array<string>;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof FunnelConversionStepsChartTypeResponse
     */
    dimensions?: Array<Array<string>>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FunnelConversionStepsChartTypeResponse
     */
    metrics?: Array<FunnelConversionStepsChartTypeResponseMetricsEnum>;
    /**
     * 
     * @type {Array<number>}
     * @memberof FunnelConversionStepsChartTypeResponse
     */
    singles?: Array<number>;
    /**
     * 
     * @type {Array<Array<number>>}
     * @memberof FunnelConversionStepsChartTypeResponse
     */
    series?: Array<Array<number>>;
}

/**
    * @export
    * @enum {string}
    */
export enum FunnelConversionStepsChartTypeResponseMetricsEnum {
    AvgTimeToConvert = 'avgTimeToConvert'
}

/**
 * event object
 * @export
 * @interface FunnelEvent
 */
export interface FunnelEvent {
    /**
     * 
     * @type {string}
     * @memberof FunnelEvent
     */
    eventName?: string;
    /**
     * 
     * @type {string}
     * @memberof FunnelEvent
     */
    eventType: FunnelEventEventTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof FunnelEvent
     */
    eventId?: number;
    /**
     * array of event filters
     * @type {Array<EventFilterByProperty>}
     * @memberof FunnelEvent
     */
    filters?: Array<EventFilterByProperty>;
}

/**
    * @export
    * @enum {string}
    */
export enum FunnelEventEventTypeEnum {
    Custom = 'custom'
}

/**
 * 
 * @export
 * @interface FunnelEventAllOf
 */
export interface FunnelEventAllOf {
    /**
     * array of event filters
     * @type {Array<EventFilterByProperty>}
     * @memberof FunnelEventAllOf
     */
    filters?: Array<EventFilterByProperty>;
}
/**
 * 
 * @export
 * @interface FunnelExcludeSteps
 */
export interface FunnelExcludeSteps {
    /**
     * 
     * @type {object}
     * @memberof FunnelExcludeSteps
     */
    steps?: object;
}
/**
 * 
 * @export
 * @interface FunnelFrequencyChartType
 */
export interface FunnelFrequencyChartType {
    /**
     * 
     * @type {string}
     * @memberof FunnelFrequencyChartType
     */
    type?: FunnelFrequencyChartTypeTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum FunnelFrequencyChartTypeTypeEnum {
    Frequency = 'frequency'
}

/**
 * 
 * @export
 * @interface FunnelQuery
 */
export interface FunnelQuery {
    /**
     * select time
     * @type {TimeBetween | TimeFrom | TimeLast}
     * @memberof FunnelQuery
     */
    time?: TimeBetween | TimeFrom | TimeLast;
    /**
     * group that is used in aggregations by group. For instance, group by user or group by organizartion.
     * @type {string}
     * @memberof FunnelQuery
     */
    group?: string;
    /**
     * 
     * @type {Array<FunnelQuerySteps>}
     * @memberof FunnelQuery
     */
    steps?: Array<FunnelQuerySteps>;
    /**
     * 
     * @type {FunnelQueryTimeWindow}
     * @memberof FunnelQuery
     */
    timeWindow?: FunnelQueryTimeWindow;
    /**
     * 
     * @type {FunnelConversionStepsChartType | FunnelConversionOverTimeChartType | FunnelTimeToConvertChartType | FunnelFrequencyChartType}
     * @memberof FunnelQuery
     */
    chartType?: FunnelConversionStepsChartType | FunnelConversionOverTimeChartType | FunnelTimeToConvertChartType | FunnelFrequencyChartType;
    /**
     * 
     * @type {string}
     * @memberof FunnelQuery
     */
    count?: FunnelQueryCountEnum;
    /**
     * 
     * @type {string}
     * @memberof FunnelQuery
     */
    stepOrder?: FunnelQueryStepOrderEnum;
    /**
     * 
     * @type {object}
     * @memberof FunnelQuery
     */
    attribution?: object;
    /**
     * 
     * @type {Array<PropertyRef>}
     * @memberof FunnelQuery
     */
    holdingConstants?: Array<PropertyRef>;
    /**
     * 
     * @type {Array<FunnelEvent & FunnelExcludeSteps>}
     * @memberof FunnelQuery
     */
    exclude?: Array<FunnelEvent & FunnelExcludeSteps>;
    /**
     * array of breakdowns
     * @type {Array<BreakdownByProperty>}
     * @memberof FunnelQuery
     */
    breakdowns?: Array<BreakdownByProperty>;
    /**
     * array of segments
     * @type {Array<EventSegmentationSegment>}
     * @memberof FunnelQuery
     */
    segments?: Array<EventSegmentationSegment>;
    /**
     * 
     * @type {EventFilters}
     * @memberof FunnelQuery
     */
    filters?: EventFilters;
}

/**
    * @export
    * @enum {string}
    */
export enum FunnelQueryCountEnum {
    Uniques = 'uniques',
    Totals = 'totals'
}
/**
    * @export
    * @enum {string}
    */
export enum FunnelQueryStepOrderEnum {
    Any = 'any',
    ExactSequence = 'exactSequence',
    ExactOrder = 'exactOrder'
}

/**
 * 
 * @export
 * @interface FunnelQuerySteps
 */
export interface FunnelQuerySteps {
    /**
     * 
     * @type {Array<FunnelEvent>}
     * @memberof FunnelQuerySteps
     */
    events?: Array<FunnelEvent>;
    /**
     * 
     * @type {string}
     * @memberof FunnelQuerySteps
     */
    order?: FunnelQueryStepsOrderEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum FunnelQueryStepsOrderEnum {
    Any = 'any',
    Exact = 'exact'
}

/**
 * 
 * @export
 * @interface FunnelQueryTimeWindow
 */
export interface FunnelQueryTimeWindow {
    /**
     * N days/weeks
     * @type {number}
     * @memberof FunnelQueryTimeWindow
     */
    n?: number;
    /**
     * 
     * @type {TimeUnitWithSession}
     * @memberof FunnelQueryTimeWindow
     */
    unit?: TimeUnitWithSession;
    /**
     * 
     * @type {string}
     * @memberof FunnelQueryTimeWindow
     */
    from?: FunnelQueryTimeWindowFromEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum FunnelQueryTimeWindowFromEnum {
    AnyDay = 'anyDay',
    FirstDay = 'firstDay'
}

/**
 * 
 * @export
 * @interface FunnelTimeToConvertChartType
 */
export interface FunnelTimeToConvertChartType {
    /**
     * 
     * @type {string}
     * @memberof FunnelTimeToConvertChartType
     */
    type?: FunnelTimeToConvertChartTypeTypeEnum;
    /**
     * 
     * @type {TimeUnit}
     * @memberof FunnelTimeToConvertChartType
     */
    intervalUnit?: TimeUnit;
    /**
     * 
     * @type {number}
     * @memberof FunnelTimeToConvertChartType
     */
    minInterval?: number;
    /**
     * 
     * @type {number}
     * @memberof FunnelTimeToConvertChartType
     */
    maxInterval?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum FunnelTimeToConvertChartTypeTypeEnum {
    TimeToConvert = 'timeToConvert'
}

/**
 * 
 * @export
 * @interface GroupRecord
 */
export interface GroupRecord {
    /**
     * 
     * @type {number}
     * @memberof GroupRecord
     */
    id?: number;
    /**
     * map of group property name and property value pairs
     * @type {object}
     * @memberof GroupRecord
     */
    properties?: object;
}
/**
 * request group records sorted by time of creation
 * @export
 * @interface GroupRecordsListRequest
 */
export interface GroupRecordsListRequest {
    /**
     * select time
     * @type {TimeBetween | TimeFrom | TimeLast}
     * @memberof GroupRecordsListRequest
     */
    time: TimeBetween | TimeFrom | TimeLast;
    /**
     * group that is used in aggregations by group. For instance, group by user or group by organization.
     * @type {string}
     * @memberof GroupRecordsListRequest
     */
    group?: string;
    /**
     * 
     * @type {GroupRecordsListRequestSearch}
     * @memberof GroupRecordsListRequest
     */
    search?: GroupRecordsListRequestSearch;
    /**
     * array of segments
     * @type {Array<EventSegmentationSegment>}
     * @memberof GroupRecordsListRequest
     */
    segments?: Array<EventSegmentationSegment>;
    /**
     * 
     * @type {EventFilters}
     * @memberof GroupRecordsListRequest
     */
    filters?: EventFilters;
}
/**
 * search in results
 * @export
 * @interface GroupRecordsListRequestSearch
 */
export interface GroupRecordsListRequestSearch {
    /**
     * 
     * @type {string}
     * @memberof GroupRecordsListRequestSearch
     */
    term?: string;
    /**
     * 
     * @type {Array<string | number>}
     * @memberof GroupRecordsListRequestSearch
     */
    inUserProperties?: Array<string | number>;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    password: string;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * map of group property name and property value pairs
     * @type {object}
     * @memberof InlineObject1
     */
    properties?: object;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * use event name only with eventType=event|user
     * @type {string}
     * @memberof InlineObject2
     */
    eventName?: string;
    /**
     * use event id only with eventType=custom
     * @type {number}
     * @memberof InlineObject2
     */
    eventId?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    eventType?: InlineObject2EventTypeEnum;
    /**
     * use property name only with propertyType=event|user
     * @type {string}
     * @memberof InlineObject2
     */
    propertyName?: string;
    /**
     * use property id only with propertyType=custom
     * @type {number}
     * @memberof InlineObject2
     */
    propertyId?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    propertyType?: InlineObject2PropertyTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject2EventTypeEnum {
    Event = 'event',
    User = 'user',
    Custom = 'custom'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineObject2PropertyTypeEnum {
    Event = 'event',
    User = 'user',
    Custom = 'custom'
}

/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {Array<string> | Array<number> | Array<boolean>}
     * @memberof InlineResponse200
     */
    values?: Array<string> | Array<number> | Array<boolean>;
}
/**
 * see  https://datatracker.ietf.org/doc/html/rfc7519
 * @export
 * @interface JWTToken
 */
export interface JWTToken {
    /**
     * 
     * @type {number}
     * @memberof JWTToken
     */
    accountId: number;
    /**
     * 
     * @type {number}
     * @memberof JWTToken
     */
    organizationId: number;
    /**
     * 
     * @type {number}
     * @memberof JWTToken
     */
    projectId?: number;
    /**
     * 
     * @type {string}
     * @memberof JWTToken
     */
    iss: JWTTokenIssEnum;
    /**
     * 
     * @type {number}
     * @memberof JWTToken
     */
    exp: number;
    /**
     * 
     * @type {number}
     * @memberof JWTToken
     */
    nbf: number;
    /**
     * 
     * @type {number}
     * @memberof JWTToken
     */
    iat: number;
    /**
     * 
     * @type {number}
     * @memberof JWTToken
     */
    jti: number;
}

/**
    * @export
    * @enum {string}
    */
export enum JWTTokenIssEnum {
    Optiprism = 'optiprism'
}

/**
 * list response metadata
 * @export
 * @interface ListResponseMetadata
 */
export interface ListResponseMetadata {
    /**
     * 
     * @type {ListResponseMetadataMeta}
     * @memberof ListResponseMetadata
     */
    meta?: ListResponseMetadataMeta;
}
/**
 * 
 * @export
 * @interface ListResponseMetadataMeta
 */
export interface ListResponseMetadataMeta {
    /**
     * 
     * @type {string}
     * @memberof ListResponseMetadataMeta
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof ListResponseMetadataMeta
     */
    prev?: string;
    /**
     * 
     * @type {number}
     * @memberof ListResponseMetadataMeta
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {Array<number>}
     * @memberof Organization
     */
    teams?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Organization
     */
    users?: Array<number>;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    updatedAt?: string;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    createdBy?: number;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    updatedBy?: number;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    sessionTimeoutSeconds?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Project
     */
    teams?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Project
     */
    users?: Array<number>;
}
/**
 * property defines event or user property. For example, event \"Buy product\" may contains next properties like \"Product name\" and \"Price.\"
 * @export
 * @interface Property
 */
export interface Property {
    /**
     * property unique id
     * @type {number}
     * @memberof Property
     */
    id: number;
    /**
     * create date
     * @type {string}
     * @memberof Property
     */
    createdAt: string;
    /**
     * update (once updated)
     * @type {string}
     * @memberof Property
     */
    updatedAt?: string;
    /**
     * id of creator User
     * @type {number}
     * @memberof Property
     */
    createdBy: number;
    /**
     * id of updater User
     * @type {number}
     * @memberof Property
     */
    updatedBy?: number;
    /**
     * project id
     * @type {number}
     * @memberof Property
     */
    projectId: number;
    /**
     * list of id of events which use this property
     * @type {Array<number>}
     * @memberof Property
     */
    events?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    type?: PropertyTypeEnum;
    /**
     * the property is a system-wide, shown in any project and can\'t be modified by a regular user
     * @type {boolean}
     * @memberof Property
     */
    isSystem: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Property
     */
    tags?: Array<string>;
    /**
     * property name. Must be unique
     * @type {string}
     * @memberof Property
     */
    name: string;
    /**
     * property name to display. If empty then name is used.
     * @type {string}
     * @memberof Property
     */
    displayName?: string;
    /**
     * description
     * @type {string}
     * @memberof Property
     */
    description?: string;
    /**
     * property status
     * @type {string}
     * @memberof Property
     */
    status: PropertyStatusEnum;
    /**
     * 
     * @type {object & DataType}
     * @memberof Property
     */
    dataType?: object & DataType;
    /**
     * nullable property might contains null value
     * @type {boolean}
     * @memberof Property
     */
    nullable: boolean;
    /**
     * array property might contents multiple values
     * @type {boolean}
     * @memberof Property
     */
    isArray: boolean;
    /**
     * dictionary can efficiently packs strings provided that cardinality will be relatively log (16bits is a reasonable maximum)
     * @type {boolean}
     * @memberof Property
     */
    isDictionary: boolean;
    /**
     * 
     * @type {object & DataType}
     * @memberof Property
     */
    dictionaryType?: object & DataType;
}

/**
    * @export
    * @enum {string}
    */
export enum PropertyTypeEnum {
    Event = 'event',
    User = 'user'
}
/**
    * @export
    * @enum {string}
    */
export enum PropertyStatusEnum {
    Enabled = 'enabled',
    Disabled = 'disabled'
}

/**
 * operation
 * @export
 * @enum {string}
 */
export enum PropertyFilterOperation {
    Eq = 'eq',
    Neq = 'neq',
    Gt = 'gt',
    Gte = 'gte',
    Lt = 'lt',
    Lte = 'lte',
    True = 'true',
    False = 'false',
    Exists = 'exists',
    Empty = 'empty',
    ArrAll = 'arr_all',
    ArrAny = 'arr_any',
    ArrNone = 'arr_none',
    Regex = 'regex'
}

/**
 * @type PropertyRef
 * reference to a property by id or name, depends on property type
 * @export
 */
export type PropertyRef = PropertyRefOneOf | PropertyRefOneOf1;

/**
 * 
 * @export
 * @interface PropertyRefOneOf
 */
export interface PropertyRefOneOf {
    /**
     * 
     * @type {string}
     * @memberof PropertyRefOneOf
     */
    propertyName?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyRefOneOf
     */
    propertyType?: PropertyRefOneOfPropertyTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum PropertyRefOneOfPropertyTypeEnum {
    Event = 'event',
    User = 'user'
}

/**
 * 
 * @export
 * @interface PropertyRefOneOf1
 */
export interface PropertyRefOneOf1 {
    /**
     * 
     * @type {number}
     * @memberof PropertyRefOneOf1
     */
    propertyId?: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyRefOneOf1
     */
    propertyType?: PropertyRefOneOf1PropertyTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum PropertyRefOneOf1PropertyTypeEnum {
    Custom = 'custom',
    Event = 'event',
    User = 'user'
}

/**
 * possible property type
 * @export
 * @enum {string}
 */
export enum PropertyType {
    Event = 'event',
    User = 'user',
    Custom = 'custom'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum QueryAggregate {
    Sum = 'sum',
    Avg = 'avg',
    Median = 'median',
    Min = 'min',
    Max = 'max',
    DistinctCount = 'distinctCount',
    _25thPercentile = '25thPercentile',
    _75thPercentile = '75thPercentile',
    _90thPercentile = '90thPercentile',
    _99thPercentile = '99thPercentile'
}

/**
 * aggregate of property per by group
 * @export
 * @interface QueryAggregateProperty
 */
export interface QueryAggregateProperty {
    /**
     * 
     * @type {string}
     * @memberof QueryAggregateProperty
     */
    type: QueryAggregatePropertyTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof QueryAggregateProperty
     */
    propertyName?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryAggregateProperty
     */
    propertyType: QueryAggregatePropertyPropertyTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof QueryAggregateProperty
     */
    propertyId?: number;
    /**
     * 
     * @type {QueryAggregate}
     * @memberof QueryAggregateProperty
     */
    aggregate: QueryAggregate;
}

/**
    * @export
    * @enum {string}
    */
export enum QueryAggregatePropertyTypeEnum {
    AggregateProperty = 'aggregateProperty'
}
/**
    * @export
    * @enum {string}
    */
export enum QueryAggregatePropertyPropertyTypeEnum {
    Custom = 'custom',
    Event = 'event',
    User = 'user'
}

/**
 * 
 * @export
 * @interface QueryAggregatePropertyAllOf
 */
export interface QueryAggregatePropertyAllOf {
    /**
     * 
     * @type {QueryAggregate}
     * @memberof QueryAggregatePropertyAllOf
     */
    aggregate?: QueryAggregate;
}
/**
 * aggregate of property per by group
 * @export
 * @interface QueryAggregatePropertyPerGroup
 */
export interface QueryAggregatePropertyPerGroup {
    /**
     * 
     * @type {string}
     * @memberof QueryAggregatePropertyPerGroup
     */
    type: QueryAggregatePropertyPerGroupTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof QueryAggregatePropertyPerGroup
     */
    propertyName?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryAggregatePropertyPerGroup
     */
    propertyType: QueryAggregatePropertyPerGroupPropertyTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof QueryAggregatePropertyPerGroup
     */
    propertyId?: number;
    /**
     * 
     * @type {QueryAggregate}
     * @memberof QueryAggregatePropertyPerGroup
     */
    aggregate: QueryAggregate;
    /**
     * 
     * @type {QueryAggregate}
     * @memberof QueryAggregatePropertyPerGroup
     */
    aggregatePerGroup: QueryAggregate;
}

/**
    * @export
    * @enum {string}
    */
export enum QueryAggregatePropertyPerGroupTypeEnum {
    AggregatePropertyPerGroup = 'aggregatePropertyPerGroup'
}
/**
    * @export
    * @enum {string}
    */
export enum QueryAggregatePropertyPerGroupPropertyTypeEnum {
    Custom = 'custom',
    Event = 'event',
    User = 'user'
}

/**
 * 
 * @export
 * @interface QueryAggregatePropertyPerGroupAllOf
 */
export interface QueryAggregatePropertyPerGroupAllOf {
    /**
     * 
     * @type {string}
     * @memberof QueryAggregatePropertyPerGroupAllOf
     */
    type?: QueryAggregatePropertyPerGroupAllOfTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum QueryAggregatePropertyPerGroupAllOfTypeEnum {
    AggregatePropertyPerGroup = 'aggregatePropertyPerGroup'
}

/**
 * 
 * @export
 * @interface QueryAggregatePropertyPerGroupAllOf1
 */
export interface QueryAggregatePropertyPerGroupAllOf1 {
    /**
     * 
     * @type {QueryAggregate}
     * @memberof QueryAggregatePropertyPerGroupAllOf1
     */
    aggregate?: QueryAggregate;
    /**
     * 
     * @type {QueryAggregate}
     * @memberof QueryAggregatePropertyPerGroupAllOf1
     */
    aggregatePerGroup?: QueryAggregate;
}
/**
 * event count aggregate by group
 * @export
 * @interface QueryCountPerGroup
 */
export interface QueryCountPerGroup {
    /**
     * 
     * @type {string}
     * @memberof QueryCountPerGroup
     */
    type: QueryCountPerGroupTypeEnum;
    /**
     * 
     * @type {QueryAggregate}
     * @memberof QueryCountPerGroup
     */
    aggregate: QueryAggregate;
}

/**
    * @export
    * @enum {string}
    */
export enum QueryCountPerGroupTypeEnum {
    CountPerGroup = 'countPerGroup'
}

/**
 * apply formula
 * @export
 * @interface QueryFormula
 */
export interface QueryFormula {
    /**
     * 
     * @type {string}
     * @memberof QueryFormula
     */
    type?: QueryFormulaTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof QueryFormula
     */
    formula?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum QueryFormulaTypeEnum {
    Formula = 'formula'
}

/**
 * simple query without any additional agruments
 * @export
 * @interface QuerySimple
 */
export interface QuerySimple {
    /**
     * 
     * @type {string}
     * @memberof QuerySimple
     */
    type: QuerySimpleTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof QuerySimple
     */
    query: QuerySimpleQueryEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum QuerySimpleTypeEnum {
    Simple = 'simple'
}
/**
    * @export
    * @enum {string}
    */
export enum QuerySimpleQueryEnum {
    CountEvents = 'countEvents',
    CountUniqueGroups = 'countUniqueGroups',
    WeeklyActiveGroups = 'weeklyActiveGroups',
    MonthlyActiveGroups = 'monthlyActiveGroups'
}

/**
 * 
 * @export
 * @interface RefreshTokenRequest
 */
export interface RefreshTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenRequest
     */
    refresh_token?: string;
}
/**
 * 
 * @export
 * @interface Report
 */
export interface Report {
    /**
     * report unique id
     * @type {number}
     * @memberof Report
     */
    id?: number;
    /**
     * create date
     * @type {string}
     * @memberof Report
     */
    createdAt?: string;
    /**
     * update (once updated)
     * @type {string}
     * @memberof Report
     */
    updatedAt?: string;
    /**
     * id of creator User
     * @type {number}
     * @memberof Report
     */
    createdBy?: number;
    /**
     * id of updater User
     * @type {number}
     * @memberof Report
     */
    updatedBy?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Report
     */
    tags?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Report
     */
    name?: string;
    /**
     * description
     * @type {string}
     * @memberof Report
     */
    description?: string;
    /**
     * 
     * @type {object & EventSegmentation | FunnelQuery}
     * @memberof Report
     */
    report?: object & EventSegmentation | FunnelQuery;
}
/**
 * @type SegmentCondition
 * @export
 */
export type SegmentCondition = SegmentConditionDidEvent | SegmentConditionFunnel | SegmentConditionHadPropertyValue | SegmentConditionHasPropertyValue;

/**
 * did event condition
 * @export
 * @interface SegmentConditionDidEvent
 */
export interface SegmentConditionDidEvent {
    /**
     * 
     * @type {string}
     * @memberof SegmentConditionDidEvent
     */
    type?: SegmentConditionDidEventTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SegmentConditionDidEvent
     */
    eventName?: string;
    /**
     * 
     * @type {string}
     * @memberof SegmentConditionDidEvent
     */
    eventType?: SegmentConditionDidEventEventTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof SegmentConditionDidEvent
     */
    eventId?: number;
    /**
     * 
     * @type {Array<EventFilterByProperty>}
     * @memberof SegmentConditionDidEvent
     */
    filters?: Array<EventFilterByProperty>;
    /**
     * 
     * @type {DidEventCount | DidEventRelativeCount | DidEventAggregateProperty | DidEventHistoricalCount}
     * @memberof SegmentConditionDidEvent
     */
    aggregate?: DidEventCount | DidEventRelativeCount | DidEventAggregateProperty | DidEventHistoricalCount;
}

/**
    * @export
    * @enum {string}
    */
export enum SegmentConditionDidEventTypeEnum {
    DidEvent = 'didEvent'
}
/**
    * @export
    * @enum {string}
    */
export enum SegmentConditionDidEventEventTypeEnum {
    Custom = 'custom'
}

/**
 * 
 * @export
 * @interface SegmentConditionDidEventAllOf
 */
export interface SegmentConditionDidEventAllOf {
    /**
     * 
     * @type {string}
     * @memberof SegmentConditionDidEventAllOf
     */
    type?: SegmentConditionDidEventAllOfTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SegmentConditionDidEventAllOfTypeEnum {
    DidEvent = 'didEvent'
}

/**
 * 
 * @export
 * @interface SegmentConditionDidEventAllOf1
 */
export interface SegmentConditionDidEventAllOf1 {
    /**
     * 
     * @type {Array<EventFilterByProperty>}
     * @memberof SegmentConditionDidEventAllOf1
     */
    filters?: Array<EventFilterByProperty>;
    /**
     * 
     * @type {DidEventCount | DidEventRelativeCount | DidEventAggregateProperty | DidEventHistoricalCount}
     * @memberof SegmentConditionDidEventAllOf1
     */
    aggregate?: DidEventCount | DidEventRelativeCount | DidEventAggregateProperty | DidEventHistoricalCount;
}
/**
 * 
 * @export
 * @interface SegmentConditionFunnel
 */
export interface SegmentConditionFunnel {
    /**
     * 
     * @type {string}
     * @memberof SegmentConditionFunnel
     */
    type?: SegmentConditionFunnelTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof SegmentConditionFunnel
     */
    last?: number;
    /**
     * 
     * @type {TimeUnit}
     * @memberof SegmentConditionFunnel
     */
    bucket?: TimeUnit;
}

/**
    * @export
    * @enum {string}
    */
export enum SegmentConditionFunnelTypeEnum {
    Funnel = 'funnel'
}

/**
 * check whether the user had a property with a value
 * @export
 * @interface SegmentConditionHadPropertyValue
 */
export interface SegmentConditionHadPropertyValue {
    /**
     * 
     * @type {string}
     * @memberof SegmentConditionHadPropertyValue
     */
    type: SegmentConditionHadPropertyValueTypeEnum;
    /**
     * property name. Because property here is a user only, we don\'t need propertyType
     * @type {string}
     * @memberof SegmentConditionHadPropertyValue
     */
    propertyName: string;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof SegmentConditionHadPropertyValue
     */
    operation: PropertyFilterOperation;
    /**
     * one or more values. Doesn\'t need if operation is \"empty\" or \"exist\"
     * @type {Array<Value>}
     * @memberof SegmentConditionHadPropertyValue
     */
    values?: Array<Value>;
    /**
     * time frame
     * @type {TimeBetween | TimeLast | TimeWindowEach}
     * @memberof SegmentConditionHadPropertyValue
     */
    time: TimeBetween | TimeLast | TimeWindowEach;
}

/**
    * @export
    * @enum {string}
    */
export enum SegmentConditionHadPropertyValueTypeEnum {
    HadPropertyValue = 'hadPropertyValue'
}

/**
 * check whether the user currently has a property with a value
 * @export
 * @interface SegmentConditionHasPropertyValue
 */
export interface SegmentConditionHasPropertyValue {
    /**
     * 
     * @type {string}
     * @memberof SegmentConditionHasPropertyValue
     */
    type: SegmentConditionHasPropertyValueTypeEnum;
    /**
     * property name. Because property here is a user only, we don\'t need propertyType
     * @type {string}
     * @memberof SegmentConditionHasPropertyValue
     */
    propertyName: string;
    /**
     * 
     * @type {PropertyFilterOperation}
     * @memberof SegmentConditionHasPropertyValue
     */
    operation: PropertyFilterOperation;
    /**
     * one or more values. Doesn\'t need if operation is \"empty\" or \"exist\"
     * @type {Array<Value>}
     * @memberof SegmentConditionHasPropertyValue
     */
    values?: Array<Value>;
}

/**
    * @export
    * @enum {string}
    */
export enum SegmentConditionHasPropertyValueTypeEnum {
    HasPropertyValue = 'hasPropertyValue'
}

/**
 * 
 * @export
 * @interface SignupRequest
 */
export interface SignupRequest {
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    password_repeat?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    first_name?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    last_name?: string;
}
/**
 * time spent after the first use of event. Use in segmentation
 * @export
 * @interface TimeAfterFirstUse
 */
export interface TimeAfterFirstUse {
    /**
     * 
     * @type {string}
     * @memberof TimeAfterFirstUse
     */
    type: TimeAfterFirstUseTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof TimeAfterFirstUse
     */
    within: number;
    /**
     * 
     * @type {TimeUnit}
     * @memberof TimeAfterFirstUse
     */
    unit: TimeUnit;
}

/**
    * @export
    * @enum {string}
    */
export enum TimeAfterFirstUseTypeEnum {
    AfterFirstUse = 'afterFirstUse'
}

/**
 * time range between fixed values
 * @export
 * @interface TimeBetween
 */
export interface TimeBetween {
    /**
     * 
     * @type {string}
     * @memberof TimeBetween
     */
    type: TimeBetweenTypeEnum;
    /**
     * start date
     * @type {string}
     * @memberof TimeBetween
     */
    from: string;
    /**
     * end date
     * @type {string}
     * @memberof TimeBetween
     */
    to: string;
}

/**
    * @export
    * @enum {string}
    */
export enum TimeBetweenTypeEnum {
    Between = 'between'
}

/**
 * time range between fixed value and current time
 * @export
 * @interface TimeFrom
 */
export interface TimeFrom {
    /**
     * 
     * @type {string}
     * @memberof TimeFrom
     */
    type: TimeFromTypeEnum;
    /**
     * start date
     * @type {string}
     * @memberof TimeFrom
     */
    from: string;
}

/**
    * @export
    * @enum {string}
    */
export enum TimeFromTypeEnum {
    From = 'from'
}

/**
 * take last N days/weeks
 * @export
 * @interface TimeLast
 */
export interface TimeLast {
    /**
     * 
     * @type {string}
     * @memberof TimeLast
     */
    type: TimeLastTypeEnum;
    /**
     * N days/weeks
     * @type {number}
     * @memberof TimeLast
     */
    n: number;
    /**
     * 
     * @type {TimeUnit}
     * @memberof TimeLast
     */
    unit: TimeUnit;
}

/**
    * @export
    * @enum {string}
    */
export enum TimeLastTypeEnum {
    Last = 'last'
}

/**
 * time unit
 * @export
 * @enum {string}
 */
export enum TimeUnit {
    Second = 'second',
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Year = 'year'
}

/**
 * time unit with session
 * @export
 * @enum {string}
 */
export enum TimeUnitWithSession {
    Second = 'second',
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month',
    Year = 'year',
    Session = 'session'
}

/**
 * window operation for segmentation. Tells that event should be triggered each timeunit (each day, for instance) {   \"time\": {     \"type\": \"each\",     \"unit\":\"day\"   } } 
 * @export
 * @interface TimeWindowEach
 */
export interface TimeWindowEach {
    /**
     * 
     * @type {string}
     * @memberof TimeWindowEach
     */
    type: TimeWindowEachTypeEnum;
    /**
     * 
     * @type {TimeUnit}
     * @memberof TimeWindowEach
     */
    unit: TimeUnit;
}

/**
    * @export
    * @enum {string}
    */
export enum TimeWindowEachTypeEnum {
    WindowEach = 'windowEach'
}

/**
 * 
 * @export
 * @interface TokensResponse
 */
export interface TokensResponse {
    /**
     * 
     * @type {string}
     * @memberof TokensResponse
     */
    accessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof TokensResponse
     */
    refreshToken?: string;
    /**
     * 
     * @type {string}
     * @memberof TokensResponse
     */
    csrfToken?: string;
}
/**
 * Custom Event is an alias to an expression which is used while querying. You can use regular or custom events in expression. You can combine events in expression, you can use filter by properties.
 * @export
 * @interface UpdateCustomEventRequest
 */
export interface UpdateCustomEventRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomEventRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomEventRequest
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomEventRequest
     */
    status?: UpdateCustomEventRequestStatusEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateCustomEventRequest
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Array<CustomEventEvent>}
     * @memberof UpdateCustomEventRequest
     */
    events: Array<CustomEventEvent>;
}

/**
    * @export
    * @enum {string}
    */
export enum UpdateCustomEventRequestStatusEnum {
    Enabled = 'enabled',
    Disabled = 'disabled'
}

/**
 * 
 * @export
 * @interface UpdateDashboardRequest
 */
export interface UpdateDashboardRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateDashboardRequest
     */
    tags?: Array<string>;
    /**
     * dashboard name
     * @type {string}
     * @memberof UpdateDashboardRequest
     */
    name?: string;
    /**
     * description
     * @type {string}
     * @memberof UpdateDashboardRequest
     */
    description?: string;
    /**
     * 
     * @type {Array<CreateDashboardRequestRows>}
     * @memberof UpdateDashboardRequest
     */
    rows?: Array<CreateDashboardRequestRows>;
}
/**
 * Update event request
 * @export
 * @interface UpdateEventRequest
 */
export interface UpdateEventRequest {
    /**
     * event name to display. If empty then name property is used.
     * @type {string}
     * @memberof UpdateEventRequest
     */
    displayName?: string;
    /**
     * description
     * @type {string}
     * @memberof UpdateEventRequest
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEventRequest
     */
    status?: UpdateEventRequestStatusEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateEventRequest
     */
    tags?: Array<string>;
}

/**
    * @export
    * @enum {string}
    */
export enum UpdateEventRequestStatusEnum {
    Enabled = 'enabled',
    Disabled = 'disabled'
}

/**
 * Propetty update
 * @export
 * @interface UpdatePropertyRequest
 */
export interface UpdatePropertyRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdatePropertyRequest
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePropertyRequest
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePropertyRequest
     */
    status?: UpdatePropertyRequestStatusEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdatePropertyRequest
     */
    tags?: Array<string>;
}

/**
    * @export
    * @enum {string}
    */
export enum UpdatePropertyRequestStatusEnum {
    Enabled = 'enabled',
    Disabled = 'disabled'
}

/**
 * 
 * @export
 * @interface UpdateReportRequest
 */
export interface UpdateReportRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateReportRequest
     */
    tags?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateReportRequest
     */
    name?: string;
    /**
     * description
     * @type {string}
     * @memberof UpdateReportRequest
     */
    description?: string;
    /**
     * 
     * @type {object & EventSegmentation | FunnelQuery}
     * @memberof UpdateReportRequest
     */
    report?: object & EventSegmentation | FunnelQuery;
}
/**
 * @type Value
 * value
 * @export
 */
export type Value = boolean | number | string;


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Refresh access token
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAccess: async (refreshTokenRequest: RefreshTokenRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenRequest' is not null or undefined
            assertParamExists('authAccess', 'refreshTokenRequest', refreshTokenRequest)
            const localVarPath = `/v1/auth/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Basic login
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basicLogin: async (inlineObject: InlineObject, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject' is not null or undefined
            assertParamExists('basicLogin', 'inlineObject', inlineObject)
            const localVarPath = `/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Basic signup
         * @param {SignupRequest} signupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basicSignup: async (signupRequest: SignupRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'signupRequest' is not null or undefined
            assertParamExists('basicSignup', 'signupRequest', signupRequest)
            const localVarPath = `/v1/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Log out
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Refresh access token
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authAccess(refreshTokenRequest: RefreshTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authAccess(refreshTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Basic login
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async basicLogin(inlineObject: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.basicLogin(inlineObject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Basic signup
         * @param {SignupRequest} signupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async basicSignup(signupRequest: SignupRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.basicSignup(signupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Log out
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Refresh access token
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAccess(refreshTokenRequest: RefreshTokenRequest, options?: any): AxiosPromise<TokensResponse> {
            return localVarFp.authAccess(refreshTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Basic login
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basicLogin(inlineObject: InlineObject, options?: any): AxiosPromise<TokensResponse> {
            return localVarFp.basicLogin(inlineObject, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Basic signup
         * @param {SignupRequest} signupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basicSignup(signupRequest: SignupRequest, options?: any): AxiosPromise<TokensResponse> {
            return localVarFp.basicSignup(signupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Log out
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<void> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Refresh access token
     * @param {RefreshTokenRequest} refreshTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authAccess(refreshTokenRequest: RefreshTokenRequest, options?: any) {
        return AuthApiFp(this.configuration).authAccess(refreshTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Basic login
     * @param {InlineObject} inlineObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public basicLogin(inlineObject: InlineObject, options?: any) {
        return AuthApiFp(this.configuration).basicLogin(inlineObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Basic signup
     * @param {SignupRequest} signupRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public basicSignup(signupRequest: SignupRequest, options?: any) {
        return AuthApiFp(this.configuration).basicSignup(signupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Log out
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logout(options?: any) {
        return AuthApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DashboardsApi - axios parameter creator
 * @export
 */
export const DashboardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create dashboard
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {CreateDashboardRequest} createDashboardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboard: async (organizationId: number, projectId: number, createDashboardRequest: CreateDashboardRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createDashboard', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createDashboard', 'projectId', projectId)
            // verify required parameter 'createDashboardRequest' is not null or undefined
            assertParamExists('createDashboard', 'createDashboardRequest', createDashboardRequest)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/dashboards`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDashboardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dashboards list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsList: async (organizationId: number, projectId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('dashboardsList', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('dashboardsList', 'projectId', projectId)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/dashboards`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete dashboard
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} dashboardId Dashboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboard: async (organizationId: number, projectId: number, dashboardId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteDashboard', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteDashboard', 'projectId', projectId)
            // verify required parameter 'dashboardId' is not null or undefined
            assertParamExists('deleteDashboard', 'dashboardId', dashboardId)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/dashboards/{dashboard_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"dashboard_id"}}`, encodeURIComponent(String(dashboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get dashboard
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} dashboardId Dashboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboard: async (organizationId: number, projectId: number, dashboardId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getDashboard', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getDashboard', 'projectId', projectId)
            // verify required parameter 'dashboardId' is not null or undefined
            assertParamExists('getDashboard', 'dashboardId', dashboardId)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/dashboards/{dashboard_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"dashboard_id"}}`, encodeURIComponent(String(dashboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update dashboard
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {string} dashboardId Dashboard ID
         * @param {UpdateDashboardRequest} updateDashboardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDashboard: async (organizationId: number, projectId: number, dashboardId: string, updateDashboardRequest: UpdateDashboardRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateDashboard', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateDashboard', 'projectId', projectId)
            // verify required parameter 'dashboardId' is not null or undefined
            assertParamExists('updateDashboard', 'dashboardId', dashboardId)
            // verify required parameter 'updateDashboardRequest' is not null or undefined
            assertParamExists('updateDashboard', 'updateDashboardRequest', updateDashboardRequest)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/dashboards/{dashboard_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"dashboard_id"}}`, encodeURIComponent(String(dashboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDashboardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardsApi - functional programming interface
 * @export
 */
export const DashboardsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create dashboard
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {CreateDashboardRequest} createDashboardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDashboard(organizationId: number, projectId: number, createDashboardRequest: CreateDashboardRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDashboard(organizationId, projectId, createDashboardRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Dashboards list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardsList(organizationId: number, projectId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object & ListResponseMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardsList(organizationId, projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete dashboard
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} dashboardId Dashboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDashboard(organizationId: number, projectId: number, dashboardId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDashboard(organizationId, projectId, dashboardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get dashboard
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} dashboardId Dashboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboard(organizationId: number, projectId: number, dashboardId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboard(organizationId, projectId, dashboardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update dashboard
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {string} dashboardId Dashboard ID
         * @param {UpdateDashboardRequest} updateDashboardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDashboard(organizationId: number, projectId: number, dashboardId: string, updateDashboardRequest: UpdateDashboardRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDashboard(organizationId, projectId, dashboardId, updateDashboardRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DashboardsApi - factory interface
 * @export
 */
export const DashboardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create dashboard
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {CreateDashboardRequest} createDashboardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboard(organizationId: number, projectId: number, createDashboardRequest: CreateDashboardRequest, options?: any): AxiosPromise<Dashboard> {
            return localVarFp.createDashboard(organizationId, projectId, createDashboardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Dashboards list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsList(organizationId: number, projectId: number, options?: any): AxiosPromise<object & ListResponseMetadata> {
            return localVarFp.dashboardsList(organizationId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete dashboard
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} dashboardId Dashboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboard(organizationId: number, projectId: number, dashboardId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDashboard(organizationId, projectId, dashboardId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get dashboard
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} dashboardId Dashboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboard(organizationId: number, projectId: number, dashboardId: number, options?: any): AxiosPromise<Dashboard> {
            return localVarFp.getDashboard(organizationId, projectId, dashboardId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update dashboard
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {string} dashboardId Dashboard ID
         * @param {UpdateDashboardRequest} updateDashboardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDashboard(organizationId: number, projectId: number, dashboardId: string, updateDashboardRequest: UpdateDashboardRequest, options?: any): AxiosPromise<Dashboard> {
            return localVarFp.updateDashboard(organizationId, projectId, dashboardId, updateDashboardRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DashboardsApi - object-oriented interface
 * @export
 * @class DashboardsApi
 * @extends {BaseAPI}
 */
export class DashboardsApi extends BaseAPI {
    /**
     * 
     * @summary Create dashboard
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {CreateDashboardRequest} createDashboardRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public createDashboard(organizationId: number, projectId: number, createDashboardRequest: CreateDashboardRequest, options?: any) {
        return DashboardsApiFp(this.configuration).createDashboard(organizationId, projectId, createDashboardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Dashboards list
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsList(organizationId: number, projectId: number, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsList(organizationId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete dashboard
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {number} dashboardId Dashboard ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public deleteDashboard(organizationId: number, projectId: number, dashboardId: number, options?: any) {
        return DashboardsApiFp(this.configuration).deleteDashboard(organizationId, projectId, dashboardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get dashboard
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {number} dashboardId Dashboard ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public getDashboard(organizationId: number, projectId: number, dashboardId: number, options?: any) {
        return DashboardsApiFp(this.configuration).getDashboard(organizationId, projectId, dashboardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update dashboard
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {string} dashboardId Dashboard ID
     * @param {UpdateDashboardRequest} updateDashboardRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public updateDashboard(organizationId: number, projectId: number, dashboardId: string, updateDashboardRequest: UpdateDashboardRequest, options?: any) {
        return DashboardsApiFp(this.configuration).updateDashboard(organizationId, projectId, dashboardId, updateDashboardRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create custom event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {CreateCustomEventRequest} createCustomEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomEvent: async (organizationId: number, projectId: number, createCustomEventRequest: CreateCustomEventRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createCustomEvent', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createCustomEvent', 'projectId', projectId)
            // verify required parameter 'createCustomEventRequest' is not null or undefined
            assertParamExists('createCustomEvent', 'createCustomEventRequest', createCustomEventRequest)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/custom-events`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCustomEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Custom events list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customEventsList: async (organizationId: number, projectId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('customEventsList', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('customEventsList', 'projectId', projectId)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/custom-events`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete custom event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomEvent: async (organizationId: number, projectId: number, eventId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteCustomEvent', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteCustomEvent', 'projectId', projectId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('deleteCustomEvent', 'eventId', eventId)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/custom-events/{event_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get events
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {EventRecordsListRequest} eventRecordsListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventRecordsList: async (organizationId: number, projectId: number, eventRecordsListRequest: EventRecordsListRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('eventRecordsList', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('eventRecordsList', 'projectId', projectId)
            // verify required parameter 'eventRecordsListRequest' is not null or undefined
            assertParamExists('eventRecordsList', 'eventRecordsListRequest', eventRecordsListRequest)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/data/event-records`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventRecordsListRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Events list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsList: async (organizationId: number, projectId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('eventsList', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('eventsList', 'projectId', projectId)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/events`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get custom event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomEvent: async (organizationId: number, projectId: number, eventId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getCustomEvent', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getCustomEvent', 'projectId', projectId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getCustomEvent', 'eventId', eventId)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/custom-events/{event_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent: async (organizationId: number, projectId: number, eventId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getEvent', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getEvent', 'projectId', projectId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEvent', 'eventId', eventId)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/events/{event_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get event property
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventProperty: async (organizationId: number, projectId: number, propertyId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getEventProperty', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getEventProperty', 'projectId', projectId)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('getEventProperty', 'propertyId', propertyId)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/event_properties/{property_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"property_id"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get event record
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} id Event Record ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventRecord: async (organizationId: number, projectId: number, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getEventRecord', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getEventRecord', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEventRecord', 'id', id)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/data/event-records/{id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user property
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProperty: async (organizationId: number, projectId: number, propertyId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getUserProperty', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getUserProperty', 'projectId', projectId)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('getUserProperty', 'propertyId', propertyId)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/user_properties/{property_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"property_id"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update custom event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {string} eventId Custom Event ID
         * @param {UpdateCustomEventRequest} updateCustomEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomEvent: async (organizationId: number, projectId: number, eventId: string, updateCustomEventRequest: UpdateCustomEventRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateCustomEvent', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateCustomEvent', 'projectId', projectId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateCustomEvent', 'eventId', eventId)
            // verify required parameter 'updateCustomEventRequest' is not null or undefined
            assertParamExists('updateCustomEvent', 'updateCustomEventRequest', updateCustomEventRequest)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/custom-events/{event_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCustomEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {string} eventId Event ID
         * @param {UpdateEventRequest} updateEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent: async (organizationId: number, projectId: number, eventId: string, updateEventRequest: UpdateEventRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateEvent', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateEvent', 'projectId', projectId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEvent', 'eventId', eventId)
            // verify required parameter 'updateEventRequest' is not null or undefined
            assertParamExists('updateEvent', 'updateEventRequest', updateEventRequest)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/events/{event_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create custom event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {CreateCustomEventRequest} createCustomEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomEvent(organizationId: number, projectId: number, createCustomEventRequest: CreateCustomEventRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomEvent(organizationId, projectId, createCustomEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Custom events list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customEventsList(organizationId: number, projectId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object & ListResponseMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customEventsList(organizationId, projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete custom event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomEvent(organizationId: number, projectId: number, eventId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomEvent(organizationId, projectId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get events
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {EventRecordsListRequest} eventRecordsListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventRecordsList(organizationId: number, projectId: number, eventRecordsListRequest: EventRecordsListRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object & ListResponseMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventRecordsList(organizationId, projectId, eventRecordsListRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Events list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsList(organizationId: number, projectId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object & ListResponseMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsList(organizationId, projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get custom event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomEvent(organizationId: number, projectId: number, eventId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomEvent(organizationId, projectId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvent(organizationId: number, projectId: number, eventId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvent(organizationId, projectId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get event property
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventProperty(organizationId: number, projectId: number, propertyId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventProperty(organizationId, projectId, propertyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get event record
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} id Event Record ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventRecord(organizationId: number, projectId: number, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventRecord(organizationId, projectId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user property
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserProperty(organizationId: number, projectId: number, propertyId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserProperty(organizationId, projectId, propertyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update custom event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {string} eventId Custom Event ID
         * @param {UpdateCustomEventRequest} updateCustomEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomEvent(organizationId: number, projectId: number, eventId: string, updateCustomEventRequest: UpdateCustomEventRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomEvent(organizationId, projectId, eventId, updateCustomEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {string} eventId Event ID
         * @param {UpdateEventRequest} updateEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEvent(organizationId: number, projectId: number, eventId: string, updateEventRequest: UpdateEventRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvent(organizationId, projectId, eventId, updateEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create custom event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {CreateCustomEventRequest} createCustomEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomEvent(organizationId: number, projectId: number, createCustomEventRequest: CreateCustomEventRequest, options?: any): AxiosPromise<CustomEvent> {
            return localVarFp.createCustomEvent(organizationId, projectId, createCustomEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Custom events list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customEventsList(organizationId: number, projectId: number, options?: any): AxiosPromise<object & ListResponseMetadata> {
            return localVarFp.customEventsList(organizationId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete custom event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomEvent(organizationId: number, projectId: number, eventId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCustomEvent(organizationId, projectId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get events
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {EventRecordsListRequest} eventRecordsListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventRecordsList(organizationId: number, projectId: number, eventRecordsListRequest: EventRecordsListRequest, options?: any): AxiosPromise<object & ListResponseMetadata> {
            return localVarFp.eventRecordsList(organizationId, projectId, eventRecordsListRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Events list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsList(organizationId: number, projectId: number, options?: any): AxiosPromise<object & ListResponseMetadata> {
            return localVarFp.eventsList(organizationId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get custom event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomEvent(organizationId: number, projectId: number, eventId: number, options?: any): AxiosPromise<CustomEvent> {
            return localVarFp.getCustomEvent(organizationId, projectId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} eventId Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(organizationId: number, projectId: number, eventId: number, options?: any): AxiosPromise<Event> {
            return localVarFp.getEvent(organizationId, projectId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get event property
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventProperty(organizationId: number, projectId: number, propertyId: number, options?: any): AxiosPromise<Property> {
            return localVarFp.getEventProperty(organizationId, projectId, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get event record
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} id Event Record ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventRecord(organizationId: number, projectId: number, id: number, options?: any): AxiosPromise<EventRecord> {
            return localVarFp.getEventRecord(organizationId, projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user property
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProperty(organizationId: number, projectId: number, propertyId: number, options?: any): AxiosPromise<Property> {
            return localVarFp.getUserProperty(organizationId, projectId, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update custom event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {string} eventId Custom Event ID
         * @param {UpdateCustomEventRequest} updateCustomEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomEvent(organizationId: number, projectId: number, eventId: string, updateCustomEventRequest: UpdateCustomEventRequest, options?: any): AxiosPromise<CustomEvent> {
            return localVarFp.updateCustomEvent(organizationId, projectId, eventId, updateCustomEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update event
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {string} eventId Event ID
         * @param {UpdateEventRequest} updateEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent(organizationId: number, projectId: number, eventId: string, updateEventRequest: UpdateEventRequest, options?: any): AxiosPromise<Event> {
            return localVarFp.updateEvent(organizationId, projectId, eventId, updateEventRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * 
     * @summary Create custom event
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {CreateCustomEventRequest} createCustomEventRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public createCustomEvent(organizationId: number, projectId: number, createCustomEventRequest: CreateCustomEventRequest, options?: any) {
        return EventsApiFp(this.configuration).createCustomEvent(organizationId, projectId, createCustomEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Custom events list
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public customEventsList(organizationId: number, projectId: number, options?: any) {
        return EventsApiFp(this.configuration).customEventsList(organizationId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete custom event
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {number} eventId Event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public deleteCustomEvent(organizationId: number, projectId: number, eventId: number, options?: any) {
        return EventsApiFp(this.configuration).deleteCustomEvent(organizationId, projectId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get events
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {EventRecordsListRequest} eventRecordsListRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventRecordsList(organizationId: number, projectId: number, eventRecordsListRequest: EventRecordsListRequest, options?: any) {
        return EventsApiFp(this.configuration).eventRecordsList(organizationId, projectId, eventRecordsListRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Events list
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsList(organizationId: number, projectId: number, options?: any) {
        return EventsApiFp(this.configuration).eventsList(organizationId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get custom event
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {number} eventId Event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getCustomEvent(organizationId: number, projectId: number, eventId: number, options?: any) {
        return EventsApiFp(this.configuration).getCustomEvent(organizationId, projectId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get event
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {number} eventId Event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEvent(organizationId: number, projectId: number, eventId: number, options?: any) {
        return EventsApiFp(this.configuration).getEvent(organizationId, projectId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get event property
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {number} propertyId Property ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEventProperty(organizationId: number, projectId: number, propertyId: number, options?: any) {
        return EventsApiFp(this.configuration).getEventProperty(organizationId, projectId, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get event record
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {number} id Event Record ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEventRecord(organizationId: number, projectId: number, id: number, options?: any) {
        return EventsApiFp(this.configuration).getEventRecord(organizationId, projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user property
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {number} propertyId Property ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getUserProperty(organizationId: number, projectId: number, propertyId: number, options?: any) {
        return EventsApiFp(this.configuration).getUserProperty(organizationId, projectId, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update custom event
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {string} eventId Custom Event ID
     * @param {UpdateCustomEventRequest} updateCustomEventRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateCustomEvent(organizationId: number, projectId: number, eventId: string, updateCustomEventRequest: UpdateCustomEventRequest, options?: any) {
        return EventsApiFp(this.configuration).updateCustomEvent(organizationId, projectId, eventId, updateCustomEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update event
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {string} eventId Event ID
     * @param {UpdateEventRequest} updateEventRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateEvent(organizationId: number, projectId: number, eventId: string, updateEventRequest: UpdateEventRequest, options?: any) {
        return EventsApiFp(this.configuration).updateEvent(organizationId, projectId, eventId, updateEventRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get group record
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} id Group Record ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupRecord: async (organizationId: number, projectId: number, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getGroupRecord', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getGroupRecord', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGroupRecord', 'id', id)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/data/group-records/{id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get group records
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {GroupRecordsListRequest} groupRecordsListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupEventsList: async (organizationId: number, projectId: number, groupRecordsListRequest: GroupRecordsListRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('groupEventsList', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('groupEventsList', 'projectId', projectId)
            // verify required parameter 'groupRecordsListRequest' is not null or undefined
            assertParamExists('groupEventsList', 'groupRecordsListRequest', groupRecordsListRequest)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/data/group-records`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupRecordsListRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update group record
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} id Group Record ID
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupRecord: async (organizationId: number, projectId: number, id: number, inlineObject1: InlineObject1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateGroupRecord', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateGroupRecord', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateGroupRecord', 'id', id)
            // verify required parameter 'inlineObject1' is not null or undefined
            assertParamExists('updateGroupRecord', 'inlineObject1', inlineObject1)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/data/group-records/{id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get group record
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} id Group Record ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupRecord(organizationId: number, projectId: number, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupRecord(organizationId, projectId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get group records
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {GroupRecordsListRequest} groupRecordsListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupEventsList(organizationId: number, projectId: number, groupRecordsListRequest: GroupRecordsListRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object & ListResponseMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupEventsList(organizationId, projectId, groupRecordsListRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update group record
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} id Group Record ID
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupRecord(organizationId: number, projectId: number, id: number, inlineObject1: InlineObject1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupRecord(organizationId, projectId, id, inlineObject1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get group record
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} id Group Record ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupRecord(organizationId: number, projectId: number, id: number, options?: any): AxiosPromise<GroupRecord> {
            return localVarFp.getGroupRecord(organizationId, projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get group records
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {GroupRecordsListRequest} groupRecordsListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupEventsList(organizationId: number, projectId: number, groupRecordsListRequest: GroupRecordsListRequest, options?: any): AxiosPromise<object & ListResponseMetadata> {
            return localVarFp.groupEventsList(organizationId, projectId, groupRecordsListRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update group record
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} id Group Record ID
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupRecord(organizationId: number, projectId: number, id: number, inlineObject1: InlineObject1, options?: any): AxiosPromise<GroupRecord> {
            return localVarFp.updateGroupRecord(organizationId, projectId, id, inlineObject1, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * 
     * @summary Get group record
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {number} id Group Record ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupRecord(organizationId: number, projectId: number, id: number, options?: any) {
        return GroupsApiFp(this.configuration).getGroupRecord(organizationId, projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get group records
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {GroupRecordsListRequest} groupRecordsListRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupEventsList(organizationId: number, projectId: number, groupRecordsListRequest: GroupRecordsListRequest, options?: any) {
        return GroupsApiFp(this.configuration).groupEventsList(organizationId, projectId, groupRecordsListRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update group record
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {number} id Group Record ID
     * @param {InlineObject1} inlineObject1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public updateGroupRecord(organizationId: number, projectId: number, id: number, inlineObject1: InlineObject1, options?: any) {
        return GroupsApiFp(this.configuration).updateGroupRecord(organizationId, projectId, id, inlineObject1, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PropertiesApi - axios parameter creator
 * @export
 */
export const PropertiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Event custom properties list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customPropertiesList: async (organizationId: number, projectId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('customPropertiesList', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('customPropertiesList', 'projectId', projectId)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/custom-properties`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Event properties list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventPropertiesList: async (organizationId: number, projectId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('eventPropertiesList', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('eventPropertiesList', 'projectId', projectId)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/event_properties`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of property values
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propertyValuesList: async (organizationId: number, projectId: number, inlineObject2: InlineObject2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('propertyValuesList', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('propertyValuesList', 'projectId', projectId)
            // verify required parameter 'inlineObject2' is not null or undefined
            assertParamExists('propertyValuesList', 'inlineObject2', inlineObject2)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/data/property-values`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update event property
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {string} propertyId Property ID
         * @param {UpdatePropertyRequest} updatePropertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventProperty: async (organizationId: number, projectId: number, propertyId: string, updatePropertyRequest: UpdatePropertyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateEventProperty', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateEventProperty', 'projectId', projectId)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('updateEventProperty', 'propertyId', propertyId)
            // verify required parameter 'updatePropertyRequest' is not null or undefined
            assertParamExists('updateEventProperty', 'updatePropertyRequest', updatePropertyRequest)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/event_properties/{property_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"property_id"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePropertyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user property
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {UpdatePropertyRequest} updatePropertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserProperty: async (organizationId: number, projectId: number, propertyId: number, updatePropertyRequest: UpdatePropertyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateUserProperty', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateUserProperty', 'projectId', projectId)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('updateUserProperty', 'propertyId', propertyId)
            // verify required parameter 'updatePropertyRequest' is not null or undefined
            assertParamExists('updateUserProperty', 'updatePropertyRequest', updatePropertyRequest)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/user_properties/{property_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"property_id"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePropertyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User properties list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPropertiesList: async (organizationId: number, projectId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('userPropertiesList', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('userPropertiesList', 'projectId', projectId)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/schema/user_properties`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertiesApi - functional programming interface
 * @export
 */
export const PropertiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PropertiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Event custom properties list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customPropertiesList(organizationId: number, projectId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object & ListResponseMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customPropertiesList(organizationId, projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Event properties list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventPropertiesList(organizationId: number, projectId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object & ListResponseMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventPropertiesList(organizationId, projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List of property values
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async propertyValuesList(organizationId: number, projectId: number, inlineObject2: InlineObject2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.propertyValuesList(organizationId, projectId, inlineObject2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update event property
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {string} propertyId Property ID
         * @param {UpdatePropertyRequest} updatePropertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventProperty(organizationId: number, projectId: number, propertyId: string, updatePropertyRequest: UpdatePropertyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventProperty(organizationId, projectId, propertyId, updatePropertyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user property
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {UpdatePropertyRequest} updatePropertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserProperty(organizationId: number, projectId: number, propertyId: number, updatePropertyRequest: UpdatePropertyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserProperty(organizationId, projectId, propertyId, updatePropertyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary User properties list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userPropertiesList(organizationId: number, projectId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object & ListResponseMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userPropertiesList(organizationId, projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PropertiesApi - factory interface
 * @export
 */
export const PropertiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PropertiesApiFp(configuration)
    return {
        /**
         * 
         * @summary Event custom properties list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customPropertiesList(organizationId: number, projectId: number, options?: any): AxiosPromise<object & ListResponseMetadata> {
            return localVarFp.customPropertiesList(organizationId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Event properties list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventPropertiesList(organizationId: number, projectId: number, options?: any): AxiosPromise<object & ListResponseMetadata> {
            return localVarFp.eventPropertiesList(organizationId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of property values
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propertyValuesList(organizationId: number, projectId: number, inlineObject2: InlineObject2, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.propertyValuesList(organizationId, projectId, inlineObject2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update event property
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {string} propertyId Property ID
         * @param {UpdatePropertyRequest} updatePropertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventProperty(organizationId: number, projectId: number, propertyId: string, updatePropertyRequest: UpdatePropertyRequest, options?: any): AxiosPromise<Property> {
            return localVarFp.updateEventProperty(organizationId, projectId, propertyId, updatePropertyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user property
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} propertyId Property ID
         * @param {UpdatePropertyRequest} updatePropertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserProperty(organizationId: number, projectId: number, propertyId: number, updatePropertyRequest: UpdatePropertyRequest, options?: any): AxiosPromise<Property> {
            return localVarFp.updateUserProperty(organizationId, projectId, propertyId, updatePropertyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary User properties list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPropertiesList(organizationId: number, projectId: number, options?: any): AxiosPromise<object & ListResponseMetadata> {
            return localVarFp.userPropertiesList(organizationId, projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PropertiesApi - object-oriented interface
 * @export
 * @class PropertiesApi
 * @extends {BaseAPI}
 */
export class PropertiesApi extends BaseAPI {
    /**
     * 
     * @summary Event custom properties list
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public customPropertiesList(organizationId: number, projectId: number, options?: any) {
        return PropertiesApiFp(this.configuration).customPropertiesList(organizationId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Event properties list
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public eventPropertiesList(organizationId: number, projectId: number, options?: any) {
        return PropertiesApiFp(this.configuration).eventPropertiesList(organizationId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of property values
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {InlineObject2} inlineObject2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public propertyValuesList(organizationId: number, projectId: number, inlineObject2: InlineObject2, options?: any) {
        return PropertiesApiFp(this.configuration).propertyValuesList(organizationId, projectId, inlineObject2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update event property
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {string} propertyId Property ID
     * @param {UpdatePropertyRequest} updatePropertyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public updateEventProperty(organizationId: number, projectId: number, propertyId: string, updatePropertyRequest: UpdatePropertyRequest, options?: any) {
        return PropertiesApiFp(this.configuration).updateEventProperty(organizationId, projectId, propertyId, updatePropertyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user property
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {number} propertyId Property ID
     * @param {UpdatePropertyRequest} updatePropertyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public updateUserProperty(organizationId: number, projectId: number, propertyId: number, updatePropertyRequest: UpdatePropertyRequest, options?: any) {
        return PropertiesApiFp(this.configuration).updateUserProperty(organizationId, projectId, propertyId, updatePropertyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary User properties list
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public userPropertiesList(organizationId: number, projectId: number, options?: any) {
        return PropertiesApiFp(this.configuration).userPropertiesList(organizationId, projectId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QueryApi - axios parameter creator
 * @export
 */
export const QueryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Funnel query
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {FunnelQuery} [funnelQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        funnelQuery: async (organizationId: number, projectId: number, funnelQuery?: FunnelQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('funnelQuery', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('funnelQuery', 'projectId', projectId)
            const localVarPath = `/organizations/{organization_id}/projects/{project_id}/reports/funnel`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(funnelQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryApi - functional programming interface
 * @export
 */
export const QueryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Funnel query
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {FunnelQuery} [funnelQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async funnelQuery(organizationId: number, projectId: number, funnelQuery?: FunnelQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataTableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.funnelQuery(organizationId, projectId, funnelQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QueryApi - factory interface
 * @export
 */
export const QueryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueryApiFp(configuration)
    return {
        /**
         * 
         * @summary Funnel query
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {FunnelQuery} [funnelQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        funnelQuery(organizationId: number, projectId: number, funnelQuery?: FunnelQuery, options?: any): AxiosPromise<DataTableResponse> {
            return localVarFp.funnelQuery(organizationId, projectId, funnelQuery, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export class QueryApi extends BaseAPI {
    /**
     * 
     * @summary Funnel query
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {FunnelQuery} [funnelQuery] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public funnelQuery(organizationId: number, projectId: number, funnelQuery?: FunnelQuery, options?: any) {
        return QueryApiFp(this.configuration).funnelQuery(organizationId, projectId, funnelQuery, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReportsApi - axios parameter creator
 * @export
 */
export const ReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create report
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {CreateReportRequest} createReportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReport: async (organizationId: number, projectId: number, createReportRequest: CreateReportRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createReport', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createReport', 'projectId', projectId)
            // verify required parameter 'createReportRequest' is not null or undefined
            assertParamExists('createReport', 'createReportRequest', createReportRequest)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/reports`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createReportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete report
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} reportId Report ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReport: async (organizationId: number, projectId: number, reportId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteReport', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteReport', 'projectId', projectId)
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('deleteReport', 'reportId', reportId)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/reports/{report_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Event segmentation query
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {EventSegmentation} [eventSegmentation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventSegmentationQuery: async (organizationId: number, projectId: number, eventSegmentation?: EventSegmentation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('eventSegmentationQuery', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('eventSegmentationQuery', 'projectId', projectId)
            const localVarPath = `/organizations/{organization_id}/projects/{project_id}/reports/event-segmentation`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventSegmentation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get report
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} reportId Report ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReport: async (organizationId: number, projectId: number, reportId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getReport', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getReport', 'projectId', projectId)
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('getReport', 'reportId', reportId)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/reports/{report_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsList: async (organizationId: number, projectId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('reportsList', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('reportsList', 'projectId', projectId)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/reports`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update report
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} reportId Report ID
         * @param {UpdateReportRequest} updateReportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReport: async (organizationId: number, projectId: number, reportId: number, updateReportRequest: UpdateReportRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateReport', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateReport', 'projectId', projectId)
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('updateReport', 'reportId', reportId)
            // verify required parameter 'updateReportRequest' is not null or undefined
            assertParamExists('updateReport', 'updateReportRequest', updateReportRequest)
            const localVarPath = `/v1/organizations/{organization_id}/projects/{project_id}/reports/{report_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateReportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportsApi - functional programming interface
 * @export
 */
export const ReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create report
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {CreateReportRequest} createReportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReport(organizationId: number, projectId: number, createReportRequest: CreateReportRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReport(organizationId, projectId, createReportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete report
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} reportId Report ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReport(organizationId: number, projectId: number, reportId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReport(organizationId, projectId, reportId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Event segmentation query
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {EventSegmentation} [eventSegmentation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventSegmentationQuery(organizationId: number, projectId: number, eventSegmentation?: EventSegmentation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataTableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventSegmentationQuery(organizationId, projectId, eventSegmentation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get report
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} reportId Report ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReport(organizationId: number, projectId: number, reportId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReport(organizationId, projectId, reportId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reports list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsList(organizationId: number, projectId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object & ListResponseMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsList(organizationId, projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update report
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} reportId Report ID
         * @param {UpdateReportRequest} updateReportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReport(organizationId: number, projectId: number, reportId: number, updateReportRequest: UpdateReportRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReport(organizationId, projectId, reportId, updateReportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReportsApi - factory interface
 * @export
 */
export const ReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create report
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {CreateReportRequest} createReportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReport(organizationId: number, projectId: number, createReportRequest: CreateReportRequest, options?: any): AxiosPromise<Report> {
            return localVarFp.createReport(organizationId, projectId, createReportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete report
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} reportId Report ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReport(organizationId: number, projectId: number, reportId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteReport(organizationId, projectId, reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Event segmentation query
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {EventSegmentation} [eventSegmentation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventSegmentationQuery(organizationId: number, projectId: number, eventSegmentation?: EventSegmentation, options?: any): AxiosPromise<DataTableResponse> {
            return localVarFp.eventSegmentationQuery(organizationId, projectId, eventSegmentation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get report
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} reportId Report ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReport(organizationId: number, projectId: number, reportId: number, options?: any): AxiosPromise<Report> {
            return localVarFp.getReport(organizationId, projectId, reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports list
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsList(organizationId: number, projectId: number, options?: any): AxiosPromise<object & ListResponseMetadata> {
            return localVarFp.reportsList(organizationId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update report
         * @param {number} organizationId 
         * @param {number} projectId 
         * @param {number} reportId Report ID
         * @param {UpdateReportRequest} updateReportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReport(organizationId: number, projectId: number, reportId: number, updateReportRequest: UpdateReportRequest, options?: any): AxiosPromise<Report> {
            return localVarFp.updateReport(organizationId, projectId, reportId, updateReportRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReportsApi - object-oriented interface
 * @export
 * @class ReportsApi
 * @extends {BaseAPI}
 */
export class ReportsApi extends BaseAPI {
    /**
     * 
     * @summary Create report
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {CreateReportRequest} createReportRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public createReport(organizationId: number, projectId: number, createReportRequest: CreateReportRequest, options?: any) {
        return ReportsApiFp(this.configuration).createReport(organizationId, projectId, createReportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete report
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {number} reportId Report ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public deleteReport(organizationId: number, projectId: number, reportId: number, options?: any) {
        return ReportsApiFp(this.configuration).deleteReport(organizationId, projectId, reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Event segmentation query
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {EventSegmentation} [eventSegmentation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public eventSegmentationQuery(organizationId: number, projectId: number, eventSegmentation?: EventSegmentation, options?: any) {
        return ReportsApiFp(this.configuration).eventSegmentationQuery(organizationId, projectId, eventSegmentation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get report
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {number} reportId Report ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getReport(organizationId: number, projectId: number, reportId: number, options?: any) {
        return ReportsApiFp(this.configuration).getReport(organizationId, projectId, reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports list
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsList(organizationId: number, projectId: number, options?: any) {
        return ReportsApiFp(this.configuration).reportsList(organizationId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update report
     * @param {number} organizationId 
     * @param {number} projectId 
     * @param {number} reportId Report ID
     * @param {UpdateReportRequest} updateReportRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public updateReport(organizationId: number, projectId: number, reportId: number, updateReportRequest: UpdateReportRequest, options?: any) {
        return ReportsApiFp(this.configuration).updateReport(organizationId, projectId, reportId, updateReportRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


